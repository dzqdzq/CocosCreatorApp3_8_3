"use strict";var AxisName,__importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),defines_1=require("./defines"),external_1=__importDefault(require("./external")),controller_shape_1=__importDefault(require("./controller-shape")),controller_shape_collider_1=require("./controller-shape-collider"),engine_1=__importDefault(require("./engine")),NodeUtils=external_1.default.NodeUtils,{CullMode,create3DNode,addMeshToNode,setMeshColor,setNodeOpacity,createMesh,createDynamicMesh,updateDynamicMesh}=engine_1.default,EditorMath=external_1.default.EditorMath;!function(e){e.x="x",e.y="y",e.z="z",e.neg_x="neg_x",e.neg_y="neg_y",e.neg_z="neg_z"}(AxisName=AxisName||{});class ControllerUtils{static arrow(e,t,a,r,c={}){var o=create3DNode("arrow");let n=5;void 0!==c.bodyBBSize&&null!==c.bodyBBSize&&(n=c.bodyBBSize);var l={noDepthTestForLines:!0},i=(Object.assign(l,c),controller_shape_1.default.calcLineData(new cc_1.Vec3(0,0,0),new cc_1.Vec3(0,a,0))),i=this.createShapeByData(i,r,l);if(i.name="ArrowLine",i.parent=o,setMeshColor(i,r),0<n){i=controller_shape_1.default.calcCylinderData(n,n,a,l),i=this.createShapeByData(i,r,l);i.name="ArrowBody",i.parent=o,setNodeOpacity(i,0),i.setPosition(new cc_1.Vec3(0,a/2,0));const s=i.addComponent(controller_shape_collider_1.ControllerShapeCollider);s.isDetectMesh=!0,s.isRender=!1}l={cullMode:CullMode.BACK},Object.assign(l,c),i=controller_shape_1.default.calcConeData(t,e),c=this.createShapeByData(i,r,l);c.parent=o,c.name="ArrowHead",c.setPosition(new cc_1.Vec3(0,a+e/2,0));const s=c.addComponent(controller_shape_collider_1.ControllerShapeCollider);return s.isDetectMesh=!1,o}static quad(e,t,a,r=new cc_1.Vec3(0,0,1),c=cc_1.Color.RED,o={}){e=controller_shape_1.default.calcQuadData(e,t,a,r,o.needBoundingBox),t=this.createShapeByData(e,c,o);return t.name="Quad",t}static borderPlane(e,t,a,r){var c=e/2,o=t/2;const n=create3DNode("borderPlane");e=controller_shape_1.default.calcQuadData(new cc_1.Vec3,e,t),e=this.createShapeByData(e,a,{unlit:!0});e.name="Plane",setNodeOpacity(e,r),e.parent=n;e.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1;r=(e,t,a)=>{e=controller_shape_1.default.calcLineData(e,t),t=this.createShapeByData(e,a,{alpha:200,noDepthTestForLines:!0});return t.name="BorderLine",t.parent=n,t};return r(new cc_1.Vec3(0,t/2,0),new cc_1.Vec3(c,t/2,0),a),r(new cc_1.Vec3(c,o,0),new cc_1.Vec3(c,0,0),a),n}static circle(e,t,a,r){e=controller_shape_1.default.calcCircleData(e,t,a),t=this.createShapeByData(e,r);return t.name="Circle",t}static torus(e,t,a,r){e=controller_shape_1.default.torus(e,t,a),t={cullMode:CullMode.BACK},a=this.createShapeByData(e,r,t),a.name="Torus",e=a.addComponent(controller_shape_collider_1.ControllerShapeCollider);return e.isDetectMesh=!0,e.isRender=!1,a}static cube(e,t,a,r,c,o={}){e=controller_shape_1.default.calcCubeData(e,t,a,c),null==o.cullMode&&(o.cullMode=CullMode.BACK),t=this.createShapeByData(e,r,o);return t.name="Cube",t.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,t}static scaleSlider(e,t,a,r={}){var c=create3DNode("scaleSlider"),o=this.cube(e,e,e,a,void 0,r),o=(o.name="ScaleSliderHead",o.parent=c,o.setPosition(0,t+e/2,0),{noDepthTestForLines:!0}),e=(Object.assign(o,r),controller_shape_1.default.lineWithBoundingBox(t)),r=this.createShapeByData(e,a,o);return r.name="ScaleSliderBody",r.parent=c,r.eulerAngles=new cc_1.Vec3(0,0,90),r.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,c}static getCameraDistanceFactor(e,t){t=NodeUtils.getWorldPosition3D(t);return cc_1.Vec3.distance(e,t)}static lineTo(e,t,a=cc_1.Color.RED,r={}){e=controller_shape_1.default.calcLineData(e,t),t=this.createShapeByData(e,a,r);return t.name="Line",t}static disc(e,t,a,r=cc_1.Color.RED,c={}){e=controller_shape_1.default.calcDiscData(e,t,a),t=this.createShapeByData(e,r,c);return t.name="Disc",t}static sector(e,t,a,r,c,o=cc_1.Color.RED,n={}){e=controller_shape_1.default.calcSectorData(e,t,a,r,c,60),t=this.createShapeByData(e,o,n);return t.name="Sector",t}static arc(e,t,a,r,c,o=cc_1.Color.RED,n={}){e=controller_shape_1.default.calcArcData(e,t,a,r,c),t=this.createShapeByData(e,o,n);return t.name="Arc",t}static arcDirectionLine(e,t,a,r,c,o,n,l=cc_1.Color.RED){e=controller_shape_1.default.arcDirectionLine(e,t,a,r,c,o,n),t=this.createShapeByData(e,l);return t.name="ArcDirectionLine",t}static lines(e,t,a=cc_1.Color.RED,r={}){e=controller_shape_1.default.calcLinesData(e,t),t=this.createShapeByData(e,a,r);return t.name="Lines",t}static wireframeBox(e,t,a,r={}){e=controller_shape_1.default.wireframeBox(e,t),t=this.createShapeByData(e,a,r);return t.name="WireFrameBox",t}static frustum(e,t,a,r,c,o,n,l={}){e=controller_shape_1.default.calcFrustum(e,t,a,r,c,o,!0),t=this.createShapeByData(e,n,l);return t.name="Frustum",t}static rectangle(e,t,a,r,c={}){e=controller_shape_1.default.calcRectangleData(e,t,a),t=this.createShapeByData(e,r,c);return t.name="Rectangle",t}static angle(e,t){var a=Math.sqrt(cc_1.Vec3.lengthSqr(e)*cc_1.Vec3.lengthSqr(t));return a<EditorMath.EPSILON?0:(e=EditorMath.clamp(cc_1.Vec3.dot(e,t)/a,-1,1),Math.acos(e)*EditorMath.R2D)}static sphere(e,t,a,r={},c){e=controller_shape_1.default.calcSphereData(e,t,r),t=this.createShapeByData(e,a,r,c);return t.name="SphereShape",t}static octahedron(e,t,a,r,c=.2,o,n={}){e=controller_shape_1.default.calcOctahedronData(e,t,a,r,c),t=this.createShapeByData(e,o,n);return t.name="OctahedronShape",t}static createShapeByData(e,t,a={},r){var c=create3DNode(a.name);return addMeshToNode(c,createMesh(e,a),a,r),setMeshColor(c,t),c}static create3DNode(e){return create3DNode(e)}static drawLines(e,t,a,r=cc_1.Color.RED){t=controller_shape_1.default.calcLinesData(t,a);let c=e.getComponent(cc_1.MeshRenderer);c?updateDynamicMesh(c,0,new defines_1.DynamicMeshPrimitive(t)):(addMeshToNode(e,createDynamicMesh(new defines_1.DynamicMeshPrimitive(t),{maxSubMeshes:1,maxSubMeshVertices:1024e3,maxSubMeshIndices:1024e3}),{depthTestForTriangles:!0,priority:127}),c=e.getComponent(cc_1.MeshRenderer)),null!==c&&void 0!==c&&c.onGeometryChanged(),setMeshColor(e,r)}static findMinPosition(e){return(0,cc_1.v3)(Math.min(...e.map(e=>e.x)),Math.min(...e.map(e=>e.y)),Math.min(...e.map(e=>e.z)))}static findMaxPosition(e){return(0,cc_1.v3)(Math.max(...e.map(e=>e.x)),Math.max(...e.map(e=>e.y)),Math.max(...e.map(e=>e.z)))}}ControllerUtils.AxisName=AxisName,ControllerUtils.axisDirectionMap={x:new cc_1.Vec3(1,0,0),y:new cc_1.Vec3(0,1,0),z:new cc_1.Vec3(0,0,1),neg_x:new cc_1.Vec3(-1,0,0),neg_y:new cc_1.Vec3(0,-1,0),neg_z:new cc_1.Vec3(0,0,-1)},exports.default=ControllerUtils;const flat=(e,t)=>e.map(t).reduce((e,t)=>e.concat(t),[]);