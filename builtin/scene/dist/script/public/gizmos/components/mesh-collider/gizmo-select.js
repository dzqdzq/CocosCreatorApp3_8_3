"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),external_1=__importDefault(require("../../utils/external")),base_1=require("../base"),controller_mesh_1=__importDefault(require("./controller-mesh")),NodeUtils=external_1.default.NodeUtils,tempQuat_a=new cc_1.Quat;class MeshColliderGizmo extends base_1.SelectGizmo{init(){this._controller=new controller_mesh_1.default(this.getGizmoRoot())}onShow(){this.updateControllerData()}onHide(){this._controller.hide()}updateControllerData(){if(this._isInitialized&&null!==this.target&&this.target instanceof cc_1.MeshCollider){var e=this.target.node,t=NodeUtils.getWorldScale3D(e),r=NodeUtils.getWorldPosition3D(e),i=tempQuat_a,e=(NodeUtils.getWorldRotation3D(e,i),this._controller.setScale(t),this._controller.setPosition(r),this._controller.setRotation(i),this.target),t=e.mesh;if(t){this._controller.show();var r=this.calcMeshData(t),o=r.points,l=e.center;for(let e=0;e<o.length;e+=3)o[e]+=l.x,o[e+1]+=l.y,o[e+2]+=l.z;this._controller.updateData(o,r.indices)}else this._controller.hide()}}calcMeshData(t){let r=[],i=[];var o=null==t?void 0:t.renderingSubMeshes.length;for(let e=0;e<o;e++){var l,s=t.renderingSubMeshes[e],a=s.geometricInfo;a&&(s=s.primitiveMode,l=a.positions,a=a.indices,l=this._generateWireFrameData(l,r.length/3,a,s))&&(r=r.concat(l.positions),i=i.concat(l.edgeIndices))}return{points:r,indices:i}}_generateWireFrameData(e,r,i,t){if(!i)return console.error("indexBuffer of mesh is undefined"),null;let o=[];var l=[];if(t===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){o=Array.from(e);var s=i.length/3;for(let e=0;e<s;e++){var a=i[3*e+0]+r,n=i[3*e+1]+r,c=i[3*e+2]+r;l.push(a,n,n,c,c,a)}}else if(t===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){o=Array.from(e);var d=i.length-2;let t=0;for(let e=0;e<d;e++){var h=i[e-t]+r,_=i[e+t+1]+r,u=i[e+2]+r;l.push(h,_,_,u,u,h),t=~t}}else if(t===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){o=Array.from(e);var f=i.length-2,g=i[0]+r;for(let e=0;e<f;e+=1){var m=i[e+1]+r,p=i[e+2]+r;l.push(g,m,m,p,p,g)}}return{positions:o,edgeIndices:l}}onTargetUpdate(){this.updateControllerData()}onNodeChanged(){this.updateControllerData()}}exports.default=MeshColliderGizmo;