"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MVec2=void 0;const cc_1=require("cc"),utils_1=require("./utils");let _x=0,_y=0;const v2_1=new cc_1.Vec2,v2_2=new cc_1.Vec2;class MVec2{static clone(t){return new cc_1.Vec2(t.x,t.y)}static copy(t,e){return t.x=e.x,t.y=e.y,t}static set(t,e,r){return t.x=e,t.y=r,t}static add(t,e,r){return t.x=e.x+r.x,t.y=e.y+r.y,t}static subtract(t,e,r){return t.x=e.x-r.x,t.y=e.y-r.y,t}static multiply(t,e,r){return t.x=e.x*r.x,t.y=e.y*r.y,t}static divide(t,e,r){return t.x=e.x/r.x,t.y=e.y/r.y,t}static ceil(t,e){return t.x=Math.ceil(e.x),t.y=Math.ceil(e.y),t}static floor(t,e){return t.x=Math.floor(e.x),t.y=Math.floor(e.y),t}static min(t,e,r){return t.x=Math.min(e.x,r.x),t.y=Math.min(e.y,r.y),t}static max(t,e,r){return t.x=Math.max(e.x,r.x),t.y=Math.max(e.y,r.y),t}static round(t,e){return t.x=Math.round(e.x),t.y=Math.round(e.y),t}static multiplyScalar(t,e,r){return t.x=e.x*r,t.y=e.y*r,t}static scaleAndAdd(t,e,r,x){return t.x=e.x+r.x*x,t.y=e.y+r.y*x,t}static distance(t,e){return _x=e.x-t.x,_y=e.y-t.y,Math.sqrt(_x*_x+_y*_y)}static squaredDistance(t,e){return _x=e.x-t.x,_y=e.y-t.y,_x*_x+_y*_y}static len(t){return _x=t.x,_y=t.y,Math.sqrt(_x*_x+_y*_y)}static lengthSqr(t){return _x=t.x,_y=t.y,_x*_x+_y*_y}static negate(t,e){return t.x=-e.x,t.y=-e.y,t}static inverse(t,e){return t.x=1/e.x,t.y=1/e.y,t}static inverseSafe(t,e){return _x=e.x,_y=e.y,Math.abs(_x)<utils_1.EPSILON?t.x=0:t.x=1/_x,Math.abs(_y)<utils_1.EPSILON?t.y=0:t.y=1/_y,t}static normalize(t,e){_x=e.x,_y=e.y;e=_x*_x+_y*_y;return 0<e&&(e=1/Math.sqrt(e),t.x=_x*e,t.y=_y*e),t}static dot(t,e){return t.x*e.x+t.y*e.y}static cross(t,e,r){return t.x=t.y=0,t.z=e.x*r.y-e.y*r.x,t}static lerp(t,e,r,x){return _x=e.x,_y=e.y,t.x=_x+x*(r.x-_x),t.y=_y+x*(r.y-_y),t}static random(t,e){e=e||1;var r=2*(0,utils_1.random)()*Math.PI;return t.x=Math.cos(r)*e,t.y=Math.sin(r)*e,t}static transformMat3(t,e,r){return _x=e.x,_y=e.y,t.x=r.m00*_x+r.m03*_y+r.m06,t.y=r.m01*_x+r.m04*_y+r.m07,t}static transformMat4(t,e,r){return _x=e.x,_y=e.y,t.x=r.m00*_x+r.m04*_y+r.m12,t.y=r.m01*_x+r.m05*_y+r.m13,t}static str(t){return`Vec2(${t.x}, ${t.y})`}static toArray(t,e,r=0){return t[r+0]=e.x,t[r+1]=e.y,t}static fromArray(t,e,r=0){return t.x=e[r+0],t.y=e[r+1],t}static strictEquals(t,e){return t.x===e.x&&t.y===e.y}static equals(t,e,r=utils_1.EPSILON){return Math.abs(t.x-e.x)<=r*Math.max(1,Math.abs(t.x),Math.abs(e.x))&&Math.abs(t.y-e.y)<=r*Math.max(1,Math.abs(t.y),Math.abs(e.y))}static angle(t,e){cc_1.Vec2.normalize(v2_1,t),cc_1.Vec2.normalize(v2_2,e);t=cc_1.Vec2.dot(v2_1,v2_2);return 1<t?0:t<-1?Math.PI:Math.acos(t)}}(exports.MVec2=MVec2).ZERO=Object.freeze(new cc_1.Vec2(0,0)),MVec2.ONE=Object.freeze(new cc_1.Vec2(1,1)),MVec2.NEG_ONE=Object.freeze(new cc_1.Vec2(-1,-1)),MVec2.UNIT_X=Object.freeze(new cc_1.Vec2(1,0)),MVec2.UNIT_Y=Object.freeze(new cc_1.Vec2(0,1));