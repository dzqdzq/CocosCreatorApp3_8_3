"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.EditorAnimationAuxCurve=exports.createEditorCurve=exports.syncToRealCurve=void 0;const cc_1=require("cc"),editor_animation_curve_base_1=__importDefault(require("./editor-animation-curve-base")),utils_1=require("./utils"),dump_1=__importDefault(require("../../../export/dump"));function syncToRealCurve(e,t){const a=e.getClipSample();var r=e.keyframeData.map(e=>[e.frame/a,{value:e.value,interpolationMode:e.interpMode,leftTangent:e.inTangent,rightTangent:e.outTangent,leftTangentWeight:e.inTangentWeight,rightTangentWeight:e.outTangentWeight,tangentWeightMode:e.tangentWeightMode}]);return t.assignSorted(r),t.preExtrapolation=e.preExtrap,t.postExtrapolation=e.postExtrap,t}function createEditorCurve(e,t,a,r){return EditorAnimationAuxCurve.create(e,t,a,r)}exports.syncToRealCurve=syncToRealCurve,exports.createEditorCurve=createEditorCurve;class EditorAnimationAuxCurve extends editor_animation_curve_base_1.default{constructor(e,t){super(),this._node=e,this._clipData=t}static create(e,t,a,r){a=new EditorAnimationAuxCurve(a,r);return a.initFromCurve({displayName:e,nodePath:"",propKey:"",propName:e,targetPaths:new cc_1.animation.TrackPath,type:{value:"Float"}},t),a}get targetPaths(){return this._curveInfo.targetPaths}get displayName(){return this._curveInfo.displayName}async getDumpData(){var e=utils_1.utils.dumpKeyframeData(this._keyframeData),t=null==(t=this._curveInfo.type)?void 0:t.value,t=utils_1.utils.isTypeSupportCurve(t);return{nodePath:"",keyframes:e,displayName:this.displayName,key:this.displayName,type:this._curveInfo.type,preExtrap:this.preExtrap,postExtrap:this.postExtrap,isCurveSupport:t}}getCompName(){return this._curveInfo.compName}getPropName(){return this._curveInfo.propName}changeNodePath(e){throw new Error("Method not supported.")}queryKeyIndex(t){if(this._keyframeData)for(let e=0;e<this._keyframeData.length;e++)if(this._keyframeData[e].frame===t)return e;return-1}queryKeyframe(t){if(this._keyframeData)for(let e=0;e<this._keyframeData.length;e++){var a=this._keyframeData[e];if(a.frame===t)return a}return null}getValidKeys(t){if(!this._keyframeData)return null;var a=[];for(let e=0;e<this._keyframeData.length;e++){var r=this._keyframeData[e].frame;t.includes(r)&&a.push(r)}return a}hasKey(e){return null!==this.queryKeyframe(e)}async createKey(t=0,a){var r=this.propData;let i;i=void 0!==(null==a?void 0:a.newValue)?null==a?void 0:a.newValue:({curve:n,sample:u}=this._getMockCurve(),n.evaluate(t/u));var n=this.queryKeyframe(t);if(n)n.value=i,a&&utils_1.utils.copyCurveData(a,n);else{let e=0;for(e=0;e<this._keyframeData.length&&!(this._keyframeData[e].frame>t);e++);var u={frame:t,value:i,interpMode:cc_1.RealInterpolationMode.LINEAR};utils_1.utils.isTypeSupportCurve(null==(n=r.type)?void 0:n.value)&&(u.inTangent=0,u.inTangentWeight=1,u.outTangent=0,u.outTangentWeight=1,u.tangentWeightMode=cc_1.TangentWeightMode.NONE,u.tangentMode=0),a&&utils_1.utils.copyCurveData(a,u),this._keyframeData.splice(e,0,u),this._isDirty=!0}return!0}async moveKeys(t,n){if(!this._keyframeData)return!1;var u=[];for(let e=0;e<t.length;e++){var a=t[e],a=this.queryKeyIndex(a);if(a<0)return!1;u.push(this._keyframeData[a]),this._keyframeData.splice(a,1)}for(let e=0;e<u.length;e++){var s=u[e];let t=s.frame+n[e],a=(t<0&&(t=0),0),r=!1,i=!1;if(0<this._keyframeData.length){for(let e=0;e<this._keyframeData.length;e++){var o=this._keyframeData[e].frame;if(o>=t){a=e,r=!0,o===t&&(i=!0);break}}r||(t<=this._keyframeData[0].frame?a=0:t>this._keyframeData[this._keyframeData.length-1].frame&&(a=this._keyframeData.length))}var l=i?1:0,h={frame:t,value:s.value};utils_1.utils.copyCurveData(s,h),this._keyframeData.splice(a,l,h)}return this._isDirty=!0}async removeKey(e){return e.forEach(e=>{e=this.queryKeyIndex(e);e<0||this._keyframeData.splice(e,1)}),this._isDirty=!0}async updateKey(t){for(let e=0;e<t.length;e++){var a=t[e];if(!this.queryKeyframe(a))return!1}return this._isDirty=!0}async copyKeysTo(t,a){for(let e=0;e<t.length;e++){var r,i=t[e],n=this.queryKeyframe(i);n&&(r={newValue:n.value},utils_1.utils.copyCurveData(n,r),await this.createKey(a+i-t[0],r))}return this._isDirty=!0}async spacingKeys(t,a){if(1<t.length){t.sort((e,t)=>e-t);var r=t[0],i=[],n=[];for(let e=1;e<t.length;e++)i.push(t[e]),n.push(r+e*a-t[e]);return this.moveKeys(i,n),this._isDirty=!0}return!1}async clearKeys(){return this._keyframeData=[],!0}async modifyCurveOfKey(e,t){e=this.queryKeyframe(e);return!!e&&(utils_1.utils.copyCurveData(t,e),this._isDirty=!0)}getCurveDuration(){let e=0;var t,a,r,i;return this._keyframeData&&0<this._keyframeData.length&&(t=this._keyframeData[this._keyframeData.length-1].frame,a=this.getCompName(),r=this.getPropName(),i=this.getClipSample(),e=a===cc_1.js.getClassName(cc_1.Sprite)&&"spriteFrame"===r?(t+1)/i:t/i),e}async getPropValueAtFrame(t){let a=null;var r=this.propData;if(0===this._keyframeData.length){var i=utils_1.utils.getDefaultValue(null==(i=r.type)?void 0:i.value);null!=i&&(a=dump_1.default.encodeObject(i,{default:void 0}))}else{var{sample:i,curve:n}=this._getMockCurve();let e=n.evaluate(t/i);null!==(e=null!==e&&void 0!==e?e:utils_1.utils.getDefaultValue(null==(n=r.type)?void 0:n.value))&&void 0!==e&&(a=dump_1.default.encodeObject(e,{default:void 0}))}return a}_getMockCurve(){const t=this.getClipSample();var e=new cc_1.RealCurve;return e.assignSorted(this._keyframeData.map(e=>[e.frame/t,{value:e.value,interpolationMode:e.interpMode,leftTangent:e.inTangent,rightTangent:e.outTangent,leftTangentWeight:e.inTangentWeight,rightTangentWeight:e.outTangentWeight,tangentWeightMode:e.tangentWeightMode}])),e.preExtrapolation=this.preExtrap,e.postExtrapolation=this.postExtrap,{sample:t,curve:e}}}exports.EditorAnimationAuxCurve=EditorAnimationAuxCurve;