"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,r,t,o){void 0===o&&(o=t);var a=Object.getOwnPropertyDescriptor(r,t);a&&("get"in a?r.__esModule:!a.writable&&!a.configurable)||(a={enumerable:!0,get:function(){return r[t]}}),Object.defineProperty(e,o,a)}:function(e,r,t,o){e[o=void 0===o?t:o]=r[t]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,r){Object.defineProperty(e,"default",{enumerable:!0,value:r})}:function(e,r){e.default=r}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var r={};if(null!=e)for(var t in e)"default"!==t&&Object.prototype.hasOwnProperty.call(e,t)&&__createBinding(r,e,t);return __setModuleDefault(r,e),r},__importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildScriptCommand=void 0;const fs_extra_1=__importDefault(require("fs-extra")),mod_lo_1=require("@cocos/creator-programming-mod-lo/lib/mod-lo"),creator_programming_rollup_plugin_mod_lo_1=__importDefault(require("@cocos/creator-programming-rollup-plugin-mod-lo")),to_named_register_1=__importDefault(require("../../utils/to-named-register")),url_1=require("url"),babel=__importStar(require("@babel/core")),rollup=__importStar(require("rollup")),rollup_plugin_sourcemaps_1=__importDefault(require("rollup-plugin-sourcemaps")),rollup_plugin_terser_1=require("rollup-plugin-terser"),path_1=__importStar(require("path")),pack_mods_1=require("../../utils/pack-mods"),creator_programming_common_1=require("@cocos/creator-programming-common"),minimatch_1=__importDefault(require("minimatch"));function relativeUrl(e,r){return(0,path_1.relative)(e,r).replace(/\\/g,"/")}let bundleIdToNameChunk;function matchPattern(e,r){return(0,minimatch_1.default)(e.replace(/\\/g,"/"),r.replace(/\\/g,"/"))}const useEditorFolderFeature=!1;function getExternalEditorModules(e){return Object.keys(e).filter(e=>"mapLocation"!==e)}async function genImportRestrictions(r,e){if(useEditorFolderFeature){var t=[],o=(t.length=0,[...e]);for(const l of r){var a=l.target;a&&(a=path_1.default.join(a,"**","editor","**/*"),o.push(a))}for(let e=0;e<r.length;++e){var n,s=r[e].target;s&&(n=path_1.default.join(s,"**/*"),s=path_1.default.join(s,"**","editor","**/*"),t[e]={importerPatterns:[n,"!"+s],banSourcePatterns:o})}return t}}async function buildScriptCommand(r){var t={scriptPackages:[],importMappings:{}};if(0!==r.bundles.length){const w=r.sourceMaps&&r.ccEnvConstants.NATIVE?"inline":r.sourceMaps;var N=Object.entries(r.ccEnvConstants).map(([e,r])=>`export const ${e} = ${r};`).join("\n"),{bundles:o,modulePreservation:a}=r,n=r.bundleCommonChunk=null!=(e=r.bundleCommonChunk)&&e,S={},T={};const y={},U=new Set,I=new Set;var q="preserve"===r.modulePreservation,s=e=>{e=e.facadeModuleId;return e&&(U.has(e)||I.has(e))?e:""},l=[];const P=r.dbInfos.map(e=>path_1.default.join(e.target,"**/editor/**/*"));for(let r=0;r<o.length;++r){var u=o[r],i=[];for(const D of u.scripts){const F=(0,url_1.pathToFileURL)(D.file).href;T[F]=D.uuid,"facade"!==a&&"preserve"!==a||useEditorFolderFeature&&P.some(e=>matchPattern((0,url_1.fileURLToPath)(F),e))||i.push(F),y[D.file]=r,q&&I.add(F)}var p="virtual:///prerequisite-imports/"+u.id;let e=u.scripts.map(e=>e.file);useEditorFolderFeature&&(e=e.filter(r=>!P.some(e=>matchPattern(r,e)))),S[p]=e.sort().map(e=>`import "${(0,url_1.pathToFileURL)(e).href}";`).join("\n"),y[p]=r,i.push(p),l.push(i),U.add(p)}if(!n){const x=[];l.forEach(e=>{x.push(...e)}),l.length=0,l.push(x)}var $,B,A,J,e=getExternalEditorModules(r.cceModuleMap),e=await genImportRestrictions(r.dbInfos,e),c=new mod_lo_1.ModLo({targets:r.transform.targets,loose:r.loose,exportsConditions:r.exportsConditions,guessCommonJsExports:r.guessCommonJsExports,useDefineForClassFields:r.useDefineForClassFields,allowDeclareFields:r.allowDeclareFields,_internalTransform:{excludes:null!=(d=null==(d=r.transform)?void 0:d.excludes)?d:[],includes:null!=(d=null==(d=r.transform)?void 0:d.includes)?d:[]},_compressUUID:e=>r.uuidCompressMap[e],_helperModule:creator_programming_rollup_plugin_mod_lo_1.default.helperModule,hot:r.hotModuleReload,importRestrictions:e,preserveSymlinks:r.preserveSymlinks}),d=r.importMap,m={},e=d?new url_1.URL(d.url):new url_1.URL("foo:/bar"),W=(m.imports={"cc/env":"virtual:/cc/env","cc/userland/macro":"virtual:/cc/userland/macro"},[]);for(const E of r.dbInfos){var Y=`db://${E.dbID}/`,V=(0,url_1.pathToFileURL)(path_1.default.join(E.target,path_1.default.join(path_1.default.sep))).href;m.imports[Y]=V,W.push(V)}if(d&&(d.json.imports&&(m.imports=Object.assign(Object.assign({},m.imports),d.json.imports)),d.json.scopes))for(var[z,G]of Object.entries(d.json.scopes)){var _=null!=(_=m.scopes)?_:m.scopes={};_[z]=Object.assign(Object.assign({},null!=(_=_[z])?_:{}),G)}c.setImportMap(m,e),c.setAssetPrefixes(W),c.addMemoryModule("virtual:/cc/env",N),c.addMemoryModule("virtual:/cc/userland/macro",r.customMacroList.map(e=>`export const ${e.key} = ${e.value};`).join("\n"));for([$,B]of Object.entries(S))c.addMemoryModule($,B);for([A,J]of Object.entries(T))c.setUUID(A,J);var f=[(0,creator_programming_rollup_plugin_mod_lo_1.default)({modLo:c})];"facade"!==a&&"erase"!==a||f.push(rpNamedChunk()),r.sourceMaps&&f.push((0,rollup_plugin_sourcemaps_1.default)()),r.debug||f.push((0,rollup_plugin_terser_1.terser)()),"erase"===a&&f.push({name:"cocos-creator/resolve-import-meta",resolveImportMeta(e,{moduleId:r}){if("url"===e)try{return`'${new url_1.URL(r).href}'`}catch(e){console.error(`Can not access import.meta.url of module '${r}'. '${r}' is not a valid URL.`)}}});const re="preserve"!==r.modulePreservation;var H=(e,r)=>{var t;re&&"object"==typeof e&&"EMPTY_BUNDLE"===e.code||"string"!=typeof e&&"CIRCULAR_DEPENDENCY"===e.code&&null!=(t=e.importer)&&t.includes("node_modules")||(t="object"==typeof e&&e.message||e,console.warn("[[Build.Script.Rollup]] "+t))},K={};for(let e=0;e<l.length;++e){var Q=l[e],h=(n&&(bundleIdToNameChunk=o[e].id),{input:Q,plugins:f,preserveModules:"erase"!==a,external:["cc"],onwarn:H}),h=await rollup.rollup(h),g={sourcemap:r.sourceMaps,exports:"named"},h=("preserve"===r.modulePreservation?g.format=r.moduleFormat:Object.assign(g,{format:"system",strict:!1,systemNullSetters:!0}),await h.generate(g));if("preserve"===r.modulePreservation){var v,b,X=r.commonDir;for(const O of h.output)"chunk"===O.type&&(b=O.fileName.match(/\.(js|ts|mjs)$/)?O.fileName:O.fileName+".js",v=path_1.default.join(X,b),await fs_extra_1.default.outputFile(v,O.code,"utf8"),v=s(O))&&(b=("./chunks/"+b).replace(/\\/g,"/"),K[v]=b)}else if(n){var Z,g=o[e],M=new ChunkBundler(g.outFile);for(const R of h.output)"chunk"===R.type&&(M.add(R),Z=s(R))&&M.addModuleMapping(Z,getChunkUrl(R));await M.write({sourceMaps:w,wrap:!1})}else{var g=path_1.default.join(r.commonDir,"bundle.js"),j=new ChunkBundler(g);let e=0;var C,ee,k=o.map(e=>new ChunkBundler(e.outFile));for(const L of h.output)"chunk"===L.type&&(C=!!L.facadeModuleId&&Q.includes(L.facadeModuleId),L.isEntry||C?(C=(e=>{let r=e["facadeModuleId"];if(!r)return-1;let t="",o=r;o.startsWith("file:///")||(o=(0,url_1.pathToFileURL)(r).href);var e=new url_1.URL(o);if((0,creator_programming_common_1.isCjsInteropUrl)(e)&&(e=(0,creator_programming_common_1.getCjsInteropTarget)(e),r=(0,url_1.fileURLToPath)(e.href)),r.startsWith("file:///"))try{t=(0,url_1.fileURLToPath)(r)}catch(e){return-1}else t=r;return null!=(e=y[t])?e:-1})(L))<0||void 0===k[C]?(console.warn(`Unexpected: entry chunk name ${L.name} is not in list.`),j.add(L),++e):(k[C].add(L),(ee=s(L))&&k[C].addModuleMapping(ee,getChunkUrl(L))):(j.add(L),++e));await Promise.all(k.map(async(e,r)=>{await e.write({sourceMaps:w,wrap:!1})})),e&&(await j.write({sourceMaps:w,wrap:!0}),t.scriptPackages.push(g))}}bundleIdToNameChunk=null,t.importMappings=K}return t}exports.buildScriptCommand=buildScriptCommand;class ChunkBundler{constructor(e){this._parts=[],this._chunkMappings={},this._out=e}add(e){this._parts.push([e.fileName,{code:e.code,map:null==(e=e.map)?void 0:e.toString()}])}addModuleMapping(e,r){this._chunkMappings[e]=r}async write(e){return(0,pack_mods_1.packMods)(this._parts.sort(([e],[r])=>e.localeCompare(r)).map(([,e])=>e),this._chunkMappings,this._out,e)}}function rpNamedChunk(){return{name:"named-chunk",renderChunk:async function(e,r,t){r=getChunkUrl(r),e=await babel.transformAsync(e,{sourceMaps:!0,compact:!1,plugins:[[to_named_register_1.default,{name:r}]]});return e?{code:e.code,map:e.map}:(this.warn("Failed to render chunk."),null)}}}function getChunkUrl(e){return bundleIdToNameChunk?`bundle://${bundleIdToNameChunk}/`+e.fileName:"chunks:///"+e.fileName}