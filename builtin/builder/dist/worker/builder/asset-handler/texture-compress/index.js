"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.queryCompressCache=exports.previewCompressImage=exports.TextureCompress=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),minimaps_1=require("./minimaps"),compress_tool_1=require("./compress-tool"),cc_1=require("cc"),asset_library_1=require("../../manager/asset-library"),utils_1=require("./utils"),plugin_1=require("../../../plugin"),metric_1=require("../../metric"),stream_1=require("stream"),os_1=require("os"),numCPUs=(0,os_1.cpus)().length,sharp_1=__importDefault(require("sharp")),lodash_1=__importDefault(require("lodash")),utils_2=require("../../../../share/utils");class TextureCompress extends stream_1.EventEmitter{constructor(e){super(),this._taskMap={},this._waitingCompressQueue=new Set,this._compressAssetLen=0,this._compressExecuteInfo=null,this.platform=e}static async initCommonOptions(){TextureCompress.allTextureCompressConfig=await Editor.Message.request("builder","query-compress-config"),(0,fs_extra_1.existsSync)(TextureCompress.storedCompressInfoPath)?TextureCompress.storedCompressInfo=(0,fs_extra_1.readJsonSync)(TextureCompress.storedCompressInfoPath):TextureCompress.storedCompressInfo={},TextureCompress.enableMipMaps=await Editor.Profile.getProject("builder","textureCompressConfig.genMipmaps")}async init(){await this.updateUserConfig()}async updateUserConfig(){await TextureCompress.initCommonOptions(),TextureCompress.userCompressConfig=await Editor.Profile.getProject("builder","textureCompressConfig");var e=TextureCompress.userCompressConfig["customConfigs"];const s={};e&&Object.values(e).length&&Object.values(e).forEach(e=>{e.overwrite&&(s[e.format]=e.id,console.debug(`compress format (${e.format}) will be overwrited by custom compress ${e.id}(${e.name})`))}),TextureCompress.overwriteFormats=s,TextureCompress._presetIdToCompressOption={}}static queryTextureCompressCache(e){return TextureCompress.storedCompressInfo[e]}addTask(e,s){return this._taskMap[e]?Object.assign(this._taskMap[e],s):this._taskMap[e]=s,this._taskMap[e]}addTaskWithAssetInfo(e){if(this._taskMap[e.uuid])return this._taskMap[e.uuid];if("auto-atlas"!==e.meta.importer){var s=this.genTaskInfoFromAssetInfo(e);if(s)return this._taskMap[e.uuid]=s}}genTaskInfoFromAssetInfo(e){if(this._taskMap[e.uuid])return this._taskMap[e.uuid];var s=e.meta.userData.compressSettings;if(!s||!s.useCompressTexture)return null;let t=e.extname;e.meta.files.includes(t)||(t="png");var r=e.library+t;if("auto-atlas"===e.meta.importer||r){var o=this.getCompressOptions(s.presetId);if(o)return{src:r,presetId:s.presetId,compressOptions:o,hasAlpha:e.meta.userData.hasAlpha,mtime:asset_library_1.buildAssetLibrary.getAssetProperty(e,"mtime"),hasMipmaps:!!TextureCompress.enableMipMaps&&(0,minimaps_1.checkHasMipMaps)(e.meta),dest:[],suffix:[]}}else console.warn("genTaskInfoFromAssetInfo failed ! Image asset does not exist: "+e.source)}getCompressOptions(e){if(TextureCompress._presetIdToCompressOption[e])return TextureCompress._presetIdToCompressOption[e];var{userPreset:s,defaultConfig:t,customConfigs:r}=TextureCompress.userCompressConfig;const{platformConfig:o,customFormats:i}=TextureCompress.allTextureCompressConfig;if(!o[this.platform])return null;var a=o[this.platform].textureCompressConfig;if(!a)return null;const m=a.platformType,u=s[e]||t[e]||t.default;if(!u||!u.options[m])return console.debug("Invalid compress task: "+JSON.stringify(u)),null;let n={};if(u.overwrite&&u.overwrite[this.platform])n=u.overwrite[this.platform];else{const c=a.support;Object.keys(u.options[m]).forEach(e=>{([...c.rgba,...c.rgb].includes(e)||Object.keys(i).includes(e))&&(n[e]=JSON.parse(JSON.stringify(u.options[m][e])))})}const p={};return r&&Object.values(r).length&&Object.values(r).forEach(e=>{e.overwrite&&(p[e.format]=e.id,console.debug(`compress format (${e.format}) will be overwrited by custom compress ${e.id}(${e.name})`))}),Object.keys(p).forEach(e=>{n[e]&&(n[p[e]]=n[e],delete n[e])}),Object.keys(n).length?TextureCompress._presetIdToCompressOption[e]=n:null}queryTask(e){return this._taskMap[e]}removeTask(e){delete this._taskMap[e]}async run(s=this._taskMap){console.group("Compress image...");var e,t=TextureCompress.userCompressConfig["customConfigs"],r=await this.sortImageTask(s);if(console.debug(`Num of all image compress task ${Object.keys(s).length}, really: ${this._compressAssetLen}, configTasks: `+r.length),collectCustomCompressInfo(t),r.length)return t=JSON.parse(JSON.stringify(r)),(e=plugin_1.pluginManager.getAssetHandlers("compressTextures")).pkgNameOrder.length&&(this.emit("update-progress","start compress custom compress hooks..."),Editor.Metrics.trackTimeStart("builder:custom-compress-texture"),await this.customCompressImage(t,e),await Editor.Metrics.trackTimeEnd("builder:custom-compress-texture",{output:!0})),this._waitingCompressQueue=new Set(t),Editor.Metrics.trackTimeStart("builder:compress-texture"),await this.executeCompressQueue(),e=await Editor.Metrics.trackTimeEnd("builder:compress-texture",{output:!0}),console.debug("builder:compress-texture: "+(0,utils_2.formatMSTime)(e)),await Promise.all(r.map(async e=>{(0,fs_extra_1.existsSync)(e.dest)?(s[e.uuid].dest.push(e.dest),s[e.uuid].suffix.push(e.suffix)):console.error(`texture compress task width asset ${e.uuid}, format: ${e.format} failed!`)})),await(0,fs_extra_1.outputJSON)(TextureCompress.storedCompressInfoPath,TextureCompress.storedCompressInfo),console.groupEnd(),console.debug("Num of sorted image asset: "+Object.keys(s).length),s;console.debug("No image need to compress"),console.groupEnd()}async sortImageTask(e){const a=[],{textureFormatConfigs:m,formatsInfo:u}=TextureCompress.allTextureCompressConfig,n=TextureCompress.userCompressConfig["customConfigs"],p={};for(const c of Object.keys(e)){const l=e[c],f=l.compressOptions;let o=[];if(l.hasMipmaps&&TextureCompress.enableMipMaps)try{var s=await(0,minimaps_1.genMipmapFiles)(l.src,asset_library_1.buildAssetLibrary.getAssetTempDirByUuid(c));if(!s.length)continue;o=s}catch(e){e instanceof Error&&(e.message=`{asset(${c})}`+e.message),console.warn(e);continue}var t=Object.keys(f);const r={};t.forEach(e=>n[e]&&(r[e]=n[e]));t={option:{mtime:l.mtime,src:l.src,compressOptions:f},mipmapFiles:o,customConfigs:r};const C=!lodash_1.default.isEqual(TextureCompress.storedCompressInfo[c]&&TextureCompress.storedCompressInfo[c].option,t.option);l.dest=[],l.dirty=C;let i=!(l.suffix=[]);Object.keys(f).forEach(e=>{let s=e;TextureCompress.userCompressConfig.customConfigs[e]&&(s=TextureCompress.userCompressConfig.customConfigs[e].format);var t,r=null==(r=u[s])?void 0:r.formatType;r?(t=(0,path_1.join)(TextureCompress.compressCacheDir,c.substr(0,2),c+m[r].suffix),!C&&(0,fs_extra_1.existsSync)(t)?(l.dest.push(t),l.suffix.push((0,utils_1.getSuffix)(u[s],m[r].suffix)),console.debug(`Use cache compress image of {Asset(${c})} ({link(${t})})`)):(l.dirty=!0,TextureCompress.userCompressConfig.customConfigs[e]&&increaseCustomCompressNum(TextureCompress.userCompressConfig.customConfigs[e]),i=!0,a.push({format:e,src:l.src,dest:t,compressOptions:f[e],customConfig:n[e],uuid:c,mipmapFiles:o,suffix:(0,utils_1.getSuffix)(u[s],m[r].suffix),formatType:r}),p[r]=(p[r]||0)+1)):console.error("Invalid format "+e)}),i&&this._compressAssetLen++,t.dest=l.dest,TextureCompress.storedCompressInfo[c]=t}return console.debug("sort compress task "+JSON.stringify(p)),a}executeCompressQueue(){return new Promise((e,s)=>{try{this._compressExecuteInfo={reject:s,resolve:e,state:"progress",busyFormatType:{},busyAsset:new Set,complete:0,total:this._waitingCompressQueue.size,childProcess:0},this.emit("update-progress","start compress task 0 / "+this._waitingCompressQueue.size);for(let e=0;e<this._compressAssetLen;e++){var t=this._getNextTask();t&&this._compressImage(t).catch(e=>{s(e)})}}catch(e){s(e)}})}_getNextTask(){for(const e of this._waitingCompressQueue.values())if(this._checkTaskCanExecute(e))return e;return null}_checkTaskCanExecute(e){var{busyAsset:s,busyFormatType:t}=this._compressExecuteInfo;return!(s.has(e.uuid)||t[e.formatType]&&!TextureCompress.allTextureCompressConfig.textureFormatConfigs[e.formatType].parallelism)}async _compressImage(e){var{busyAsset:s,busyFormatType:t,total:r,childProcess:o}=this._compressExecuteInfo;if(TextureCompress.allTextureCompressConfig.textureFormatConfigs[e.formatType].childProcess){if(o>numCPUs)return void console.debug(e.formatType+" wait for child process "+o);this._compressExecuteInfo.childProcess++}o=t[e.formatType];if(o&&0<o){if(!TextureCompress.allTextureCompressConfig.textureFormatConfigs[e.formatType].parallelism)return;t[e.formatType]=++o}else t[e.formatType]=1;s.add(e.uuid),this.emit("update-progress",`execute compress task ${this._compressExecuteInfo.complete}/${r}, ${s.size} in progress}`),this._waitingCompressQueue.delete(e);try{await this.compressImageByConfig(e)}catch(e){console.error(e)}this._compressExecuteInfo.childProcess--,s.delete(e.uuid),t[e.formatType]=--t[e.formatType],this._compressExecuteInfo.complete++,await this._step()}async _step(){var e,s;if(!this._waitingCompressQueue.size)return{busyAsset:e,resolve:s}=this._compressExecuteInfo,e.size?void 0:s();(e=this._getNextTask())&&this._compressImage(e)}async customCompressImage(s,t){for(let e=0;e<t.pkgNameOrder.length;e++){var r=t.pkgNameOrder[e],o=t.handles[r];if(o)try{return console.debug(`Start custom compress(${r})`),await o(s)}catch(e){console.error(e),console.error(`Custom Compress (${r}) failed!`)}}}async compressImageByConfig(s){var e,t,r=s["dest"];let o=s.src;await(0,fs_extra_1.ensureDir)((0,path_1.dirname)(r));try{if(100===s.compressOptions.quality&&(0,path_1.extname)(s.src).endsWith(s.format))return console.log(`${s.format} with quality is 100, will copy the image from ${s.src} to `+s.dest),void await(0,fs_extra_1.copy)(s.src,s.dest,{overwrite:!0})}catch(e){console.warn(e)}".webp"===(0,path_1.extname)(o)&&(r=(0,sharp_1.default)(o),o=o.replace("webp","png"),await r.toFile(o));let i;if(s.customConfig)try{return console.debug(`start custom compress config ${s.format}(${s.customConfig.name})`),await(0,compress_tool_1.compressCustomFormat)(Object.assign(Object.assign({},s),{src:o})),void console.debug("Custom compress config",`${s.format}(${s.customConfig.name})`,"sucess")}catch(e){if(console.warn(`Compress {asset(${s.uuid})} with custom config failed!`),console.warn(e),!(i=(0,compress_tool_1.getCompressFunc)(s.customConfig.format)))return void console.warn("Invalid format "+s.customConfig.format)}if(i=i||(0,compress_tool_1.getCompressFunc)(s.format)){if(await i(Object.assign(Object.assign({},s),{src:o})),TextureCompress.enableMipMaps)try{var a,m=await(0,minimaps_1.compressMipmapFiles)(Object.assign(Object.assign({},s),{src:o}),i);m.length&&(m.splice(0,0,(0,fs_extra_1.readFileSync)(s.dest)),a=cc_1.ImageAsset.mergeCompressedTextureMips(m),await(0,fs_extra_1.outputFile)(s.dest,a))}catch(e){console.error(e),await(0,fs_extra_1.remove)(s.dest),console.error(`Generate {asset(${s.uuid})} compress texture mipmap files failed!`)}try{(0,path_1.extname)(s.src).endsWith(s.format)&&(e=await(0,fs_extra_1.stat)(s.src),(t=await(0,fs_extra_1.stat)(s.dest)).size>e.size)&&(console.log(`The compressed image(${s.dest}) size(${t.size}) is larger than the original image(${s.src}) size(${e.size}), and the original image will be used. To ignore this protection mechanism, please configure it in Project Settings -> Texture Compression Configuration.`),await(0,fs_extra_1.copy)(s.src,s.dest,{overwrite:!0}))}catch(e){console.warn(e)}}else console.warn("Invalid format "+s.format)}}async function previewCompressImage(e,s="web-mobile"){s=new TextureCompress(s),await s.init(),e=asset_library_1.buildAssetLibrary.getAsset(e),e=s.addTaskWithAssetInfo(e);if(e)return await s.run(),e}async function queryCompressCache(e){return await TextureCompress.initCommonOptions(),TextureCompress.queryTextureCompressCache(e)}function increaseCustomCompressNum(e){e&&(e.num||(e.num=0),e.num++)}function collectCustomCompressInfo(e){let s=0;Object.values(e).map(e=>{e.num&&(s+=e.num,e=(0,utils_1.changeInfoToLabel)({format:e.format,overwrite:e.overwrite,value:e.num,file:(0,path_1.basename)(e.path),command:e.command}),(0,metric_1.sendSingleMetric)({category:"Build",action:"custom-compress",label:e}),(0,metric_1.sendSingleMetric)({sendToNewCocosAnalyticsOnly:!0,category:"buildSystem",value:{B100040:e}}))}),(0,metric_1.sendSingleMetric)({sendToNewCocosAnalyticsOnly:!0,category:"buildSystem",value:{B100145:s}})}(exports.TextureCompress=TextureCompress).overwriteFormats={},TextureCompress._presetIdToCompressOption={},TextureCompress.compressCacheDir=(0,path_1.join)(Editor.Project.path,"temp","builder","CompressTexture"),TextureCompress.storedCompressInfo={},TextureCompress.storedCompressInfoPath=(0,path_1.join)(TextureCompress.compressCacheDir,"compress-info.json"),TextureCompress.enableMipMaps=!1,exports.previewCompressImage=previewCompressImage,exports.queryCompressCache=queryCompressCache;