"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.packer=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),config_1=require("./config"),pac_info_1=require("./pac-info"),Algorithm=require("./algorithm"),Sharp=require("sharp"),applyBleed=require("./bleeding").applyBleed;async function packer(t,e){var r=filterUnpacked(t),a=(console.debug("Start trim sprite image ..."),await trimImages(r.result),console.debug("determine atlas size..."),determineAtlasSize(r.result,e)),r=Array.from(r.unpackedImages.concat(a.unpackedImages));return console.debug("Start generate atlas image..."),await Promise.all(a.packAtlas.map(t=>generateAtlas(t,e))),{atlases:a.packAtlas.map(t=>t.toJSON()),unpackedImages:r.map(t=>({imageUuid:t.uuid,libraryPath:t._file})),pacUuid:t[0]._pacUuid}}function determineAtlasSize(t,a){const i=t.concat();var o=[];let n=[],h=Algorithm[a.algorithm];h||(console.warn(`determineAtlasSize failed: Can not find algorithm ${a.algorithm}, use MaxRects`),h=Algorithm.MaxRects);var l=a.maxWidth,d=a.maxHeight,s=a.allowRotation;let c=0;for(;0<i.length;){var p=h(i,l,d,s);if(0===p.length){n=n.concat(i);break}p.forEach(t=>{i.splice(i.indexOf(t),1)});let e=0,r=0;for(let t=0;t<p.length;t++){var g=p[t],m=(g.rotatedWidth=g.rotated?g.height:g.width,g.rotatedHeight=g.rotated?g.width:g.height,g.trim.rotatedWidth=g.rotated?g.trim.height:g.trim.width,g.trim.rotatedHeight=g.rotated?g.trim.width:g.trim.height,g.x+g.rotatedWidth),g=g.y+g.rotatedHeight;m>e&&(e=m),g>r&&(r=g)}var u=a.name+"-"+c,f=(c++,(0,path_1.join)(a.destDir,u+"."+a.format));o.push(new pac_info_1.AtlasInfo(p,e,r,u,f))}return o.forEach(t=>{applySquareAndPowerConstraints(t,a.forceSquared,a.powerOfTwo),t.spriteFrameInfos.forEach(t=>{t.trim.x=t.x+a.padding+a.bleed,t.trim.y=t.y+a.padding+a.bleed})}),{packAtlas:o,unpackedImages:n}}function applySquareAndPowerConstraints(t,e,r){e&&(t.width=t.height=Math.max(t.width,t.height)),r&&(t.width=roundToPowerOfTwo(t.width),t.height=roundToPowerOfTwo(t.height))}function roundToPowerOfTwo(t){if("number"!=typeof t)return 0;let e=2;for(;t>e;)e*=2;return e}function filterUnpacked(t){const e=[];t=t.filter(t=>0<t.trim.width&&0<t.trim.height||(t.width=t.rawWidth,t.height=t.rawHeight,e.push(t),!1));return{unpackedImages:e,result:t}}async function generateAtlas(t,e){var r=t.spriteFrameInfos;const a=t.width,i=t.height;var o={raw:{width:a,height:i,channels:4}};let n=await Sharp({create:{width:a,height:i,channels:4,background:{r:0,b:0,g:0,alpha:0}}}).toBuffer();let h=0;let l=0,d=[];for(let t=0;t<r.length;t++){var s=r[t],c=s.trim.x,p=s.trim.y;const a=s.trim.width,i=s.trim.height;h+=a*i*4,l++;try{(2097152<=h||100<=l)&&(n=await Sharp(n,o).composite(d).toBuffer(),d=[],h=0,l=0);let t=Sharp(s._libraryPath);var g=await(t=s.rotated?t.rotate(90):t).toBuffer();d.push({input:g,left:c,top:p})}catch(t){console.error(`Handle image [${s._libraryPath} error]. 
 Origin path is [${s.originalPath}:${s.name}]. 
 Error : `+t.toString());continue}}n=await Sharp(n,o).composite(d).toBuffer(),(e.contourBleed||e.paddingBleed)&&applyBleed(e,t,n,n),await Sharp(n,o).png().toFile(t.imagePath)}async function trimImages(t){const r=(0,path_1.join)(config_1.buildTempDir,"trimImages");(0,fs_extra_1.ensureDirSync)(r),await Promise.all(t.map((e,t)=>{e.originalPath=e._libraryPath,e._libraryPath=(0,path_1.join)(r,"spritesheet_js_"+e.uuid+"_image_"+t+++".png");t=e.trim,t=Sharp(e.originalPath).extract({left:t.x,top:t.y,width:t.rotatedWidth,height:t.rotatedHeight});return e.rotated&&t.rotate(270),t.toFile(e._libraryPath).catch(t=>{console.error(`trimImages(${e.originalPath}) failed!`),console.warn(t)})})).catch(t=>{console.error(t),console.error("packer: trimImages failed!")})}exports.packer=packer;