"use strict";const ipacker=require("max-rects-packing"),MaxRectsBinPack=require("./maxrects");function getRectsFromInputs(e){return e.map(e=>({width:e.width,height:e.height,origin:e}))}function getInputsFromRects(e){return e.map(e=>{var t=e.origin;for(const r in e)"origin"!==r&&(t[r]=e[r]);return t})}function scoreMaxRects(e,t,r,c,i,s){var a=new MaxRectsBinPack(t,r,i).insertRects(e,c);let o=0;let n=0,h=0;for(let e=0;e<a.length;e++){var l=a[e],u=(o+=l.width*l.height,l.x+(l.rotated?l.height:l.width)),l=l.y+(l.rotated?l.width:l.height);u>n&&(n=u),l>h&&(h=l)}i=n*h,i=o/i;(o>s.packedArea||i>s.score&&o>=s.packedArea)&&(s.packedRects=a,s.unpackedRects=e,s.score=i,s.packedArea=o,s.binWidth=t,s.binHeight=r,s.heuristice=c)}function scoreMaxRectsForAllHeuristics(t,r,c,i,s){for(let e=0;e<=5;e++)4!==e&&scoreMaxRects(getRectsFromInputs(t),r,c,e,i,s)}module.exports={ipacker(e,t,r,c){t=new ipacker.Packer(t,r,{allowRotate:c}),r=getRectsFromInputs(e);return t.fit(r).rects.map(e=>Object.assign(e.origin,e.fitInfo))},MaxRects(c,e,i,s){let a=0;for(let e=0;e<c.length;e++)a+=c[e].width*c[e].height;var o={packedRects:[],unpackedRects:[],score:-1/0,packedArea:-1/0};if(a<e*i)for(let r=4;r<=e;r=Math.min(2*r,e)){for(let t=4;t<=i;t=Math.min(2*t,i)){var n=r*t;if(n>=a){let e=a;for(;;){var h=Math.pow(e,.5),l=(h<=r&&h<=t&&scoreMaxRectsForAllHeuristics(c,h,h,s,o),scoreMaxRectsForAllHeuristics(c,e/t,t,s,o),scoreMaxRectsForAllHeuristics(c,r,e/r,s,o),o.unpackedRects);if(0<l.length){let t=0;for(let e=0;e<l.length;e++)t+=l[e].width*l[e].height;e+=t/2}if(e>=n||0===l.length)break}}if(t>=i)break}if(r>=e)break}else scoreMaxRectsForAllHeuristics(c,e,i,s,o);return getInputsFromRects(o.packedRects)}};