/**
 * 接收一个数据队列和一个 generate 函数, 通过将数据传递给 generate 拿到一个 promise 对象
 * 根据 num 传入的并行个数进行适当任务的并发
 *
 * @param tasks[any[]]
 * @param generate[Function]
 * @param num[Number]
 */
export declare function parallel(tasks: any[], generate: Function, num?: number): Promise<any[]>;
/**
 * 瀑布流任务队列
 */
export declare class ParallelQueue<TaskObject, ReturnValue> {
    private _thread;
    private _waitQueue;
    private _execQueue;
    private _incrementalID;
    private _generate;
    private _staging;
    private _execID;
    private _execThread;
    _waitPromise?: Promise<any>;
    _waitResolve?: Function;
    constructor(generate: (param: TaskObject) => Promise<ReturnValue>, thread: number);
    private _startLock;
    private _stopFlag;
    start(): void;
    stop(): void;
    private _step;
    /**
     * 添加一个任务数据
     * @param taskObj
     */
    addTask(taskObj: TaskObject): number;
    /**
     * 删除一个任务数据
     * @param id
     */
    removeTask(id: number): boolean;
    /**
     * 等待执行完毕
     */
    waitQueue(): Promise<any>;
    /**
     * 当前队列的导入资源总数
     */
    total(): number;
    size(): number;
    /**
     * 是否正在导入
     */
    busy(): boolean;
    /**
     * 清空队列，还原为初始状态
     */
    clear(): boolean;
    /**
     * 暂停一个导入任务，释放 thread，直接开始其他导入任务
     * @param id
     */
    pause(id: number): void;
    /**
     * 恢复一个导入任务，会重新占用一个 thread
     * @param id
     */
    resume(id: number): void;
}
