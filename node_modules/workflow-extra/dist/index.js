'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParallelQueue = exports.parallel = void 0;
/**
 * 接收一个数据队列和一个 generate 函数, 通过将数据传递给 generate 拿到一个 promise 对象
 * 根据 num 传入的并行个数进行适当任务的并发
 *
 * @param tasks[any[]]
 * @param generate[Function]
 * @param num[Number]
 */
function parallel(tasks, generate, num = 1) {
    return new Promise((resolve) => {
        const results = [];
        let i = 0;
        let j = 0;
        async function step() {
            const task = tasks[i];
            if (task) {
                j++;
                const t = i;
                try {
                    const result = await generate(task);
                    results[t] = result;
                }
                catch (error) {
                    if (error instanceof Error) {
                        results[t] = error;
                    }
                    else {
                        results[t] = new Error(error + '');
                    }
                }
                j--;
                i++;
                step();
            }
            else if (j === 0) {
                resolve(results);
            }
        }
        for (; i < num && i < tasks.length; i++) {
            step();
        }
        i--;
    });
}
exports.parallel = parallel;
/**
 * 瀑布流任务队列
 */
class ParallelQueue {
    // 并行的任务线
    _thread;
    // 等待队列
    _waitQueue = new Map;
    // 执行队列
    _execQueue = new Map;
    // 递增 id，是最后一个插入的任务 id
    _incrementalID = 0;
    // 将 taskObject 转成 task 的函数
    _generate;
    // 暂存队列
    _staging = new Map;
    // 最后被执行的任务 id
    _execID = 1;
    // 同时在执行的任务线
    _execThread = 0;
    _waitPromise = undefined;
    _waitResolve = undefined;
    constructor(generate, thread) {
        this._generate = generate;
        this._thread = thread;
    }
    _startLock = false;
    _stopFlag = false;
    start() {
        this._stopFlag = false;
        let num = 0;
        while (this._execThread < this._thread && num < this._thread) {
            num++;
            this._step();
        }
        this._step();
    }
    stop() {
        this._stopFlag = true;
    }
    _step() {
        if (this._execThread >= this._thread) {
            return;
        }
        if (this._execID > this._incrementalID && this._execThread === 0 && this._staging.size === 0) {
            this._waitResolve && this._waitResolve();
            this._waitPromise = undefined;
            this._waitResolve = undefined;
            return;
        }
        let taskObject;
        let id;
        while (this._execID <= this._incrementalID) {
            id = this._execID++;
            taskObject = this._waitQueue.get(id);
            if (!taskObject) {
                continue;
            }
            this._execQueue.set(id, taskObject);
            this._waitQueue.delete(id);
            break;
        }
        if (taskObject) {
            this._execThread++;
            this._generate(taskObject).then(() => {
                this._execThread--;
                this._execQueue.delete(id);
                setImmediate(() => {
                    this._step();
                });
            }).catch((error) => {
                console.error(error);
                this._execThread--;
                this._execQueue.delete(id);
                setImmediate(() => {
                    this._step();
                });
            });
        }
    }
    /**
     * 添加一个任务数据
     * @param taskObj
     */
    addTask(taskObj) {
        this._waitQueue.set(++this._incrementalID, taskObj);
        if (!this._startLock && !this._stopFlag) {
            this._startLock = true;
            setImmediate(() => {
                this.start();
                this._startLock = false;
            });
        }
        return this._incrementalID;
    }
    /**
     * 删除一个任务数据
     * @param id
     */
    removeTask(id) {
        return this._waitQueue.delete(id);
    }
    /**
     * 等待执行完毕
     */
    waitQueue() {
        if (this._incrementalID === 0 ||
            (this._execID > this._incrementalID &&
                this._execThread === 0)) {
            return Promise.resolve();
        }
        if (this._waitPromise) {
            return this._waitPromise;
        }
        this._waitPromise = new Promise((resolve) => {
            this._waitResolve = resolve;
        });
        return this._waitPromise;
    }
    /**
     * 当前队列的导入资源总数
     */
    total() {
        return this._incrementalID;
    }
    size() {
        return this._incrementalID;
    }
    /**
     * 是否正在导入
     */
    busy() {
        return !(this._incrementalID === 0 ||
            (this._execID > this._incrementalID &&
                this._execThread === 0));
    }
    /**
     * 清空队列，还原为初始状态
     */
    clear() {
        if (this._incrementalID === 0 ||
            (this._execID > this._incrementalID &&
                this._execThread === 0)) {
            this._incrementalID = 0;
            this._execID = 1;
            this._execThread = 0;
            return true;
        }
        return false;
    }
    /**
     * 暂停一个导入任务，释放 thread，直接开始其他导入任务
     * @param id
     */
    pause(id) {
        const taskObject = this._execQueue.get(id);
        if (taskObject) {
            this._staging.set(id, taskObject);
            this._execQueue.delete(id);
            this._execThread--;
            this._step();
        }
    }
    /**
     * 恢复一个导入任务，会重新占用一个 thread
     * @param id
     */
    resume(id) {
        const taskObject = this._staging.get(id);
        if (taskObject) {
            this._execQueue.set(id, taskObject);
            this._staging.delete(id);
            this._execThread++;
            this._step();
        }
    }
}
exports.ParallelQueue = ParallelQueue;
