'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskManager = exports.Task = void 0;
const event_1 = require("./event");
var TaskManagerState;
(function (TaskManagerState) {
    // 未启动
    TaskManagerState[TaskManagerState["idle"] = 0] = "idle";
    // 正常启动状态
    TaskManagerState[TaskManagerState["normal"] = 1] = "normal";
    // 暂停状态
    TaskManagerState[TaskManagerState["pause"] = 2] = "pause";
})(TaskManagerState || (TaskManagerState = {}));
class Task {
    // 每个任务的处理函数
    handle() { }
}
exports.Task = Task;
class TaskManager extends event_1.EventEmitter {
    get name() {
        return this.options.name;
    }
    get progress() {
        const length = this.length;
        if (length === 0) {
            return length;
        }
        return this.completedQueue.length / length;
    }
    get length() {
        return this.pendingQueue.length + this.executingQueue.size + this.completedQueue.length;
    }
    constructor(options) {
        super();
        this.pendingQueue = new Array;
        this.executingQueue = new Set;
        this.completedQueue = new Array;
        this.state = TaskManagerState.idle;
        this.options = {
            name: '',
            maxConcurrent: 1,
        };
        this.options = options || {};
    }
    step() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state !== TaskManagerState.normal) {
                return;
            }
            if (this.executingQueue.size >= this.options.maxConcurrent) {
                return;
            }
            const task = this.pendingQueue.shift();
            if (!task) {
                if (this.executingQueue.size === 0) {
                    this.emit('finish');
                }
                return;
            }
            this.executingQueue.add(task);
            try {
                yield task.handle();
            }
            catch (error) {
                this.emit('error', error);
            }
            this.executingQueue.delete(task);
            this.completedQueue.push(task);
            if (this.executingQueue.size < this.options.maxConcurrent) {
                this.step();
            }
        });
    }
    /**
     * 开始执行任务队列
     */
    start() {
        if (this.state === TaskManagerState.normal) {
            return;
        }
        this.emit('start');
        this.state = TaskManagerState.normal;
        for (let i = 0; i < this.options.maxConcurrent; i++) {
            this.step();
        }
    }
    /**
     * 暂停后续任务
     */
    pause() {
        if (this.state === TaskManagerState.pause) {
            return;
        }
        this.emit('pause');
        this.state = TaskManagerState.pause;
    }
    /**
     * 重新开始暂停的队列
     */
    resume() {
        if (this.state !== TaskManagerState.pause) {
            return;
        }
        this.emit('resume');
        this.state = TaskManagerState.normal;
        for (let i = 0; i < this.options.maxConcurrent; i++) {
            this.step();
        }
    }
    /**
     * 插入子任务
     * @param task
     */
    push(task) {
        this.pendingQueue.push(task);
        this.step();
    }
    /**
     * 插入队列头部
     * @param task
     */
    unshift(task) {
        this.pendingQueue.unshift(task);
        this.step();
    }
    /**
     * 移除自任务
     * @param task
     */
    remove(task) {
        const index = this.pendingQueue.indexOf(task);
        if (index !== -1) {
            this.pendingQueue.splice(index, 1);
        }
    }
    /**
     * 循环等待队列
     * @param handle
     */
    forEachPendingQueue(handle) {
        this.pendingQueue.forEach(handle);
    }
}
exports.TaskManager = TaskManager;
