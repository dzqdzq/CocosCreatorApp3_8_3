'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("assert");
const task_queue_1 = require("../lib/task-queue");
describe(`TaskManager`, function () {
    describe('base', () => {
        it('properties', function () {
            const manager = new task_queue_1.TaskManager({
                name: 'test',
                maxConcurrent: 1,
            });
            (0, assert_1.equal)(manager.name, 'test');
            (0, assert_1.equal)(manager.length, 0);
            (0, assert_1.equal)(manager.progress, 0);
        });
        it('准备任务队列', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const manager = new task_queue_1.TaskManager({
                    name: 'test',
                    maxConcurrent: 1,
                });
                let execTask = 0;
                let finishTask = 0;
                class TimeTask extends task_queue_1.Task {
                    constructor(t) {
                        super();
                        this.t = t;
                    }
                    handle() {
                        execTask++;
                        return new Promise((resolve) => {
                            setTimeout(() => {
                                finishTask++;
                                resolve(void 0);
                            }, this.t);
                        });
                    }
                }
                const tTaskA = new TimeTask(200);
                const tTaskB = new TimeTask(100);
                manager.push(tTaskA);
                (0, assert_1.equal)(manager.progress, 0);
                (0, assert_1.equal)(manager.length, 1);
                manager.push(tTaskB);
                (0, assert_1.equal)(manager.progress, 0);
                (0, assert_1.equal)(manager.length, 2);
                yield new Promise((resolve) => {
                    setTimeout(resolve, 200);
                });
                // 没有开始的情况下不会执行代码
                (0, assert_1.equal)(manager.progress, 0);
                (0, assert_1.equal)(manager.length, 2);
                (0, assert_1.equal)(execTask, 0);
                (0, assert_1.equal)(finishTask, 0);
            });
        });
        it('执行任务', () => __awaiter(this, void 0, void 0, function* () {
            const manager = new task_queue_1.TaskManager({
                name: 'test',
                maxConcurrent: 1,
            });
            let execTask = 0;
            let finishTask = 0;
            class TimeTask extends task_queue_1.Task {
                constructor(t) {
                    super();
                    this.t = t;
                }
                handle() {
                    execTask++;
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            finishTask++;
                            resolve(void 0);
                        }, this.t);
                    });
                }
            }
            const tTaskA = new TimeTask(100);
            const tTaskB = new TimeTask(200);
            manager.push(tTaskA);
            manager.push(tTaskB);
            manager.start();
            (0, assert_1.equal)(manager.progress, 0);
            (0, assert_1.equal)(manager.length, 2);
            (0, assert_1.equal)(execTask, 1);
            (0, assert_1.equal)(finishTask, 0);
            yield new Promise((resolve) => {
                setTimeout(resolve, 100);
            });
            (0, assert_1.equal)(manager.length, 2);
            (0, assert_1.equal)(execTask, 2);
            (0, assert_1.equal)(finishTask, 1);
            (0, assert_1.equal)(manager.progress, 0.5);
        }));
        it('暂停 / 恢复任务', () => __awaiter(this, void 0, void 0, function* () {
            const manager = new task_queue_1.TaskManager({
                name: 'test',
                maxConcurrent: 1,
            });
            let execTask = 0;
            let finishTask = 0;
            class TimeTask extends task_queue_1.Task {
                constructor(t) {
                    super();
                    this.t = t;
                }
                handle() {
                    execTask++;
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            finishTask++;
                            resolve(void 0);
                        }, this.t);
                    });
                }
            }
            const tTaskA = new TimeTask(100);
            const tTaskB = new TimeTask(100);
            manager.push(tTaskA);
            manager.push(tTaskB);
            manager.start();
            manager.pause();
            (0, assert_1.equal)(manager.progress, 0);
            (0, assert_1.equal)(manager.length, 2);
            (0, assert_1.equal)(execTask, 1);
            (0, assert_1.equal)(finishTask, 0);
            yield new Promise((resolve) => {
                setTimeout(resolve, 100);
            });
            (0, assert_1.equal)(manager.progress, 0.5);
            (0, assert_1.equal)(manager.length, 2);
            (0, assert_1.equal)(execTask, 1);
            (0, assert_1.equal)(finishTask, 1);
            manager.resume();
            (0, assert_1.equal)(manager.progress, 0.5);
            (0, assert_1.equal)(manager.length, 2);
            (0, assert_1.equal)(execTask, 2);
            (0, assert_1.equal)(finishTask, 1);
            yield new Promise((resolve) => {
                setTimeout(resolve, 100);
            });
            (0, assert_1.equal)(manager.progress, 1);
            (0, assert_1.equal)(manager.length, 2);
            (0, assert_1.equal)(execTask, 2);
            (0, assert_1.equal)(finishTask, 2);
        }));
        it('并行任务', () => __awaiter(this, void 0, void 0, function* () {
            const manager = new task_queue_1.TaskManager({
                name: 'test',
                maxConcurrent: 2,
            });
            let execTask = 0;
            let finishTask = 0;
            class TimeTask extends task_queue_1.Task {
                constructor(t) {
                    super();
                    this.t = t;
                }
                handle() {
                    execTask++;
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            finishTask++;
                            resolve(void 0);
                        }, this.t);
                    });
                }
            }
            const tTaskA = new TimeTask(100);
            const tTaskB = new TimeTask(100);
            const tTaskC = new TimeTask(100);
            manager.push(tTaskA);
            manager.push(tTaskB);
            manager.push(tTaskC);
            manager.start();
            (0, assert_1.equal)(manager.progress, 0);
            (0, assert_1.equal)(manager.length, 3);
            (0, assert_1.equal)(execTask, 2);
            (0, assert_1.equal)(finishTask, 0);
            yield new Promise((resolve) => {
                setTimeout(resolve, 100);
            });
            (0, assert_1.equal)(manager.progress, 2 / 3);
            (0, assert_1.equal)(manager.length, 3);
            (0, assert_1.equal)(execTask, 3);
            (0, assert_1.equal)(finishTask, 2);
            yield new Promise((resolve) => {
                setTimeout(resolve, 100);
            });
            (0, assert_1.equal)(manager.progress, 1);
            (0, assert_1.equal)(manager.length, 3);
            (0, assert_1.equal)(execTask, 3);
            (0, assert_1.equal)(finishTask, 3);
        }));
    });
});
