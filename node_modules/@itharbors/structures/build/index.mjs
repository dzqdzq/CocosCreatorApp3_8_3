var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// source/lib/queue.ts
var ObjectQueue = class {
  constructor() {
    this.head = 0;
    this.tail = 0;
    this.items = {};
  }
  enqueue(item) {
    this.items[this.tail] = item;
    this.tail += 1;
  }
  dequeue() {
    if (this.isEmpty()) {
      return void 0;
    }
    const item = this.items[this.head];
    delete this.items[this.head];
    this.head += 1;
    return item;
  }
  peek() {
    if (this.isEmpty()) {
      return void 0;
    }
    return this.items[this.head];
  }
  isEmpty() {
    return this.tail - this.head <= 0;
  }
  size() {
    return this.tail - this.head;
  }
  clear() {
    while (this.head < this.tail) {
      delete this.items[this.head];
      this.head += 1;
    }
  }
};
var ArrayQueue = class {
  constructor() {
    this.items = [];
  }
  enqueue(item) {
    this.items.push(item);
  }
  dequeue() {
    if (this.isEmpty()) {
      return void 0;
    }
    return this.items.shift();
  }
  peek() {
    if (this.isEmpty()) {
      return void 0;
    }
    return this.items[0];
  }
  isEmpty() {
    return this.items.length === 0;
  }
  size() {
    return this.items.length;
  }
  clear() {
    this.items.length = 0;
  }
};

// source/lib/event.ts
var EventEmitter = class {
  constructor() {
    this._events = {};
  }
  addListener(action, handle) {
    const HandleArray = this._events[action] = this._events[action] || [];
    if (HandleArray.find((item) => item.handle === handle)) {
      return console.error(`Please do not listen to the same function repeatedly.`);
    }
    HandleArray.push({
      handle,
      once: false
    });
  }
  addOnceListener(action, handle) {
    const HandleArray = this._events[action] = this._events[action] || [];
    if (HandleArray.find((item) => item.handle === handle)) {
      return console.error(`Please do not listen to the same function repeatedly.`);
    }
    HandleArray.push({
      handle,
      once: true
    });
  }
  removeListener(action, handle) {
    if (!handle) {
      if (this._events[action]) {
        this._events[action].length === 0;
        delete this._events[action];
      }
      return;
    }
    const HandleArray = this._events[action] = this._events[action] || [];
    for (let i = 0; i < HandleArray.length; i++) {
      const Item = HandleArray[i];
      if (Item.handle === handle) {
        HandleArray.splice(i, 1);
        break;
      }
    }
  }
  clear(action) {
    if (action) {
      if (this._events[action]) {
        this._events[action].length === 0;
        delete this._events[action];
      }
      return;
    }
    Object.keys(this._events).forEach((name) => {
      this._events[name].length === 0;
      delete this._events[name];
    });
  }
  emit(action, ...args) {
    return __async(this, null, function* () {
      if (!this._events[action]) {
        return;
      }
      const HandleArray = this._events[action];
      for (let i = 0; i < HandleArray.length; i++) {
        const HandleItem = HandleArray[i];
        if (HandleItem.once) {
          HandleArray.splice(i, 1);
          i--;
        }
        try {
          yield HandleItem.handle.call(this, ...args);
        } catch (error) {
          console.error(error);
        }
      }
    });
  }
};

// source/lib/task-queue.ts
var Task = class {
  handle() {
  }
};
var TaskManager = class extends EventEmitter {
  constructor(options) {
    super();
    this.pendingQueue = new Array();
    this.executingQueue = /* @__PURE__ */ new Set();
    this.completedQueue = new Array();
    this.state = 0 /* idle */;
    this.options = {
      name: "",
      maxConcurrent: 1
    };
    this.options = options || {};
  }
  get name() {
    return this.options.name;
  }
  get progress() {
    const length = this.length;
    if (length === 0) {
      return length;
    }
    return this.completedQueue.length / length;
  }
  get length() {
    return this.pendingQueue.length + this.executingQueue.size + this.completedQueue.length;
  }
  step() {
    return __async(this, null, function* () {
      if (this.state !== 1 /* normal */) {
        return;
      }
      if (this.executingQueue.size >= this.options.maxConcurrent) {
        return;
      }
      const task = this.pendingQueue.shift();
      if (!task) {
        if (this.executingQueue.size === 0) {
          this.emit("finish");
        }
        return;
      }
      this.executingQueue.add(task);
      try {
        yield task.handle();
      } catch (error) {
        this.emit("error", error);
      }
      this.executingQueue.delete(task);
      this.completedQueue.push(task);
      if (this.executingQueue.size < this.options.maxConcurrent) {
        this.step();
      }
    });
  }
  start() {
    if (this.state === 1 /* normal */) {
      return;
    }
    this.emit("start");
    this.state = 1 /* normal */;
    for (let i = 0; i < this.options.maxConcurrent; i++) {
      this.step();
    }
  }
  pause() {
    if (this.state === 2 /* pause */) {
      return;
    }
    this.emit("pause");
    this.state = 2 /* pause */;
  }
  resume() {
    if (this.state !== 2 /* pause */) {
      return;
    }
    this.emit("resume");
    this.state = 1 /* normal */;
    for (let i = 0; i < this.options.maxConcurrent; i++) {
      this.step();
    }
  }
  push(task) {
    this.pendingQueue.push(task);
    this.step();
  }
  unshift(task) {
    this.pendingQueue.unshift(task);
    this.step();
  }
  remove(task) {
    const index = this.pendingQueue.indexOf(task);
    if (index !== -1) {
      this.pendingQueue.splice(index, 1);
    }
  }
  forEachPendingQueue(handle) {
    this.pendingQueue.forEach(handle);
  }
};

// source/lib/object-recycler.ts
var ObjectRecycler = class {
  constructor(option) {
    this.objectPool = [];
    this.option = option;
  }
  acquireObject() {
    if (this.objectPool.length > 0) {
      const object = this.objectPool.pop();
      object.initialize();
      return object;
    } else {
      const obj = this.option.generate();
      obj.initialize();
      return obj;
    }
  }
  recycleObject(object) {
    if (object.destroy) {
      object.destroy();
    }
    const index = this.objectPool.indexOf(object);
    if (index === -1) {
      this.objectPool.push(object);
    }
  }
};

// source/lib/task-scheduler.ts
var Task2 = class {
  constructor(name, option) {
    this.executed = false;
    this.running = false;
    this.option = option || {};
    this.name = name;
  }
};
var TaskScheduler = class {
  constructor() {
    this.name2item = {};
    this.depend2item = {};
  }
  get size() {
    return Object.keys(this.name2item).length;
  }
  add(name, option) {
    const item = this.name2item[name] = new Task2(name, option);
    if (item.option.depends) {
      item.option.depends.forEach((name2) => {
        const array = this.depend2item[name2] = this.depend2item[name2] || [];
        array.push(item);
      });
    }
  }
  remove(name) {
    const item = this.name2item[name];
    if (!item) {
      return;
    }
    delete this.name2item[name];
    if (item.option.depends) {
      item.option.depends.forEach((name2) => {
        const array = this.depend2item[name2];
        const index = array.indexOf(item);
        array.splice(index, 1);
        if (!array.length) {
          delete this.depend2item[name2];
        }
      });
    }
  }
  execute(name) {
    return __async(this, null, function* () {
      const item = this.name2item[name];
      if (!item) {
        console.warn(`Task execution failed: '${name}' does not exist.`);
        return null;
      }
      const refused = item.option.depends.some((name2) => {
        const depend = this.name2item[name2];
        return !depend.executed;
      });
      if (refused) {
        console.warn(`Task execution failed: '${name}' dependencies are not completed.`);
        return null;
      }
      if (!item.executed && !item.running) {
        item.running = true;
        const result = yield item.option.execute();
        item.running = false;
        item.executed = true;
        const depends = this.depend2item[name] || [];
        for (let i = 0; i < depends.length; i++) {
          const child = depends[i];
          const allow = !child.option.depends.some((name2) => {
            return !this.name2item[name2] || !this.name2item[name2].executed;
          });
          if (allow) {
            this.execute(child.name);
          }
        }
        return result;
      }
      return null;
    });
  }
  revert(name) {
    return __async(this, null, function* () {
      const item = this.name2item[name];
      if (!item) {
        return;
      }
      yield item.option.revert();
      item.executed = false;
      item.running = false;
      const depends = this.depend2item[name] || [];
      for (let i = 0; i < depends.length; i++) {
        const child = depends[i];
        this.revert(child.name);
      }
    });
  }
};

// source/lib/action-queue.ts
var Action = class {
  constructor(detail, action) {
    this.detail = detail;
    this.target = action;
  }
};
var ActionList = class extends Action {
  exec(params) {
    return __async(this, null, function* () {
      for (let action of this.detail.queue) {
        yield action.exec(params);
      }
    });
  }
  revertAction() {
    const queue = [];
    for (let i = this.detail.queue.length - 1; i >= 0; i--) {
      const action = this.detail.queue[i];
      queue.push(action.revertAction());
    }
    return new ActionList({
      queue
    }, this);
  }
};
var ActionQueue = class {
  constructor(params) {
    this._redoOffset = 0;
    this._queue = [];
    this._state = 0 /* normal */;
    this._recordActionList = [];
    this._params = params;
  }
  get queue() {
    return this._queue;
  }
  get length() {
    return this._queue.length;
  }
  startRecording() {
    if (this._state === 1 /* record */) {
      this.stopRecording();
    }
    this._state = 1 /* record */;
  }
  stopRecording() {
    if (this._recordActionList.length > 0) {
      this._queue.push(new ActionList({
        queue: this._recordActionList
      }));
      this._recordActionList = [];
    }
    this._state = 0 /* normal */;
  }
  exec(action) {
    return __async(this, null, function* () {
      if (this._state === 1 /* record */) {
        this._recordActionList.push(action);
      } else {
        this._queue.push(action);
      }
      this._redoOffset = 0;
      yield action.exec(this._params);
    });
  }
  undo() {
    return __async(this, null, function* () {
      if (this._state === 1 /* record */) {
        this.stopRecording();
      }
      const setter = /* @__PURE__ */ new Set();
      let undoAction;
      for (let i = this._queue.length - 1; i >= 0; i--) {
        const action = this._queue[i];
        if (action.target) {
          setter.add(action.target);
        } else if (!setter.has(action)) {
          undoAction = action;
          break;
        }
      }
      if (undoAction) {
        let redoAction = undoAction.target;
        if (!redoAction) {
          redoAction = undoAction.revertAction();
          redoAction.target = undoAction;
        }
        this._queue.push(redoAction);
        redoAction.exec(this._params);
      }
      this._redoOffset = 0;
    });
  }
  redo() {
    return __async(this, null, function* () {
      if (this._state === 1 /* record */) {
        this.stopRecording();
      }
      const action = this._queue[this._queue.length - 1 - this._redoOffset];
      if (action && action.target) {
        let execAction = action.target;
        if (!execAction) {
          execAction = action.revertAction();
          execAction.target = action;
        }
        this._queue.push(execAction);
        execAction.exec(this._params);
        this._redoOffset += 2;
      }
    });
  }
};
export {
  Action,
  ActionList,
  ActionQueue,
  ArrayQueue,
  EventEmitter,
  ObjectQueue,
  ObjectRecycler,
  Task,
  TaskManager,
  TaskScheduler
};
