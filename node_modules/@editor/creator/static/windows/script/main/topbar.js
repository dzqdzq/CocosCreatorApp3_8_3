'use strict';

const Vue = require('vue/dist/vue');
const ipc = require('@base/electron-base-ipc');

Vue.config.productionTip = false;
Vue.config.devtools = false;

const { join } = require('path');

let vm;
exports.init = function () {
    vm = new Vue({
        el: document.getElementById('toolbar'),

        data: {
            platform: process.platform,
            MAIN_WINDOW_ORIGIN_HEADER: {
                ALL: true,
                CENTER: true,
                RIGHT: true,
            },
            left: [],
            middle: [],
            right: [],
            barStyle: '',
            leftStyle: '',
            maxiIcon: 'maxi',
        },

        methods: {
            minimize() {
                ipc.send('editor-lib-windows:minimize');
            },
            maximize() {
                ipc.send('editor-lib-windows:maximize');
            },
            close() {
                ipc.send('editor-lib-windows:close');
            },

            attach(data) {
                if (!data.enable || !data.info.contributions || !data.info.contributions.toolbar) {
                    return;
                }

                let toolbars = data.info.contributions.toolbar;
                if (toolbars.left) {
                    const exists = this.left.some((item) => {
                        return item.name === data.info.name;
                    });
                    !exists && this.left.push({
                        name: data.info.name,
                        path: join(data.path, toolbars.left),
                        priority: toolbars.leftPriority || 0,
                    });
                    this.left.sort((a, b) => {
                        return a.priority - b.priority;
                    });
                }
                if (toolbars.middle) {
                    const exists = this.middle.some((item) => {
                        return item.name === data.info.name;
                    });
                    !exists && this.middle.push({
                        name: data.info.name,
                        path: join(data.path, toolbars.middle),
                        priority: toolbars.middlePriority || 0,
                    });
                    this.middle.sort((a, b) => {
                        return a.priority - b.priority;
                    });
                }
                if (toolbars.right) {
                    const exists = this.right.some((item) => {
                        return item.name === data.info.name;
                    });
                    !exists && this.right.push({
                        name: data.info.name,
                        path: join(data.path, toolbars.right),
                        priority: toolbars.rightPriority || 0,
                    });
                    this.right.sort((a, b) => {
                        return a.priority - b.priority;
                    });
                }
            },

            detach(data) {
                if (!data.info.contributions || !data.info.contributions.toolbar) {
                    return;
                }

                let toolbars = data.info.contributions.toolbar;
                if (toolbars.left) {
                    this.left.some((item, index) => {
                        if (item.name === data.info.name) {
                            Editor.Module.removeCache(item.path);
                            this.left.splice(index, 1);
                            return true;
                        }
                    });
                }
                if (toolbars.middle) {
                    this.middle.some((item, index) => {
                        if (item.name === data.info.name) {
                            Editor.Module.removeCache(item.path);
                            this.middle.splice(index, 1);
                            return true;
                        }
                    });
                }
                if (toolbars.right) {
                    this.right.some((item, index) => {
                        if (item.name === data.info.name) {
                            Editor.Module.removeCache(item.path);
                            this.right.splice(index, 1);
                            return true;
                        }
                    });
                }
            },

            getMaxiIcon() {
                const bool = ipc.sendSync('editor-lib-windows:isMaximized');
                return this.maxiIcon =  bool ? 'un-maxi' : 'maxi';
            }
        },

        mounted() {
            this.getMaxiIcon();
            window.addEventListener('resize', () => {
                this.getMaxiIcon();
            });
        },
    });

}

exports.attach = function (pkg) {
    try {
        vm.attach(pkg);
    } catch (error) {
        console.error(error);
    }
}

exports.detach = function (pkg) {
    try {
        vm.detach(pkg);
    } catch (error) {
        console.error(error);
    }
}

exports.showCustomHeader = function (src) {
    document.querySelector('#custom-toolbar').removeAttribute('hidden');
    document.querySelector('#custom-toolbar ui-panel').setAttribute('src', src);
}

exports.changeOriginHeader = function (config) {
    for (const key in config) {
        vm.$set(vm.MAIN_WINDOW_ORIGIN_HEADER, key, config[key]);
    }
}
