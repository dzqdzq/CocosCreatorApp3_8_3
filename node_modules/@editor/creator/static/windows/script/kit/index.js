'use strict';

const ipc = require('@base/electron-base-ipc');
const wins = require('@base/electron-windows');

const ipcRenderer = require('electron').ipcRenderer;

window.__MAIN__ = false;

// 首先初始化任务管理器
// require('../../../../task');

// 初始化插件注册到每个窗口的代码
require('../public/windows');

require('../public/polyfill');

Editor.Task.sync();

const panelMap = {};

const current = {
    elem: null,
    listeners: [],
    kitID: -1,
    webContentID: -1,
};

function register(name) {
    if (!panelMap[name]) {
        const panel = panelMap[name] = document.createElement('panel-frame');
        panel.style = `display: none; position: absolute; z-indx: 1; top: 0; left: 0; width: 100%; height: 100%;`;
        return new Promise((resolve) => {
            const ready = function() {
                resolve();
                panel.removeEventListener('panel-ready', ready);
            }
            panel.addEventListener('panel-ready', ready);
            panel.setAttribute('name', name);
            document.body.appendChild(panel);
        });
    }
}

function unregister(name) {
    if (!panelMap[name]) {
        return;
    }
    const $panel = panelMap[name];
    delete panelMap[name];
    $panel.parentNode.removeChild($panel);
}

function eventEmit(event) {
    // current.kitID
    // current.webContentID
    ipcRenderer.sendTo(current.webContentID, 'editor-lib-panel:kit-panel-emit', current.kitID, event.type, event.detail);
}

async function open(name, options/* Editor.Panel.KitOpenOption */) {
    if (!panelMap[name]) {
        await register(name);
    }
    if (current.elem && current.elem.name) {
        close(current.elem.name);
    }

    const panel = panelMap[name];

    panel.style.display = 'block';
    current.elem = panel;
    current.listeners = options.listeners;
    current.kitID = options.kitID;
    current.webContentID = options.webContentID;

    options.listeners && options.listeners.forEach((name) => {
        panel.shadowRoot.addEventListener(name, eventEmit);
    });

    requestAnimationFrame(() => {
        const methods = panel.panel.methods;
        if (methods && methods['reset']) {
            methods['reset'].call(panel, ...options.params);
        }
    });
}

function close(name) {
    const panel = panelMap[name];
    if (!panel || current.elem !== panel) {
        return;
    }

    current.listeners && current.listeners.forEach((name) => {
        panel.shadowRoot.removeEventListener(name, eventEmit);
    });

    panel.style.display = 'none';
    current.elem = null;
    current.listeners = [];
    current.kitID = -1;
    current.webContentID = -1;
}

ipc.on('editor-lib-panel:register-kit-panel', (event, name) => {
    register(name);
});

ipc.on('editor-lib-panel:unregister-kit-panel', (event, name) => {
    unregister(name);
});

ipc.on('editor-lib-panel:open-kit-panel', (event, name, options/* Editor.Panel.KitOpenOption */) => {
    open(name, options)
});

ipc.on('editor-lib-panel:hide-kit-panel', (event, name) => {
    if (!current.elem) {
        return;
    }
    const currentElem = current.elem;
    name = name || currentElem.name;
    close(name);
    const methods = currentElem.panel.methods;
    if (methods && methods['clear']) {
        methods['clear'].call(currentElem.panel);
    }
});
