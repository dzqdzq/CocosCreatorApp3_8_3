"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const resolve_1 = __importDefault(require("resolve"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const babel = __importStar(require("@babel/core"));
// @ts-ignore
const preset_env_1 = __importDefault(require("@babel/preset-env"));
// @ts-ignore
const babel_plugin_transform_commonjs_1 = __importDefault(require("babel-plugin-transform-commonjs"));
const module_interop_1 = require("./module-interop");
const path_url_interop_1 = require("./path-url-interop");
const babel_plugin_kill_amd_1 = __importDefault(require("./babel-plugin-kill-amd"));
const VERSION = '1.0.1';
var ModuleResolveResultKind;
(function (ModuleResolveResultKind) {
    ModuleResolveResultKind[ModuleResolveResultKind["resolved"] = 0] = "resolved";
    ModuleResolveResultKind[ModuleResolveResultKind["nodeJsCore"] = 1] = "nodeJsCore";
    ModuleResolveResultKind[ModuleResolveResultKind["unresolved"] = 2] = "unresolved";
    ModuleResolveResultKind[ModuleResolveResultKind["browserFieldEmpty"] = 3] = "browserFieldEmpty";
})(ModuleResolveResultKind || (ModuleResolveResultKind = {}));
class Bringer {
    constructor(options) {
        var _a;
        this._projectDir = options.project;
        this._outDir = options.outDir;
        this._incrementalFile = options.incrementalFile;
        this._externalModulePlaceHolder = options.excludedModulePlaceholder || Bringer.defaultExternalModulePlaceHolder;
        this._rootCache = (_a = (this._incrementalFile ? readCache(this._incrementalFile) : null), (_a !== null && _a !== void 0 ? _a : {
            version: VERSION,
            modules: {},
            packages: {},
        }));
    }
    build(modules, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            options = options || {};
            const { importMapFile } = options;
            const buildResult = {
                resolved: new Array(modules.length).fill(null),
            };
            buildResult.nodeJsCoreModules = {};
            buildResult.unresolved = [];
            const addNodeJsCoreModuleReference = (resolved, requested, file) => {
                if (!buildResult.nodeJsCoreModules) {
                    buildResult.nodeJsCoreModules = {};
                }
                if (!(resolved in buildResult.nodeJsCoreModules)) {
                    buildResult.nodeJsCoreModules[resolved] = [];
                }
                buildResult.nodeJsCoreModules[resolved].push({
                    requested,
                    file,
                });
            };
            const topLevelModuleMetas = new Array(modules.length).fill(null);
            for (let iModule = 0; iModule < modules.length; ++iModule) {
                const moduleId = modules[iModule];
                const resolveResult = yield this._resolveModule(moduleId, this._projectDir);
                if (resolveResult.kind === ModuleResolveResultKind.nodeJsCore) {
                    buildResult.resolved[iModule] = resolveResult.resolved;
                    addNodeJsCoreModuleReference(resolveResult.resolved, moduleId);
                }
                else if (resolveResult.kind === ModuleResolveResultKind.resolved) {
                    const moduleMeta = yield this._inspectRecursive(resolveResult.resolved, resolveResult.pkg);
                    topLevelModuleMetas[iModule] = moduleMeta;
                    buildResult.resolved[iModule] = resolveResult.resolved;
                }
                else if (resolveResult.kind === ModuleResolveResultKind.unresolved) {
                    buildResult.unresolved.push({
                        requested: moduleId,
                        reason: resolveResult.reason,
                    });
                }
            }
            const visited = new Set();
            const visit = (moduleMeta) => {
                visited.add(moduleMeta);
                if (moduleMeta.dependencies) {
                    for (const requestedModule of Object.keys(moduleMeta.dependencies)) {
                        const dependency = moduleMeta.dependencies[requestedModule];
                        if (dependency.kind === ModuleResolveResultKind.unresolved) {
                            buildResult.unresolved.push({
                                reason: dependency.reason,
                                requested: requestedModule,
                                file: moduleMeta.file,
                            });
                        }
                        else if (dependency.kind === ModuleResolveResultKind.nodeJsCore) {
                            addNodeJsCoreModuleReference(dependency.resolved, requestedModule, moduleMeta.file);
                        }
                        else {
                            if (!visited.has(dependency.resolved)) {
                                visit(dependency.resolved);
                            }
                        }
                    }
                }
            };
            for (const topLevelModuleMeta of topLevelModuleMetas) {
                if (topLevelModuleMeta) {
                    visit(topLevelModuleMeta);
                }
            }
            const mapping = new Array(modules.length).fill(null);
            if (importMapFile) {
                const importMapFileURL = path_url_interop_1.pathToFileURL(importMapFile);
                const importMap = {};
                for (let iModule = 0; iModule < modules.length; ++iModule) {
                    const moduleId = modules[iModule];
                    const topLevelModuleMeta = topLevelModuleMetas[iModule];
                    if (topLevelModuleMeta) {
                        const outFile = this._getOutFile(topLevelModuleMeta.file);
                        const outFileURL = path_url_interop_1.pathToFileURL(outFile);
                        mapping[iModule] = outFileURL;
                        const relativeURL = path_url_interop_1.moduleSpecifierURLRelative(importMapFileURL, outFileURL);
                        (_a = importMap.imports, (_a !== null && _a !== void 0 ? _a : (importMap.imports = {})))[moduleId] = relativeURL;
                    }
                }
                yield fs_extra_1.default.ensureDir(path_1.default.dirname(importMapFile));
                yield fs_extra_1.default.writeFile(importMapFile, JSON.stringify(importMap, undefined, 4));
            }
            return buildResult;
        });
    }
    _inspectRecursive(file, pkg) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileStat = yield fs_extra_1.default.stat(file);
            const fileTime = fileStat.mtimeMs;
            const cacheKey = this._getCacheKey(file);
            const outFile = this._getOutFile(file);
            if (cacheKey in this._rootCache.modules) {
                const moduleMetaCache = this._rootCache.modules[cacheKey];
                if (moduleMetaCache.inspectTime === fileTime &&
                    (yield fs_extra_1.default.pathExists(outFile))) {
                    return moduleMetaCache.meta;
                }
            }
            console.debug(`Inspecting ${file}...`);
            const moduleMetaCache = {
                file,
                inspectTime: fileTime,
                meta: {
                    file,
                    failed: true,
                },
            };
            this._rootCache.modules[cacheKey] = moduleMetaCache;
            const inspectResult = yield this._inspect(file, outFile, pkg ? this._rootCache.packages[pkg] : undefined);
            if (!inspectResult.failed) {
                delete moduleMetaCache.meta.failed;
            }
            if (inspectResult.dependencyResolveResults) {
                moduleMetaCache.meta.dependencies = {};
                for (const requestedModule of Object.keys(inspectResult.dependencyResolveResults)) {
                    const dependencyResolveResult = inspectResult.dependencyResolveResults[requestedModule];
                    if (dependencyResolveResult.kind === ModuleResolveResultKind.unresolved ||
                        dependencyResolveResult.kind === ModuleResolveResultKind.nodeJsCore) {
                        moduleMetaCache.meta.dependencies[requestedModule] = dependencyResolveResult;
                    }
                    else if (dependencyResolveResult.kind === ModuleResolveResultKind.resolved) {
                        const moduleMeta = yield this._inspectRecursive(dependencyResolveResult.resolved, dependencyResolveResult.pkg);
                        moduleMetaCache.meta.dependencies[requestedModule] = {
                            kind: ModuleResolveResultKind.resolved,
                            resolved: moduleMeta,
                        };
                    }
                }
            }
            return moduleMetaCache.meta;
        });
    }
    _inspect(file, outFile, pkg) {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceCode = (yield fs_extra_1.default.readFile(file)).toString();
            const passToESM = yield babel.transformAsync(sourceCode, {
                ast: true,
                sourceMaps: true,
                plugins: [
                    babel_plugin_transform_commonjs_1.default
                ],
            });
            if (!passToESM) {
                return {};
            }
            const requestedModules = [];
            babel.traverse(passToESM.ast, module_interop_1.makeVisitorOnModuleSpecifiers((path) => {
                requestedModules.push(path.node.value);
            }));
            const dependencyResolveResults = {};
            if (requestedModules) {
                const fileDir = path_1.default.dirname(file);
                for (const requestedModule of requestedModules) {
                    dependencyResolveResults[requestedModule] = yield this._resolveModule(requestedModule, fileDir, pkg);
                }
            }
            const applyResolveResult = {
                visitor: module_interop_1.makeVisitorOnModuleSpecifiers((path) => {
                    const requestedModule = path.node.value;
                    if (requestedModule in dependencyResolveResults) {
                        const resolveResult = dependencyResolveResults[requestedModule];
                        if (resolveResult.kind === ModuleResolveResultKind.resolved) {
                            const relative = path_url_interop_1.moduleSpecifierURLRelative(path_url_interop_1.pathToFileURL(file), path_url_interop_1.pathToFileURL(resolveResult.resolved));
                            path.replaceWith(babel.types.stringLiteral(relative));
                        }
                        else if (resolveResult.kind === ModuleResolveResultKind.browserFieldEmpty) {
                            path.replaceWith(babel.types.stringLiteral(this._externalModulePlaceHolder));
                        }
                    }
                }),
            };
            const passToDest = yield babel.transformFromAstAsync(passToESM.ast, undefined, {
                sourceMaps: 'inline',
                inputSourceMap: passToESM.map,
                plugins: [
                    applyResolveResult,
                ],
                presets: [
                    [{
                            plugins: [babel_plugin_kill_amd_1.default],
                        }],
                    [preset_env_1.default, { modules: 'systemjs' }]
                ],
            });
            if (!passToDest) {
                return {};
            }
            yield fs_extra_1.default.ensureDir(path_1.default.dirname(outFile));
            yield fs_extra_1.default.writeFile(outFile, passToDest.code);
            return {
                dependencyResolveResults,
            };
        });
    }
    _resolveModule(id, baseDir, baseDirPackageMeta) {
        return __awaiter(this, void 0, void 0, function* () {
            if (baseDirPackageMeta && baseDirPackageMeta.browserField) {
                if (id in baseDirPackageMeta.browserField.modules) {
                    const subsititution = baseDirPackageMeta.browserField.modules[id];
                    if (subsititution === false) {
                        return {
                            kind: ModuleResolveResultKind.browserFieldEmpty,
                        };
                    }
                    else {
                        return {
                            kind: ModuleResolveResultKind.resolved,
                            resolved: subsititution,
                        };
                    }
                }
            }
            try {
                return yield new Promise((resolve, reject) => {
                    const pkgPropertyKeyPackageMetaKey = '__bringer_package_meta_key__';
                    const relativePathBrowserFieldEmpty = '__browser_field_empty__';
                    resolve_1.default(id, {
                        basedir: baseDir,
                        packageFilter: (pkg, packagePath) => {
                            const packageMetaKey = this._updatePackageMeta(pkg, packagePath);
                            pkg[pkgPropertyKeyPackageMetaKey] = packageMetaKey;
                            return pkg;
                        },
                    }, (error, resolved, pkg) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            function assetsResolved(resolved) { }
                            assetsResolved(resolved);
                            if (resolve_1.default.isCore(resolved)) {
                                resolve({
                                    kind: ModuleResolveResultKind.nodeJsCore,
                                    resolved: resolved,
                                });
                            }
                            else if (resolved.endsWith(relativePathBrowserFieldEmpty)) {
                                return {
                                    kind: ModuleResolveResultKind.browserFieldEmpty,
                                };
                            }
                            else {
                                let resolveResultKind = ModuleResolveResultKind.resolved;
                                let packageMetaKey;
                                if (pkg && (pkgPropertyKeyPackageMetaKey in pkg)) {
                                    packageMetaKey = pkg[pkgPropertyKeyPackageMetaKey];
                                    const packageMeta = this._getPackageMeta(packageMetaKey);
                                    if (packageMeta.browserField) {
                                        const relative = path_1.default.relative(packageMeta.path, resolved);
                                        const normalizedRelative = normalizeRelativePath(relative);
                                        if (normalizedRelative in packageMeta.browserField.files) {
                                            const subsititution = packageMeta.browserField.files[normalizedRelative];
                                            if (subsititution === false) {
                                                resolveResultKind = ModuleResolveResultKind.browserFieldEmpty;
                                            }
                                            else {
                                                resolved = path_1.default.resolve(packageMeta.path, subsititution);
                                            }
                                        }
                                    }
                                }
                                resolve(resolveResultKind === ModuleResolveResultKind.browserFieldEmpty ? {
                                    kind: ModuleResolveResultKind.browserFieldEmpty,
                                } : {
                                    kind: ModuleResolveResultKind.resolved,
                                    resolved: resolved,
                                    pkg: packageMetaKey,
                                });
                            }
                        }
                    });
                });
            }
            catch (error) {
                return {
                    kind: ModuleResolveResultKind.unresolved,
                    reason: error,
                };
            }
        });
    }
    _getCacheKey(file) {
        let pathRelative = path_1.default.relative(this._projectDir, file);
        return pathRelative.replace(/\\/g, '/');
    }
    _getOutFile(file) {
        // !!!TODO handle out-of-project reference.
        const outFile = path_1.default.join(this._outDir, path_1.default.relative(this._projectDir, file));
        return outFile;
    }
    _updatePackageMeta(pkg, packagePath) {
        var _a;
        const packageMetaKey = this._getPackageMetaKey(packagePath);
        const packageFileStat = fs_extra_1.default.statSync(packagePath);
        const fileTime = packageFileStat.mtimeMs;
        if (packageMetaKey in this._rootCache.packages) {
            const packageMeta = this._rootCache.packages[packageMetaKey];
            if (packageMeta.inspectTime === fileTime) {
                return packageMetaKey;
            }
        }
        const packageMeta = {
            inspectTime: fileTime,
            path: path_1.default.dirname(packagePath),
        };
        const browserField = pkg['browser'];
        if (browserField === false || typeof browserField === 'string') {
            packageMeta.browserField = {
                modules: {},
                files: {
                    [normalizeRelativePath((_a = pkg.main, (_a !== null && _a !== void 0 ? _a : 'index.js')))]: normalizeRelativePath(browserField),
                },
            };
        }
        else if (typeof browserField === 'object') {
            packageMeta.browserField = {
                modules: {},
                files: {},
            };
            for (const fileOrModuleId of Object.keys(browserField)) {
                const subsititution = browserField[fileOrModuleId] === false ?
                    false : normalizeRelativePath(browserField[fileOrModuleId]);
                if (fileOrModuleId.startsWith('.') ||
                    path_1.default.extname(fileOrModuleId).length !== 0) {
                    // File id
                    packageMeta.browserField.files[normalizeRelativePath(fileOrModuleId)] = subsititution;
                }
                else {
                    // Module id
                    packageMeta.browserField.modules[fileOrModuleId] = subsititution;
                }
            }
        }
        this._rootCache.packages[packageMetaKey] = packageMeta;
        return packageMetaKey;
    }
    _getPackageMeta(key) {
        return this._rootCache.packages[key];
    }
    _getPackageMetaKey(packagePath) {
        return packagePath;
    }
}
exports.Bringer = Bringer;
(function (Bringer) {
    Bringer.defaultExternalModulePlaceHolder = '__BRINGER_EXCLUDED__';
})(Bringer = exports.Bringer || (exports.Bringer = {}));
function readCache(cacheFile) {
    try {
        const cache = fs_extra_1.default.readJSONSync(cacheFile);
        if (cache.version === VERSION) {
            return cache;
        }
    }
    catch (_a) {
    }
    return null;
}
function normalizeRelativePath(relativePath) {
    return path_1.default.normalize(relativePath).replace(/[\\]/g, '/');
}
//# sourceMappingURL=bringer.js.map