"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
class ModuleResolver {
    constructor(options) {
        this._rootDir = options.rootDir;
        const { compilerOptions } = readTSConfig(this._rootDir);
        this._compilerOptions = compilerOptions;
        this._moduleResolutionHost = {
            fileExists: typescript_1.default.sys.fileExists,
            readFile: typescript_1.default.sys.readFile,
        };
        this._moduleResolutionCache = typescript_1.default.createModuleResolutionCache(this._rootDir, (s) => path_1.default.normalize(s), compilerOptions);
    }
    resolve(specifier, fromFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolveResult = typescript_1.default.resolveModuleName(specifier, fromFile, this._compilerOptions, this._moduleResolutionHost, this._moduleResolutionCache, undefined);
            const { resolvedModule } = resolveResult;
            if (!resolvedModule) {
                const hackJSONPath = path_1.default.join(path_1.default.dirname(fromFile), `${specifier}.json`);
                if (yield fs_extra_1.default.pathExists(hackJSONPath)) {
                    return { file: hackJSONPath, isExternal: false };
                }
                return null;
            }
            else {
                if (resolvedModule.resolvedFileName.toLocaleLowerCase().endsWith('.d.ts')) {
                    const resolvedFileNameJs = resolvedModule.resolvedFileName.substr(resolvedModule.resolvedFileName.length - 5) + '.js';
                    if (yield fs_extra_1.default.pathExists(resolvedFileNameJs)) {
                        resolvedModule.resolvedFileName = resolvedFileNameJs;
                    }
                }
                return {
                    file: resolvedModule.resolvedFileName,
                    isExternal: !!resolvedModule.isExternalLibraryImport,
                };
            }
        });
    }
    resolveSync(specifier, fromFile) {
        const resolveResult = typescript_1.default.resolveModuleName(specifier, fromFile, this._compilerOptions, this._moduleResolutionHost, this._moduleResolutionCache, undefined);
        const { resolvedModule } = resolveResult;
        if (!resolvedModule) {
            const hackJSONPath = path_1.default.join(path_1.default.dirname(fromFile), `${specifier}.json`);
            if (fs_extra_1.default.pathExistsSync(hackJSONPath)) {
                return { file: hackJSONPath, isExternal: false };
            }
            return null;
        }
        else {
            if (resolvedModule.resolvedFileName.toLocaleLowerCase().endsWith('.d.ts')) {
                const resolvedFileNameJs = resolvedModule.resolvedFileName.substr(0, resolvedModule.resolvedFileName.length - 5) + '.js';
                if (fs_extra_1.default.pathExistsSync(resolvedFileNameJs)) {
                    resolvedModule.resolvedFileName = resolvedFileNameJs;
                }
            }
            return {
                file: resolvedModule.resolvedFileName,
                isExternal: !!resolvedModule.isExternalLibraryImport,
            };
        }
    }
}
exports.ModuleResolver = ModuleResolver;
function replaceWithOutputExtension(url) {
    const map = {
        '.d.ts': '.js',
        '.ts': '.js',
    };
    const urlLowercase = url.toLowerCase();
    for (const k of Object.keys(map)) {
        if (urlLowercase.endsWith(k)) {
            return `${url.substr(0, url.length - k.length)}${map[k]}`;
        }
    }
    return url;
}
exports.replaceWithOutputExtension = replaceWithOutputExtension;
function readTSConfig(baseDir) {
    const tsConfigFile = typescript_1.default.findConfigFile(baseDir, typescript_1.default.sys.fileExists);
    if (!tsConfigFile) {
        throw new Error(`Can not find tsconfig at ${baseDir}.`);
    }
    const tsConfig = typescript_1.default.readConfigFile(tsConfigFile, typescript_1.default.sys.readFile);
    if (!tsConfig.config) {
        throw new Error(`Failed to read tsconfig ${tsConfigFile}`);
    }
    const parseConfigHost = {
        useCaseSensitiveFileNames: typescript_1.default.sys.useCaseSensitiveFileNames,
        readFile: typescript_1.default.sys.readFile,
        readDirectory: typescript_1.default.sys.readDirectory,
        fileExists: typescript_1.default.sys.fileExists,
    };
    const parsedCommandLine = typescript_1.default.parseJsonConfigFileContent(tsConfig.config, parseConfigHost, baseDir);
    return {
        compilerOptions: parsedCommandLine.options,
    };
}
//# sourceMappingURL=module-resolve.js.map