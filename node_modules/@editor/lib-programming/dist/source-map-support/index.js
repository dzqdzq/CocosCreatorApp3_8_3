"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceMapSupport = void 0;
const source_map_1 = require("source-map");
const url_1 = require("url");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
/**
 * 参考 https://github.com/evanw/node-source-map-support/blob/master/source-map-support.js
 */
class SourceMapSupport {
    constructor() {
        this._sourceMapCache = {};
        this._fileContentsCache = {};
        this._myStackProperty = Symbol('[[Creator::stack]]');
    }
    install() {
        if (this._vendorPrepareStackTrace) {
            return;
        }
        this._vendorPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace =
            (...args) => this._prepareStackTrace(...args);
    }
    uninstall() {
        if (!this._vendorPrepareStackTrace) {
            return;
        }
        Error.prepareStackTrace = this._vendorPrepareStackTrace;
    }
    hasStackProperty(value) {
        return this._myStackProperty in value;
    }
    getStackProperty(value) {
        return value[this._myStackProperty];
    }
    _prepareStackTrace(err, stackTraces) {
        let vendorResult;
        if (this._vendorPrepareStackTrace) {
            // @ts-ignore
            vendorResult = this._vendorPrepareStackTrace.apply(undefined, arguments);
        }
        else {
            vendorResult = stackTraces.map(callSite => this._callSiteToString(callSite)).join('\n');
        }
        const myResult = this._prepareStackTracePostVendor(err, stackTraces, vendorResult);
        if (myResult) {
            return myResult;
        }
        return vendorResult;
    }
    _prepareStackTracePostVendor(err, stackTraces, _vendorResult) {
        if (typeof err !== 'object' || err === null) {
            return;
        }
        // const wrappedCallSites: WrappedCallSite[] = [];
        // for (const callSite of stackTraces) {
        //     const wrapped = this._wrapCallSite(callSite);
        //     if (wrapped) {
        //         wrappedCallSites.push(wrapped);
        //     }
        // }
        // if (wrappedCallSites.length !== 0) {
        //     Object.defineProperty(err, this._myStackProperty, {
        //         value: wrappedCallSites,
        //         enumerable: false,
        //     });
        //     return this._formatStack(err, wrappedCallSites);
        // }
        const state = { current: null, next: null };
        const wrappedCallSites = stackTraces.map((callSite) => {
            var _a;
            const wrapped = (_a = this._tryWrapCallSite(callSite, state)) !== null && _a !== void 0 ? _a : callSite;
            state.next = state.current;
            return wrapped;
        });
        state.current = state.next = null;
        return this._formatStack(err, wrappedCallSites);
    }
    _formatStack(err, wrappedCallSites) {
        var _a, _b;
        const stack = wrappedCallSites.map(callSite => `\n    at ${this._callSiteToString(callSite)}`).join('');
        return `${(_a = err.name) !== null && _a !== void 0 ? _a : 'Error'}: ${(_b = err.message) !== null && _b !== void 0 ? _b : ''}${stack}`;
    }
    _tryWrapCallSite(callSite, state) {
        try {
            return this._wrapCallSite(callSite, state);
        }
        catch (err) {
            console.debug(err);
            return;
        }
    }
    _wrapCallSite(callSite, state) {
        var _a, _b;
        state.current = null;
        if (callSite.isNative()) {
            return;
        }
        // Most call sites will return the source file from getFileName(), but code
        // passed to eval() ending in "//# sourceURL=..." will return the source file
        // from getScriptNameOrSourceURL() instead
        const source = (_a = callSite.getFileName()) !== null && _a !== void 0 ? _a : callSite.getScriptNameOrSourceURL();
        if (source) {
            const line = callSite.getLineNumber();
            let column = callSite.getColumnNumber() - 1;
            // Fix position in Node where some (internal) code is prepended.
            // See https://github.com/evanw/node-source-map-support/issues/36
            // Header removed in node at ^10.16 || >=11.11.0
            // v11 is not an LTS candidate, we can just test the one version with it.
            // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
            const noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
            const headerLength = noHeader.test(process.version) ? 0 : 62;
            if (line === 1 && column > headerLength /* && !isInBrowser()*/ && !callSite.isEval()) {
                column -= headerLength;
            }
            const mappedPosition = this._mapSourcePosition({ source, line, column });
            if (mappedPosition) {
                state.current = mappedPosition;
                const wrappedCallSite = cloneCallSite(callSite);
                wrappedCallSite.getFileName = () => mappedPosition.source;
                wrappedCallSite.getLineNumber = () => mappedPosition.line;
                wrappedCallSite.getColumnNumber = () => mappedPosition.column + 1;
                const nextName = (_b = state.next) === null || _b === void 0 ? void 0 : _b.name;
                if (nextName) {
                    wrappedCallSite.getFunctionName = () => nextName;
                }
                return wrappedCallSite;
            }
        }
        else if (callSite.isEval()) {
            const origin = callSite.getEvalOrigin();
            if (origin) {
                this._mapEvalOrigin(origin);
            }
        }
    }
    _callSiteToString(callSite) {
        var _a;
        let fileName;
        let fileLocation = "";
        if (callSite.isNative()) {
            fileLocation = "native";
        }
        else {
            fileName = callSite.getFileName();
            if (!fileName && callSite.isEval()) {
                fileLocation = (_a = callSite.getEvalOrigin()) !== null && _a !== void 0 ? _a : '';
                fileLocation += ", "; // Expecting source position to follow.
            }
            if (fileName) {
                fileLocation += fileName;
            }
            else {
                // Source code does not originate from a file and is not native, but we
                // can still get the source position inside the source string, e.g. in
                // an eval string.
                fileLocation += "<anonymous>";
            }
            const lineNumber = callSite.getLineNumber();
            if (lineNumber !== null) {
                fileLocation += ":" + lineNumber;
                const columnNumber = callSite.getColumnNumber();
                if (columnNumber) {
                    fileLocation += ":" + columnNumber;
                }
            }
        }
        let line = "";
        const functionName = callSite.getFunctionName();
        let addSuffix = true;
        const isConstructor = callSite.isConstructor();
        const isMethodCall = !(callSite.isToplevel() || isConstructor);
        if (isMethodCall) {
            let typeName = callSite.getTypeName();
            // Fixes shim to be backward compatable with Node v0 to v4
            if (typeName === "[object Object]") {
                typeName = "null";
            }
            const methodName = callSite.getMethodName();
            if (functionName) {
                if (typeName && functionName.indexOf(typeName) !== 0) {
                    line += typeName + ".";
                }
                line += functionName;
                if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
                    line += " [as " + methodName + "]";
                }
            }
            else {
                line += typeName + "." + (methodName || "<anonymous>");
            }
        }
        else if (isConstructor) {
            line += "new " + (functionName || "<anonymous>");
        }
        else if (functionName) {
            line += functionName;
        }
        else {
            line += fileLocation;
            addSuffix = false;
        }
        if (addSuffix) {
            line += " (" + fileLocation + ")";
        }
        return line;
    }
    _mapSourcePosition(position) {
        var _a;
        const sourceMapRecord = this._getSourceMap(position.source);
        if (!(sourceMapRecord === null || sourceMapRecord === void 0 ? void 0 : sourceMapRecord.map) ||
            typeof sourceMapRecord.map.originalPositionFor !== 'function') {
            return;
        }
        // Resolve the source URL relative to the URL of the source map.
        // Only return the original position if a matching line was found. If no
        // matching line is found then we return position instead, which will cause
        // the stack trace to print the path and line for the compiled file. It is
        // better to give a precise location in the compiled file than a vague
        // location in the original file.
        const originalPosition = sourceMapRecord.map.originalPositionFor(position);
        if (originalPosition.source === null || originalPosition.source === 'null') {
            return;
        }
        const resolved = this._resolveUrl(originalPosition.source, sourceMapRecord.url);
        if (resolved) {
            originalPosition.source = (_a = convertFileUrlToPath(resolved)) !== null && _a !== void 0 ? _a : resolved.href;
        }
        return originalPosition;
    }
    _mapEvalOrigin(origin) {
    }
    _getSourceMap(source) {
        var _a;
        const sourceUrl = this._resolveUrl(source);
        if (!sourceUrl) {
            return;
        }
        const { href } = sourceUrl;
        const sourceMapRecord = this._sourceMapCache[href];
        if (sourceMapRecord === undefined) {
            const fetchedSourceMap = this._fetchSourceMap(sourceUrl);
            if (!fetchedSourceMap) {
                this._sourceMapCache[href] = null;
            }
            else {
                const sourceMapUrl = fetchedSourceMap.url;
                // Load all sources stored inline with the source map into the file cache
                // to pretend like they are already loaded. They may not exist on disk.
                if (fetchedSourceMap.map.sourcesContent) {
                    fetchedSourceMap.map.sourcesContent.forEach((sourceContent, iSource) => {
                        var _a, _b;
                        if (sourceContent) {
                            const inlineSource = fetchedSourceMap.map.sources[iSource];
                            const inlineSourceUrl = (_b = (_a = this._resolveUrl(inlineSource, sourceMapUrl)) === null || _a === void 0 ? void 0 : _a.href) !== null && _b !== void 0 ? _b : inlineSource;
                            this._fileContentsCache[inlineSourceUrl] = sourceContent;
                        }
                    });
                }
                const sourceMapConsumer = new source_map_1.SourceMapConsumer(fetchedSourceMap.map);
                this._sourceMapCache[href] = { map: sourceMapConsumer, url: sourceMapUrl };
            }
        }
        return (_a = this._sourceMapCache[href]) !== null && _a !== void 0 ? _a : undefined;
    }
    _tryFetchSourceMap(source) {
        try {
            return this._fetchSourceMap(source);
        }
        catch (err) {
            console.debug(`Failed to fetch source map for '${source}': ${err}`);
            return;
        }
    }
    _fetchSourceMap(source) {
        const sourceMappingUri = this._fetchSourceMapUrl(source);
        if (!sourceMappingUri) {
            return;
        }
        // Read the contents of the source map
        let sourceMapData;
        let sourceMapUrl;
        if (reSourceMappingDataUrl.test(sourceMappingUri)) {
            // Support source map URL as a data url
            const rawData = sourceMappingUri.slice(sourceMappingUri.indexOf(',') + 1);
            sourceMapData = JSON.parse(Buffer.from(rawData, "base64").toString());
            sourceMapUrl = source;
        }
        else {
            // Support source map URLs relative to the source URL
            const resolved = this._resolveUrl(sourceMappingUri, source);
            if (!resolved) {
                return;
            }
            sourceMapUrl = resolved;
            const file = this._fetchFileSync(sourceMapUrl);
            if (!file) {
                return;
            }
            sourceMapData = JSON.parse(file);
        }
        if (!sourceMapData) {
            return;
        }
        return {
            url: sourceMapUrl,
            map: sourceMapData,
        };
    }
    _fetchSourceMapUrl(source) {
        const file = this._fetchFileSync(source);
        if (!file) {
            return;
        }
        const reg = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
        // Keep executing the search to find the *last* sourceMappingURL to avoid
        // picking up sourceMappingURLs from comments, strings, etc.
        let lastMatch;
        let match;
        while ((match = reg.exec(file))) {
            lastMatch = match;
        }
        if (!lastMatch) {
            return;
        }
        return lastMatch[1];
    }
    _fetchFileSync(url) {
        var _a, _b;
        const { href } = url;
        if (!(href in this._fileContentsCache)) {
            this._fileContentsCache[href] = (_a = this._doFetchFileSync(url)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this._fileContentsCache[href]) !== null && _b !== void 0 ? _b : undefined;
    }
    _doFetchFileSync(url) {
        let path;
        try {
            path = url_1.fileURLToPath(url);
        }
        catch (err) {
            console.warn(`${url.href} is not a valid file URL. We can only fetch source map in file system.`);
            return;
        }
        return fs_extra_1.default.readFileSync(path, { encoding: 'utf8' });
    }
    _resolveUrl(url, base) {
        if (path_1.default.isAbsolute(url)) {
            try {
                return url_1.pathToFileURL(url);
            }
            catch (_a) { }
        }
        try {
            return new url_1.URL(url, base);
        }
        catch (_b) {
            return;
        }
    }
}
exports.SourceMapSupport = SourceMapSupport;
// Regex for detecting source maps
const reSourceMappingDataUrl = /^data:application\/json[^,]+base64,/;
function cloneCallSite(callSite) {
    const object = {};
    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(callSite));
    names.forEach(function (name) {
        object[name] = /^(?:is|get)/.test(name) ? function () { return callSite[name].call(callSite); } : callSite[name];
    });
    return object;
}
function convertFileUrlToPath(url) {
    if (url.protocol === 'file:') {
        try {
            return url_1.fileURLToPath(url);
        }
        catch (_a) { }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc291cmNlLW1hcC1zdXBwb3J0L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLDJDQUF1RjtBQUN2Riw2QkFBd0Q7QUFDeEQsd0RBQTBCO0FBQzFCLGdEQUFzQjtBQXVCdEI7O0dBRUc7QUFDSCxNQUFhLGdCQUFnQjtJQUE3QjtRQTRXWSxvQkFBZSxHQUEyQyxFQUFFLENBQUM7UUFDN0QsdUJBQWtCLEdBQWtDLEVBQUUsQ0FBQztRQUV2RCxxQkFBZ0IsR0FBRyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBL1dHLE9BQU87UUFDSCxJQUFJLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtZQUMvQixPQUFPO1NBQ1Y7UUFDRCxJQUFJLENBQUMsd0JBQXdCLEdBQUcsS0FBSyxDQUFDLGlCQUFpQixDQUFDO1FBQ3hELEtBQUssQ0FBQyxpQkFBaUI7WUFDbkIsQ0FBQyxHQUFHLElBQW1DLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFFRCxTQUFTO1FBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtZQUNoQyxPQUFPO1NBQ1Y7UUFDRCxLQUFLLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDO0lBQzVELENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxLQUFVO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixJQUFJLEtBQUssQ0FBQztJQUMxQyxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsS0FBVTtRQUN2QixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQVUsQ0FBQztJQUNqRCxDQUFDO0lBRU8sa0JBQWtCLENBQUMsR0FBVSxFQUFFLFdBQThCO1FBQ2pFLElBQUksWUFBaUIsQ0FBQztRQUN0QixJQUFJLElBQUks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RXJFLFNBQVMsYUFBYSxDQUFDLFFBQXlCO0lBQzVDLE1BQU0sTUFBTSxHQUFRLEVBQUUsQ0FBQztJQUN2QixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLEtBQW1DLENBQUMsT0FBTyxDQUFDLFVBQVUsSUFBSTtRQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNySCxDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sTUFBTSxDQUFDO0FBQ2xCLENBQUM7QUFFRCxTQUFTLG9CQUFvQixDQUFDLEdBQVE7SUFDbEMsSUFBSSxHQUFHLENBQUMsUUFBUSxLQUFLLE9BQU8sRUFBRTtRQUMxQixJQUFJO1lBQ0EsT0FBTyxtQkFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzdCO1FBQUMsV0FBTSxHQUFHO0tBQ2Q7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBNYXBwZWRQb3NpdGlvbiwgUG9zaXRpb24sIFJhd1NvdXJjZU1hcCwgU291cmNlTWFwQ29uc3VtZXIgfSBmcm9tICdzb3VyY2UtbWFwJztcbmltcG9ydCB7IFVSTCwgZmlsZVVSTFRvUGF0aCwgcGF0aFRvRmlsZVVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBzIGZyb20gJ3BhdGgnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuXG50eXBlIFByZXBhcmVTdGFja1RyYWNlID0gTm9uTnVsbGFibGU8RXJyb3JDb25zdHJ1Y3RvclsncHJlcGFyZVN0YWNrVHJhY2UnXT47XG5cbnR5cGUgU3RhY2sgPSBzdHJpbmc7XG5cbnR5cGUgV3JhcHBlZENhbGxTaXRlID0gTm9kZUpTLkNhbGxTaXRlO1xuXG5pbnRlcmZhY2UgU291cmNlTWFwUmVjb3JkIHtcbiAgICBtYXA6IFNvdXJjZU1hcENvbnN1bWVyO1xuICAgIHVybDogVVJMO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9ub2RlLXNvdXJjZS1tYXAtc3VwcG9ydC9wdWxsLzI1M1xuICovXG5pbnRlcmZhY2UgU3RhdGUge1xuICAgIGN1cnJlbnQ6IE1hcHBlZFBvc2l0aW9uIHwgbnVsbDtcbiAgICBuZXh0OiBNYXBwZWRQb3NpdGlvbiB8IG51bGw7XG59XG5cbi8qKlxuICog5Y+C6ICDIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9ub2RlLXNvdXJjZS1tYXAtc3VwcG9ydC9ibG9iL21hc3Rlci9zb3VyY2UtbWFwLXN1cHBvcnQuanNcbiAqL1xuZXhwb3J0IGNsYXNzIFNvdXJjZU1hcFN1cHBvcnQge1xuICAgIGluc3RhbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLl92ZW5kb3JQcmVwYXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZlbmRvclByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID1cbiAgICAgICAgICAgICguLi5hcmdzOiBQYXJhbWV0ZXJzPFByZXBhcmVTdGFja1RyYWNlPikgPT4gdGhpcy5fcHJlcGFyZVN0YWNrVHJhY2UoLi4uYXJncyk7XG4gICAgfVxuXG4gICAgdW5pbnN0YWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZlbmRvclByZXBhcmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB0aGlzLl92ZW5kb3JQcmVwYXJlU3RhY2tUcmFjZTtcbiAgICB9XG5cbiAgICBoYXNTdGFja1Byb3BlcnR5KHZhbHVlOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX215U3RhY2tQcm9wZXJ0eSBpbiB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXRTdGFja1Byb3BlcnR5KHZhbHVlOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW3RoaXMuX215U3RhY2tQcm9wZXJ0eV0gYXMgU3RhY2s7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcHJlcGFyZVN0YWNrVHJhY2UoZXJyOiBFcnJvciwgc3RhY2tUcmFjZXM6IE5vZGVKUy5DYWxsU2l0ZVtdKSB7XG4gICAgICAgIGxldCB2ZW5kb3JSZXN1bHQ6IGFueTtcbiAgICAgICAgaWYgKHRoaXMuX3ZlbmRvclByZXBhcmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB2ZW5kb3JSZXN1bHQgPSB0aGlzLl92ZW5kb3JQcmVwYXJlU3RhY2tUcmFjZS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZW5kb3JSZXN1bHQgPSBzdGFja1RyYWNlcy5tYXAoY2FsbFNpdGUgPT4gdGhpcy5fY2FsbFNpdGVUb1N0cmluZyhjYWxsU2l0ZSkpLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG15UmVzdWx0ID0gdGhpcy5fcHJlcGFyZVN0YWNrVHJhY2VQb3N0VmVuZG9yKGVyciwgc3RhY2tUcmFjZXMsIHZlbmRvclJlc3VsdCk7XG4gICAgICAgIGlmIChteVJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIG15UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZW5kb3JSZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcHJlcGFyZVN0YWNrVHJhY2VQb3N0VmVuZG9yKFxuICAgICAgICBlcnI6IEVycm9yLFxuICAgICAgICBzdGFja1RyYWNlczogTm9kZUpTLkNhbGxTaXRlW10sXG4gICAgICAgIF92ZW5kb3JSZXN1bHQ6IGFueSxcbiAgICApOiBhbnkge1xuICAgICAgICBpZiAodHlwZW9mIGVyciAhPT0gJ29iamVjdCcgfHwgZXJyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdCB3cmFwcGVkQ2FsbFNpdGVzOiBXcmFwcGVkQ2FsbFNpdGVbXSA9IFtdO1xuICAgICAgICAvLyBmb3IgKGNvbnN0IGNhbGxTaXRlIG9mIHN0YWNrVHJhY2VzKSB7XG4gICAgICAgIC8vICAgICBjb25zdCB3cmFwcGVkID0gdGhpcy5fd3JhcENhbGxTaXRlKGNhbGxTaXRlKTtcbiAgICAgICAgLy8gICAgIGlmICh3cmFwcGVkKSB7XG4gICAgICAgIC8vICAgICAgICAgd3JhcHBlZENhbGxTaXRlcy5wdXNoKHdyYXBwZWQpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmICh3cmFwcGVkQ2FsbFNpdGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgdGhpcy5fbXlTdGFja1Byb3BlcnR5LCB7XG4gICAgICAgIC8vICAgICAgICAgdmFsdWU6IHdyYXBwZWRDYWxsU2l0ZXMsXG4gICAgICAgIC8vICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLl9mb3JtYXRTdGFjayhlcnIsIHdyYXBwZWRDYWxsU2l0ZXMpO1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0IHN0YXRlOiBTdGF0ZSA9IHsgY3VycmVudDogbnVsbCwgbmV4dDogbnVsbCB9O1xuICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbFNpdGVzID0gc3RhY2tUcmFjZXMubWFwKChjYWxsU2l0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHRoaXMuX3RyeVdyYXBDYWxsU2l0ZShjYWxsU2l0ZSwgc3RhdGUpID8/IGNhbGxTaXRlO1xuICAgICAgICAgICAgc3RhdGUubmV4dCA9IHN0YXRlLmN1cnJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLmN1cnJlbnQgPSBzdGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdFN0YWNrKGVyciwgd3JhcHBlZENhbGxTaXRlcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZm9ybWF0U3RhY2soZXJyOiBFcnJvciwgd3JhcHBlZENhbGxTaXRlczogV3JhcHBlZENhbGxTaXRlW10pIHtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSB3cmFwcGVkQ2FsbFNpdGVzLm1hcChjYWxsU2l0ZSA9PiBgXFxuICAgIGF0ICR7dGhpcy5fY2FsbFNpdGVUb1N0cmluZyhjYWxsU2l0ZSl9YCkuam9pbignJyk7XG4gICAgICAgIHJldHVybiBgJHtlcnIubmFtZSA/PyAnRXJyb3InfTogJHtlcnIubWVzc2FnZSA/PyAnJ30ke3N0YWNrfWA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdHJ5V3JhcENhbGxTaXRlKGNhbGxTaXRlOiBOb2RlSlMuQ2FsbFNpdGUsIHN0YXRlOiBTdGF0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBDYWxsU2l0ZShjYWxsU2l0ZSwgc3RhdGUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX3dyYXBDYWxsU2l0ZShjYWxsU2l0ZTogTm9kZUpTLkNhbGxTaXRlLCBzdGF0ZTogU3RhdGUpOiBXcmFwcGVkQ2FsbFNpdGUgfCB1bmRlZmluZWQge1xuICAgICAgICBzdGF0ZS5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAoY2FsbFNpdGUuaXNOYXRpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW9zdCBjYWxsIHNpdGVzIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZSBmcm9tIGdldEZpbGVOYW1lKCksIGJ1dCBjb2RlXG4gICAgICAgIC8vIHBhc3NlZCB0byBldmFsKCkgZW5kaW5nIGluIFwiLy8jIHNvdXJjZVVSTD0uLi5cIiB3aWxsIHJldHVybiB0aGUgc291cmNlIGZpbGVcbiAgICAgICAgLy8gZnJvbSBnZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwoKSBpbnN0ZWFkXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGNhbGxTaXRlLmdldEZpbGVOYW1lKCkgPz8gKChjYWxsU2l0ZSBhcyBhbnkpLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpIGFzIHN0cmluZyB8IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBjYWxsU2l0ZS5nZXRMaW5lTnVtYmVyKCkhO1xuICAgICAgICAgICAgbGV0IGNvbHVtbiA9IGNhbGxTaXRlLmdldENvbHVtbk51bWJlcigpISAtIDE7XG4gICAgICAgICAgICAvLyBGaXggcG9zaXRpb24gaW4gTm9kZSB3aGVyZSBzb21lIChpbnRlcm5hbCkgY29kZSBpcyBwcmVwZW5kZWQuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L25vZGUtc291cmNlLW1hcC1zdXBwb3J0L2lzc3Vlcy8zNlxuICAgICAgICAgICAgLy8gSGVhZGVyIHJlbW92ZWQgaW4gbm9kZSBhdCBeMTAuMTYgfHwgPj0xMS4xMS4wXG4gICAgICAgICAgICAvLyB2MTEgaXMgbm90IGFuIExUUyBjYW5kaWRhdGUsIHdlIGNhbiBqdXN0IHRlc3QgdGhlIG9uZSB2ZXJzaW9uIHdpdGggaXQuXG4gICAgICAgICAgICAvLyBUZXN0IG5vZGUgdmVyc2lvbnMgZm9yOiAxMC4xNi0xOSwgMTAuMjArLCAxMi0xOSwgMjAtOTksIDEwMCssIG9yIDExLjExXG4gICAgICAgICAgICBjb25zdCBub0hlYWRlciA9IC9edigxMFxcLjFbNi05XXwxMFxcLlsyLTldWzAtOV18MTBcXC5bMC05XXszLH18MVsyLTldXFxkKnxbMi05XVxcZHxcXGR7Myx9fDExXFwuMTEpLztcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IG5vSGVhZGVyLnRlc3QocHJvY2Vzcy52ZXJzaW9uKSA/IDAgOiA2MjtcbiAgICAgICAgICAgIGlmIChsaW5lID09PSAxICYmIGNvbHVtbiA+IGhlYWRlckxlbmd0aCAvKiAmJiAhaXNJbkJyb3dzZXIoKSovICYmICFjYWxsU2l0ZS5pc0V2YWwoKSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbiAtPSBoZWFkZXJMZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZFBvc2l0aW9uID0gdGhpcy5fbWFwU291cmNlUG9zaXRpb24oeyBzb3VyY2UsIGxpbmUsIGNvbHVtbiB9KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQgPSBtYXBwZWRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbFNpdGUgPSBjbG9uZUNhbGxTaXRlKGNhbGxTaXRlKTtcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbFNpdGUuZ2V0RmlsZU5hbWUgPSAoKSA9PiBtYXBwZWRQb3NpdGlvbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgd3JhcHBlZENhbGxTaXRlLmdldExpbmVOdW1iZXIgPSAoKSA9PiBtYXBwZWRQb3NpdGlvbi5saW5lO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsU2l0ZS5nZXRDb2x1bW5OdW1iZXIgPSAoKSA9PiBtYXBwZWRQb3NpdGlvbi5jb2x1bW4gKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROYW1lID0gc3RhdGUubmV4dD8ubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZENhbGxTaXRlLmdldEZ1bmN0aW9uTmFtZSA9ICgpID0+IG5leHROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZENhbGxTaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNhbGxTaXRlLmlzRXZhbCgpKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBjYWxsU2l0ZS5nZXRFdmFsT3JpZ2luKCk7XG4gICAgICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwRXZhbE9yaWdpbihvcmlnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2FsbFNpdGVUb1N0cmluZyhjYWxsU2l0ZTogV3JhcHBlZENhbGxTaXRlKSB7XG4gICAgICAgIGxldCBmaWxlTmFtZTtcbiAgICAgICAgbGV0IGZpbGVMb2NhdGlvbiA9IFwiXCI7XG4gICAgICAgIGlmIChjYWxsU2l0ZS5pc05hdGl2ZSgpKSB7XG4gICAgICAgICAgICBmaWxlTG9jYXRpb24gPSBcIm5hdGl2ZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBjYWxsU2l0ZS5nZXRGaWxlTmFtZSgpO1xuICAgICAgICAgICAgaWYgKCFmaWxlTmFtZSAmJiBjYWxsU2l0ZS5pc0V2YWwoKSkge1xuICAgICAgICAgICAgICAgIGZpbGVMb2NhdGlvbiA9IGNhbGxTaXRlLmdldEV2YWxPcmlnaW4oKSA/PyAnJztcbiAgICAgICAgICAgICAgICBmaWxlTG9jYXRpb24gKz0gXCIsIFwiOyAgLy8gRXhwZWN0aW5nIHNvdXJjZSBwb3NpdGlvbiB0byBmb2xsb3cuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIGZpbGVMb2NhdGlvbiArPSBmaWxlTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU291cmNlIGNvZGUgZG9lcyBub3Qgb3JpZ2luYXRlIGZyb20gYSBmaWxlIGFuZCBpcyBub3QgbmF0aXZlLCBidXQgd2VcbiAgICAgICAgICAgICAgICAvLyBjYW4gc3RpbGwgZ2V0IHRoZSBzb3VyY2UgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2Ugc3RyaW5nLCBlLmcuIGluXG4gICAgICAgICAgICAgICAgLy8gYW4gZXZhbCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgZmlsZUxvY2F0aW9uICs9IFwiPGFub255bW91cz5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBjYWxsU2l0ZS5nZXRMaW5lTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAobGluZU51bWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjpcIiArIGxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uTnVtYmVyID0gY2FsbFNpdGUuZ2V0Q29sdW1uTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbk51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBmaWxlTG9jYXRpb24gKz0gXCI6XCIgKyBjb2x1bW5OdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpbmUgPSBcIlwiO1xuICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBjYWxsU2l0ZS5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgICAgICAgbGV0IGFkZFN1ZmZpeCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGlzQ29uc3RydWN0b3IgPSBjYWxsU2l0ZS5pc0NvbnN0cnVjdG9yKCk7XG4gICAgICAgIGNvbnN0IGlzTWV0aG9kQ2FsbCA9ICEoY2FsbFNpdGUuaXNUb3BsZXZlbCgpIHx8IGlzQ29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoaXNNZXRob2RDYWxsKSB7XG4gICAgICAgICAgICBsZXQgdHlwZU5hbWUgPSBjYWxsU2l0ZS5nZXRUeXBlTmFtZSgpO1xuICAgICAgICAgICAgLy8gRml4ZXMgc2hpbSB0byBiZSBiYWNrd2FyZCBjb21wYXRhYmxlIHdpdGggTm9kZSB2MCB0byB2NFxuICAgICAgICAgICAgaWYgKHR5cGVOYW1lID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgICAgICAgICAgdHlwZU5hbWUgPSBcIm51bGxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBjYWxsU2l0ZS5nZXRNZXRob2ROYW1lKCk7XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVOYW1lICYmIGZ1bmN0aW9uTmFtZS5pbmRleE9mKHR5cGVOYW1lKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IHR5cGVOYW1lICsgXCIuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2ROYW1lICYmIGZ1bmN0aW9uTmFtZS5pbmRleE9mKFwiLlwiICsgbWV0aG9kTmFtZSkgIT09IGZ1bmN0aW9uTmFtZS5sZW5ndGggLSBtZXRob2ROYW1lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSArPSBcIiBbYXMgXCIgKyBtZXRob2ROYW1lICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lICs9IHR5cGVOYW1lICsgXCIuXCIgKyAobWV0aG9kTmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gXCJuZXcgXCIgKyAoZnVuY3Rpb25OYW1lIHx8IFwiPGFub255bW91cz5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBsaW5lICs9IGZ1bmN0aW9uTmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmUgKz0gZmlsZUxvY2F0aW9uO1xuICAgICAgICAgICAgYWRkU3VmZml4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZFN1ZmZpeCkge1xuICAgICAgICAgICAgbGluZSArPSBcIiAoXCIgKyBmaWxlTG9jYXRpb24gKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYXBTb3VyY2VQb3NpdGlvbihwb3NpdGlvbjogUG9zaXRpb24gJiB7IHNvdXJjZTogc3RyaW5nIH0pOiBNYXBwZWRQb3NpdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU1hcFJlY29yZCA9IHRoaXMuX2dldFNvdXJjZU1hcChwb3NpdGlvbi5zb3VyY2UpO1xuICAgICAgICBpZiAoIXNvdXJjZU1hcFJlY29yZD8ubWFwIHx8XG4gICAgICAgICAgICB0eXBlb2Ygc291cmNlTWFwUmVjb3JkLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBzb3VyY2UgVVJMIHJlbGF0aXZlIHRvIHRoZSBVUkwgb2YgdGhlIHNvdXJjZSBtYXAuXG4gICAgICAgIC8vIE9ubHkgcmV0dXJuIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpZiBhIG1hdGNoaW5nIGxpbmUgd2FzIGZvdW5kLiBJZiBub1xuICAgICAgICAvLyBtYXRjaGluZyBsaW5lIGlzIGZvdW5kIHRoZW4gd2UgcmV0dXJuIHBvc2l0aW9uIGluc3RlYWQsIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAgICAgLy8gdGhlIHN0YWNrIHRyYWNlIHRvIHByaW50IHRoZSBwYXRoIGFuZCBsaW5lIGZvciB0aGUgY29tcGlsZWQgZmlsZS4gSXQgaXNcbiAgICAgICAgLy8gYmV0dGVyIHRvIGdpdmUgYSBwcmVjaXNlIGxvY2F0aW9uIGluIHRoZSBjb21waWxlZCBmaWxlIHRoYW4gYSB2YWd1ZVxuICAgICAgICAvLyBsb2NhdGlvbiBpbiB0aGUgb3JpZ2luYWwgZmlsZS5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQb3NpdGlvbiA9IHNvdXJjZU1hcFJlY29yZC5tYXAub3JpZ2luYWxQb3NpdGlvbkZvcihwb3NpdGlvbik7XG4gICAgICAgIGlmIChvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSA9PT0gbnVsbCB8fCBvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMuX3Jlc29sdmVVcmwob3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UsIHNvdXJjZU1hcFJlY29yZC51cmwpO1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsUG9zaXRpb24uc291cmNlID0gY29udmVydEZpbGVVcmxUb1BhdGgocmVzb2x2ZWQpID8/IHJlc29sdmVkLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3JpZ2luYWxQb3NpdGlvbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYXBFdmFsT3JpZ2luKG9yaWdpbjogc3RyaW5nKSB7XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXRTb3VyY2VNYXAoc291cmNlOiBzdHJpbmcpOiBTb3VyY2VNYXBSZWNvcmQgfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCBzb3VyY2VVcmwgPSB0aGlzLl9yZXNvbHZlVXJsKHNvdXJjZSk7XG4gICAgICAgIGlmICghc291cmNlVXJsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBocmVmIH0gPSBzb3VyY2VVcmw7XG4gICAgICAgIGNvbnN0IHNvdXJjZU1hcFJlY29yZCA9IHRoaXMuX3NvdXJjZU1hcENhY2hlW2hyZWZdO1xuICAgICAgICBpZiAoc291cmNlTWFwUmVjb3JkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZldGNoZWRTb3VyY2VNYXAgPSB0aGlzLl9mZXRjaFNvdXJjZU1hcChzb3VyY2VVcmwpO1xuICAgICAgICAgICAgaWYgKCFmZXRjaGVkU291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwQ2FjaGVbaHJlZl0gPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VNYXBVcmwgPSBmZXRjaGVkU291cmNlTWFwLnVybDtcblxuICAgICAgICAgICAgICAgIC8vIExvYWQgYWxsIHNvdXJjZXMgc3RvcmVkIGlubGluZSB3aXRoIHRoZSBzb3VyY2UgbWFwIGludG8gdGhlIGZpbGUgY2FjaGVcbiAgICAgICAgICAgICAgICAvLyB0byBwcmV0ZW5kIGxpa2UgdGhleSBhcmUgYWxyZWFkeSBsb2FkZWQuIFRoZXkgbWF5IG5vdCBleGlzdCBvbiBkaXNrLlxuICAgICAgICAgICAgICAgIGlmIChmZXRjaGVkU291cmNlTWFwLm1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaGVkU291cmNlTWFwLm1hcC5zb3VyY2VzQ29udGVudC5mb3JFYWNoKChzb3VyY2VDb250ZW50OiBzdHJpbmcsIGlTb3VyY2U6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmxpbmVTb3VyY2UgPSBmZXRjaGVkU291cmNlTWFwLm1hcC5zb3VyY2VzW2lTb3VyY2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubGluZVNvdXJjZVVybCA9IHRoaXMuX3Jlc29sdmVVcmwoaW5saW5lU291cmNlLCBzb3VyY2VNYXBVcmwpPy5ocmVmID8/IGlubGluZVNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxlQ29udGVudHNDYWNoZVtpbmxpbmVTb3VyY2VVcmxdID0gc291cmNlQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlTWFwQ29uc3VtZXIgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIoZmV0Y2hlZFNvdXJjZU1hcC5tYXApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZU1hcENhY2hlW2hyZWZdID0geyBtYXA6IHNvdXJjZU1hcENvbnN1bWVyLCB1cmw6IHNvdXJjZU1hcFVybCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VNYXBDYWNoZVtocmVmXSA/PyB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdHJ5RmV0Y2hTb3VyY2VNYXAoc291cmNlOiBVUkwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFNvdXJjZU1hcChzb3VyY2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYEZhaWxlZCB0byBmZXRjaCBzb3VyY2UgbWFwIGZvciAnJHtzb3VyY2V9JzogJHtlcnJ9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9mZXRjaFNvdXJjZU1hcChzb3VyY2U6IFVSTCk6IHVuZGVmaW5lZCB8IHsgbWFwOiBSYXdTb3VyY2VNYXAsIHVybDogVVJMIH0ge1xuICAgICAgICBjb25zdCBzb3VyY2VNYXBwaW5nVXJpID0gdGhpcy5fZmV0Y2hTb3VyY2VNYXBVcmwoc291cmNlKTtcbiAgICAgICAgaWYgKCFzb3VyY2VNYXBwaW5nVXJpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgc291cmNlIG1hcFxuICAgICAgICBsZXQgc291cmNlTWFwRGF0YTogUmF3U291cmNlTWFwO1xuICAgICAgICBsZXQgc291cmNlTWFwVXJsOiBVUkw7XG4gICAgICAgIGlmIChyZVNvdXJjZU1hcHBpbmdEYXRhVXJsLnRlc3Qoc291cmNlTWFwcGluZ1VyaSkpIHtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgc291cmNlIG1hcCBVUkwgYXMgYSBkYXRhIHVybFxuICAgICAgICAgICAgY29uc3QgcmF3RGF0YSA9IHNvdXJjZU1hcHBpbmdVcmkuc2xpY2Uoc291cmNlTWFwcGluZ1VyaS5pbmRleE9mKCcsJykgKyAxKTtcbiAgICAgICAgICAgIHNvdXJjZU1hcERhdGEgPSBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKHJhd0RhdGEsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgc291cmNlTWFwVXJsID0gc291cmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3VwcG9ydCBzb3VyY2UgbWFwIFVSTHMgcmVsYXRpdmUgdG8gdGhlIHNvdXJjZSBVUkxcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5fcmVzb2x2ZVVybChzb3VyY2VNYXBwaW5nVXJpLCBzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZU1hcFVybCA9IHJlc29sdmVkO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuX2ZldGNoRmlsZVN5bmMoc291cmNlTWFwVXJsKTtcbiAgICAgICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZU1hcERhdGEgPSBKU09OLnBhcnNlKGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzb3VyY2VNYXBEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsOiBzb3VyY2VNYXBVcmwsXG4gICAgICAgICAgICBtYXA6IHNvdXJjZU1hcERhdGEsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmV0Y2hTb3VyY2VNYXBVcmwoc291cmNlOiBVUkwpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5fZmV0Y2hGaWxlU3luYyhzb3VyY2UpO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlZyA9IC8oPzpcXC9cXC9bQCNdW1xcc10qc291cmNlTWFwcGluZ1VSTD0oW15cXHMnXCJdKylbXFxzXSokKXwoPzpcXC9cXCpbQCNdW1xcc10qc291cmNlTWFwcGluZ1VSTD0oW15cXHMqJ1wiXSspW1xcc10qKD86XFwqXFwvKVtcXHNdKiQpL21nO1xuICAgICAgICAvLyBLZWVwIGV4ZWN1dGluZyB0aGUgc2VhcmNoIHRvIGZpbmQgdGhlICpsYXN0KiBzb3VyY2VNYXBwaW5nVVJMIHRvIGF2b2lkXG4gICAgICAgIC8vIHBpY2tpbmcgdXAgc291cmNlTWFwcGluZ1VSTHMgZnJvbSBjb21tZW50cywgc3RyaW5ncywgZXRjLlxuICAgICAgICBsZXQgbGFzdE1hdGNoOiBSZWdFeHBNYXRjaEFycmF5IHwgdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGw7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWcuZXhlYyhmaWxlKSkpIHtcbiAgICAgICAgICAgIGxhc3RNYXRjaCA9IG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYXN0TWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXN0TWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmV0Y2hGaWxlU3luYyh1cmw6IFVSTCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gdXJsO1xuICAgICAgICBpZiAoIShocmVmIGluIHRoaXMuX2ZpbGVDb250ZW50c0NhY2hlKSkge1xuICAgICAgICAgICAgdGhpcy5fZmlsZUNvbnRlbnRzQ2FjaGVbaHJlZl0gPSB0aGlzLl9kb0ZldGNoRmlsZVN5bmModXJsKSA/PyBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxlQ29udGVudHNDYWNoZVtocmVmXSA/PyB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZG9GZXRjaEZpbGVTeW5jKHVybDogVVJMKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgbGV0IHBhdGg6IHN0cmluZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhdGggPSBmaWxlVVJMVG9QYXRoKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke3VybC5ocmVmfSBpcyBub3QgYSB2YWxpZCBmaWxlIFVSTC4gV2UgY2FuIG9ubHkgZmV0Y2ggc291cmNlIG1hcCBpbiBmaWxlIHN5c3RlbS5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKHBhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9yZXNvbHZlVXJsKHVybDogc3RyaW5nLCBiYXNlPzogVVJMKTogVVJMIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKHBzLmlzQWJzb2x1dGUodXJsKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFRvRmlsZVVSTCh1cmwpO1xuICAgICAgICAgICAgfSBjYXRjaCB7IH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsLCBiYXNlKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9zb3VyY2VNYXBDYWNoZTogUmVjb3JkPHN0cmluZywgU291cmNlTWFwUmVjb3JkIHwgbnVsbD4gPSB7fTtcbiAgICBwcml2YXRlIF9maWxlQ29udGVudHNDYWNoZTogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVsbD4gPSB7fTtcbiAgICBwcml2YXRlIF92ZW5kb3JQcmVwYXJlU3RhY2tUcmFjZTogdW5kZWZpbmVkIHwgUHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgcHJpdmF0ZSBfbXlTdGFja1Byb3BlcnR5ID0gU3ltYm9sKCdbW0NyZWF0b3I6OnN0YWNrXV0nKTtcbn1cblxuLy8gUmVnZXggZm9yIGRldGVjdGluZyBzb3VyY2UgbWFwc1xuY29uc3QgcmVTb3VyY2VNYXBwaW5nRGF0YVVybCA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb25bXixdK2Jhc2U2NCwvO1xuXG5mdW5jdGlvbiBjbG9uZUNhbGxTaXRlKGNhbGxTaXRlOiBOb2RlSlMuQ2FsbFNpdGUpOiBOb2RlSlMuQ2FsbFNpdGUge1xuICAgIGNvbnN0IG9iamVjdDogYW55ID0ge307XG4gICAgY29uc3QgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2FsbFNpdGUpKTtcbiAgICAobmFtZXMgYXMgKGtleW9mIE5vZGVKUy5DYWxsU2l0ZSlbXSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvYmplY3RbbmFtZV0gPSAvXig/OmlzfGdldCkvLnRlc3QobmFtZSkgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsU2l0ZVtuYW1lXS5jYWxsKGNhbGxTaXRlKTsgfSA6IGNhbGxTaXRlW25hbWVdO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGaWxlVXJsVG9QYXRoKHVybDogVVJMKSB7XG4gICAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVVUkxUb1BhdGgodXJsKTtcbiAgICAgICAgfSBjYXRjaCB7IH1cbiAgICB9XG59XG4iXX0=