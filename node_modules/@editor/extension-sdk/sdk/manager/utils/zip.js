"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unzip = exports.zip = void 0;
const jszip_1 = __importDefault(require("jszip"));
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const recursive = async (dirPath, handle) => {
    if (!(await (0, fs_extra_1.pathExists)(dirPath)))
        return;
    const fileStats = await (0, fs_extra_1.stat)(dirPath);
    if (fileStats.isSymbolicLink())
        return;
    if (fileStats.isDirectory()) {
        const fileList = await (0, fs_extra_1.readdir)(dirPath, { withFileTypes: true });
        for (let i = 0, len = fileList.length; i < len; i++) {
            const temp = fileList[i];
            await recursive((0, path_1.join)(dirPath, temp.name), handle);
        }
    }
    else if (fileStats.isFile()) {
        await handle(dirPath, (0, path_1.extname)(dirPath), fileStats);
    }
};
const zip = async (targetPath, destPath, level = 1) => {
    if (!(await (0, fs_extra_1.pathExists)(targetPath)))
        throw new Error('Zip requires a valid address');
    const zipHandle = new jszip_1.default();
    await recursive(targetPath, async (file) => {
        const fileContent = await (0, fs_extra_1.readFile)(file);
        zipHandle
            ?.file((0, path_1.relative)(targetPath, file).split(path_1.sep).join('/'), fileContent);
    });
    const buffer = await zipHandle.generateAsync({
        type: 'nodebuffer',
        compression: 'DEFLATE',
        compressionOptions: { level },
    });
    await (0, fs_extra_1.writeFile)(destPath, buffer);
};
exports.zip = zip;
const unzip = async (targetPath, destPath) => {
    if (!(await (0, fs_extra_1.pathExists)(targetPath)))
        throw new Error('zip path is invalid');
    const zipHandle = new jszip_1.default();
    const buffer = await (0, fs_extra_1.readFile)(targetPath);
    const handle = await zipHandle.loadAsync(buffer, { createFolders: false });
    const { files } = handle;
    const keys = Object.keys(files);
    for (let i = 0, len = keys.length; i < len; i++) {
        const temp = (0, path_1.join)(destPath, keys[i]);
        await (0, fs_extra_1.ensureDir)((0, path_1.dirname)(temp));
        if (!handle.files[keys[i]].dir) {
            const content = await handle.files[keys[i]].async('nodebuffer');
            await (0, fs_extra_1.writeFile)(temp, content);
        }
    }
};
exports.unzip = unzip;
