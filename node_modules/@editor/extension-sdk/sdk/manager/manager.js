"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manager = void 0;
const path_1 = require("path");
const uninstall_1 = require("./uninstall/uninstall");
const upload_1 = require("./upload");
const manager_constant_1 = require("./manager.constant");
const source_1 = require("./api/source");
const resource_1 = require("./resource");
const download_1 = require("./download");
const extension_1 = require("./api/extension");
const provider_1 = require("./provider");
class Manager {
    constructor(managerConfig) {
        this.initManageProvider(managerConfig);
    }
    initManageProvider(managerConfig) {
        const { extensionPaths, domain } = managerConfig;
        const pathList = Array.isArray(extensionPaths) ? extensionPaths : [extensionPaths];
        provider_1.Provider.getInstance().extensionPaths = pathList.map((item) => (0, path_1.resolve)(item));
        if (domain)
            provider_1.Provider.getInstance().domain = domain;
    }
    getSourceList() {
        return (0, source_1.apiGetSourceList)();
    }
    getExtensionList(params) {
        return (0, extension_1.apiQueryExtensionList)(params);
    }
    getExtensionVersionList(params) {
        return (0, extension_1.apiQueryExtensionVersionList)(params);
    }
    getExtensionDetail(params) {
        return (0, extension_1.apiQueryExtensionDetailInfo)(params);
    }
    async scanLocalExtensions(lang) {
        const folderList = provider_1.Provider.getInstance().extensionPaths;
        if (folderList.length < 1)
            return [];
        return resource_1.Scanner.scanByPaths(folderList, lang);
    }
    queryLocalExtensionDetail(folderPath, lang) {
        return resource_1.Scanner.queryLocalExtensionDetail(folderPath, lang);
    }
    getDownloader(extensions, hooks) {
        extensions = Array.isArray(extensions) ? extensions : [extensions];
        if (extensions.some((item) => !item.installPath))
            throw new Error('Invalid install address');
        const pathList = provider_1.Provider.getInstance().extensionPaths;
        return new download_1.DownloaderManager(pathList, extensions, hooks);
    }
    async queryDepends(folderPathList) {
        folderPathList = Array.isArray(folderPathList) ? folderPathList : [folderPathList];
        if (folderPathList.length < 1)
            return [];
        const configPathList = folderPathList.map((item) => (0, path_1.resolve)(item, manager_constant_1.EXTENSION_CONFIG_FILE));
        return resource_1.Scanner.getDepends(configPathList);
    }
    getUploader(extensionFolder, hooks) {
        return new upload_1.Uploader(extensionFolder, hooks);
    }
    async uninstall(extensionName, targetFolders, uninstallHooks) {
        let folders = [];
        let hooks = uninstallHooks;
        if (targetFolders) {
            if (Array.isArray(targetFolders) || typeof targetFolders === 'string') {
                folders = Array.isArray(targetFolders) ? targetFolders : [targetFolders];
            }
            else {
                hooks = hooks ? hooks : targetFolders;
            }
        }
        await new uninstall_1.Uninstall(hooks).uninstall(extensionName, folders);
    }
    async cleanCache() {
        await download_1.cacheManage.clean();
    }
}
exports.Manager = Manager;
