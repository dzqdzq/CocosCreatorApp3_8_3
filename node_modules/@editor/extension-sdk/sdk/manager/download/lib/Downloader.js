"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Downloader = void 0;
const uuid_1 = require("uuid");
const axios_1 = require("axios");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const config_1 = require("../../config");
const CacheManager_1 = require("./CacheManager");
const download_helper_1 = require("../download.helper");
const utils_1 = require("../../utils");
const download_constant_1 = require("../download.constant");
class Downloader {
    downloadInfo;
    downloadHook;
    status = download_constant_1.EDownloadStatus.PREPARING;
    installPackageTempPath;
    cancelSource = utils_1.cancelToken.source();
    constructor(downloadInfo, downloadHook) {
        this.downloadInfo = downloadInfo;
        this.downloadHook = downloadHook;
    }
    getPkgInstallPath() {
        return (0, path_1.resolve)(this.downloadInfo.installPath, this.downloadInfo.name);
    }
    async getTempZipStorePath() {
        const tempFolder = (0, config_1.getTempFolder)();
        await (0, fs_extra_1.ensureDir)(tempFolder);
        return (0, path_1.join)(tempFolder, `${this.downloadInfo.name}@${this.downloadInfo.version}-${(0, uuid_1.v4)()}.zip`);
    }
    async prepareDownload() {
        if (this.status !== download_constant_1.EDownloadStatus.PREPARING)
            return;
        this.status = download_constant_1.EDownloadStatus.READY;
        if (this.downloadHook && this.downloadHook.beforePerDownload)
            await this.downloadHook.beforePerDownload(this.downloadInfo);
    }
    async unCompressExtension(zipPath) {
        if (this.status !== download_constant_1.EDownloadStatus.LOADED && (await (0, fs_extra_1.pathExists)(zipPath))) {
            await (0, fs_extra_1.remove)(zipPath);
            return;
        }
        this.status = download_constant_1.EDownloadStatus.COMPRESSING;
        const unzipDirPath = (0, path_1.dirname)(zipPath);
        const folderName = (0, path_1.basename)(zipPath, (0, path_1.extname)(zipPath));
        const tempPath = (0, path_1.join)(unzipDirPath, folderName);
        await (0, utils_1.unzip)(zipPath, tempPath);
        await (0, fs_extra_1.remove)(zipPath);
        if (this.downloadHook && this.downloadHook.perUnCompressed)
            await this.downloadHook.perUnCompressed({
                ...this.downloadInfo,
                tempPath,
                installPkgPath: this.getPkgInstallPath(),
            });
        return tempPath;
    }
    async downloadResourceByRequest() {
        const tempFilePath = await this.getTempZipStorePath();
        const buffer = await (0, download_helper_1.downloadByUrl)({
            url: this.downloadInfo.remote_addr,
            method: 'GET',
            cancelToken: this.cancelSource.token,
            onDownloadProgress: (event) => {
                if (this.downloadHook && this.downloadHook.downloadProgress)
                    this.downloadHook.downloadProgress(event.progress || (event.total ? event.loaded / event.total : 1), this.downloadInfo);
            },
        });
        await (0, fs_extra_1.writeFile)(tempFilePath, Buffer.from(buffer));
        await CacheManager_1.cacheManage.save(tempFilePath, {
            name: this.downloadInfo.name,
            version: this.downloadInfo.version,
        });
        return tempFilePath;
    }
    async downloadFile() {
        try {
            if (this.status !== download_constant_1.EDownloadStatus.READY)
                return;
            this.status = download_constant_1.EDownloadStatus.LOADING;
            const cachePath = await CacheManager_1.cacheManage.get({
                name: this.downloadInfo.name,
                version: this.downloadInfo.version,
            });
            let zipPath;
            if (this.downloadInfo.md5 && cachePath) {
                const cacheMd5 = await (0, utils_1.getFileMd5)(cachePath);
                if (this.downloadInfo.md5 === cacheMd5) {
                    zipPath = await this.getTempZipStorePath();
                    await (0, fs_extra_1.copy)(cachePath, zipPath);
                    if (this.downloadHook && this.downloadHook.downloadProgress)
                        this.downloadHook.downloadProgress(1, this.downloadInfo);
                }
                else {
                    zipPath = await this.downloadResourceByRequest();
                }
            }
            else {
                zipPath = await this.downloadResourceByRequest();
            }
            this.status = download_constant_1.EDownloadStatus.LOADED;
            if (this.downloadHook && this.downloadHook.perDownloaded)
                await this.downloadHook.perDownloaded({
                    ...this.downloadInfo,
                    tempPath: zipPath,
                    installPkgPath: this.getPkgInstallPath(),
                });
            await (0, fs_extra_1.ensureDir)(this.downloadInfo.installPath);
            this.installPackageTempPath = await this.unCompressExtension(zipPath);
        }
        catch (err) {
            if (err instanceof axios_1.CanceledError)
                return;
            this.status = download_constant_1.EDownloadStatus.FAILED;
            throw err;
        }
    }
    async removeExistsPkg(folderPath) {
        if (!(await (0, fs_extra_1.pathExists)(folderPath)))
            return;
        await (0, utils_1.recursiveChmod)(folderPath, '0700');
        await (0, fs_extra_1.remove)(folderPath);
    }
    async installExtension() {
        if (!this.installPackageTempPath)
            return;
        if (this.status !== download_constant_1.EDownloadStatus.COMPRESSING && (await (0, fs_extra_1.pathExists)(this.installPackageTempPath))) {
            await (0, fs_extra_1.remove)(this.installPackageTempPath);
            return;
        }
        this.status = download_constant_1.EDownloadStatus.INSTALLING;
        const tempPath = this.getPkgInstallPath();
        await this.removeExistsPkg(tempPath);
        await (0, fs_extra_1.move)(this.installPackageTempPath, tempPath, { overwrite: true });
        if (this.downloadHook && this.downloadHook.perInstalled)
            await this.downloadHook.perInstalled({
                ...this.downloadInfo,
                tempPath,
                installPkgPath: tempPath,
            });
    }
    async download() {
        if (!download_constant_1.EnableDownloadStatus.includes(this.status))
            return;
        this.status = download_constant_1.EDownloadStatus.PREPARING;
        await this.prepareDownload();
        await this.downloadFile();
        await this.installExtension();
        this.status = download_constant_1.EDownloadStatus.LOADED;
    }
    cancelDownload() {
        if (this.status === download_constant_1.EDownloadStatus.LOADING) {
            this.cancelSource.cancel();
        }
        this.status = download_constant_1.EDownloadStatus.CANCELED;
    }
}
exports.Downloader = Downloader;
