"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloaderManager = void 0;
const semver_1 = require("semver");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const resource_1 = require("./../../resource");
const CacheManager_1 = require("./CacheManager");
const download_helper_1 = require("./../download.helper");
const Downloader_1 = require("./Downloader");
const extension_1 = require("../../api/extension");
const manager_constant_1 = require("./../../manager.constant");
class DownloaderManager {
    extensionPaths;
    downloadInfos;
    downloadHooks;
    extensionTotal = 0;
    downloaderList;
    alreadyInstallExtensionList = [];
    constructor(extensionPaths, downloadInfos, downloadHooks) {
        this.extensionPaths = extensionPaths;
        this.downloadInfos = downloadInfos;
        this.downloadHooks = downloadHooks;
    }
    async prepareDownload() {
        this.downloaderList = new Map();
        for (let i = 0, len = this.downloadInfos.length; i < len; i++) {
            const { name, version, e, installPath } = this.downloadInfos[i];
            const temp = await (0, extension_1.apiQueryPackageDownloadInfo)({ name, version, e });
            if (!temp.name)
                throw new Error(`${this.downloadInfos[i].name} no such package available`);
            const tempHooks = {
                ...(this.downloadHooks || {}),
                downloadProgress: (progress, info) => {
                    this.updateSingleProgress(progress, info);
                },
                perInstalled: async (info) => {
                    await this.collectPackageData(info);
                },
            };
            const handle = new Downloader_1.Downloader({
                ...temp,
                installPath: (0, path_1.resolve)(installPath),
            }, tempHooks);
            this.downloaderList && this.downloaderList.set(temp.name, { loader: handle, progress: 0 });
        }
        this.extensionTotal = this.downloaderList ? this.downloaderList.size : 0;
    }
    updateSingleProgress(progress, info) {
        if (!this.downloaderList)
            return;
        this.downloaderList.get(info.name).progress = progress;
        if (this.downloadHooks && this.downloadHooks.downloadProgress) {
            const sum = Array.from(this.downloaderList.values()).reduce((total, per) => {
                total += per.progress;
                return total;
            }, 0);
            this.downloadHooks.downloadProgress(sum / this.extensionTotal);
        }
    }
    async collectPackageData(info) {
        if (this.downloadHooks && this.downloadHooks.perInstalled)
            await this.downloadHooks.perInstalled(info);
        this.alreadyInstallExtensionList.push(info);
    }
    async fillPackageData(folderPath, configData) {
        let pkg = await (0, download_helper_1.findUpConfig)(folderPath);
        let packageJson = {};
        if (!pkg) {
            pkg = (0, path_1.join)(folderPath, manager_constant_1.EXTENSION_CONFIG_FILE);
            await (0, fs_extra_1.ensureFile)(pkg);
        }
        else {
            packageJson = await (0, fs_extra_1.readJSON)(pkg);
        }
        const creatorConfig = Reflect.get(packageJson, manager_constant_1.EDITOR_FIELD) || {};
        const registry = Reflect.get(creatorConfig, 'registry') || {};
        const remote = Reflect.get(registry, 'remote') || {};
        const dependencies = Reflect.get(creatorConfig, 'dependencies') || {};
        this.alreadyInstallExtensionList.forEach((item) => {
            Reflect.set(dependencies, item.name, item.version);
        });
        Reflect.set(registry, 'remote', remote);
        Reflect.set(creatorConfig, 'registry', registry);
        Reflect.set(creatorConfig, 'dependencies', dependencies);
        Reflect.set(packageJson, manager_constant_1.EDITOR_FIELD, creatorConfig);
        await (0, fs_extra_1.writeJSON)(pkg, packageJson, { spaces: 2 });
    }
    async analysisExtensionDepends(configList) {
        let limitList = [];
        const depends = await resource_1.Scanner.getDepends(configList);
        if (depends.length > 0 && this.extensionPaths.length > 0) {
            const localExtensions = await resource_1.Scanner.scanByPaths(this.extensionPaths);
            const localExtensionsMap = localExtensions.reduce((total, per) => {
                total.set(per.name, per);
                return total;
            }, new Map());
            limitList = depends.filter((item) => {
                const temp = localExtensionsMap.get(item.name);
                return !temp || (0, semver_1.neq)(temp.version, item.version);
            });
        }
        if (this.downloadHooks && this.downloadHooks.downloaded)
            this.downloadHooks.downloaded(limitList);
    }
    async refreshPackageData() {
        if (this.alreadyInstallExtensionList.length < 1)
            return;
        const pathCollect = {};
        this.alreadyInstallExtensionList.forEach((item) => {
            pathCollect[item.installPath] = pathCollect[item.installPath] || [];
            pathCollect[item.installPath].push(item);
        });
        await Promise.all(Object.keys(pathCollect).map((folderPath) => this.fillPackageData(folderPath, pathCollect[folderPath])));
        const paths = this.alreadyInstallExtensionList.map((item) => (0, path_1.join)(item.tempPath, manager_constant_1.EXTENSION_CONFIG_FILE));
        await this.analysisExtensionDepends(paths);
        this.alreadyInstallExtensionList = [];
    }
    dispatchError(error) {
        const currentError = typeof error === 'string' ? new Error(error) : error;
        if (this.downloadHooks && this.downloadHooks.error)
            return this.downloadHooks.error(currentError);
        throw currentError;
    }
    async download() {
        try {
            await this.prepareDownload();
            if (this.downloadInfos.length < 1 || !this.downloaderList)
                return;
            await Promise.all(Array.from(this.downloaderList.values()).map((item) => item.loader.download()));
            await this.refreshPackageData();
            CacheManager_1.cacheManage.cleanTempFile();
        }
        catch (err) {
            this.dispatchError(err);
        }
    }
    async cancelDownload() {
        try {
            if (!this.downloaderList)
                return;
            this.downloaderList.forEach((item) => item.loader.cancelDownload());
            this.downloaderList = null;
            await this.refreshPackageData();
        }
        catch (err) {
            this.dispatchError(err);
        }
    }
}
exports.DownloaderManager = DownloaderManager;
