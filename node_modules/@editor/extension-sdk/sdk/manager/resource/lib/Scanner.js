"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scanner = void 0;
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const provider_1 = require("./../../provider");
const common_1 = require("./../../utils/common");
const manager_constant_1 = require("./../../manager.constant");
const resource_helper_1 = require("../resource.helper");
const manager_constant_2 = require("../../manager.constant");
const semver_1 = require("semver");
class Scanner {
    static formatPkgName(name) {
        return name.toLowerCase();
    }
    static getConfigPath(dirPath) {
        return (0, resource_helper_1.recursive)(dirPath, manager_constant_2.EXTENSION_CONFIG_FILE, { excludeFolder: manager_constant_2.DEFAULT_IGNORE_LIST });
    }
    static async queryLangPkgByKey(configJson, pkgPath, lang) {
        const { name, description = '' } = configJson;
        if (!lang)
            return description;
        const reg = new RegExp(`^i18n:${name}\\.(\\w+)`, 'i');
        if (!reg.test(description))
            return description;
        const list = reg.exec(description);
        const langJs = (0, path_1.join)((0, path_1.dirname)(pkgPath), 'i18n', `${lang}.js`);
        if (list && list[1] && (await (0, fs_extra_1.pathExists)(langJs))) {
            const result = await Promise.resolve().then(() => __importStar(require(langJs)));
            const langList = list[1].split('.');
            let langStr = result;
            for (let i = 0, len = langList.length; i < len; i++)
                langStr = langStr?.[langList[i]];
            if (langStr && typeof langStr === 'string')
                return langStr;
        }
        return description;
    }
    static async getEditorConfig(configPath, lang) {
        const configJson = await (0, fs_extra_1.readJSON)(configPath);
        if (!configJson.name && !configJson.version)
            return;
        const packageFolder = (0, path_1.dirname)(configPath);
        const icon_url = await (0, resource_helper_1.getExtensionCover)(packageFolder);
        const description = await Scanner.queryLangPkgByKey(configJson, configPath, lang);
        return {
            name: Scanner.formatPkgName(configJson.name),
            version: configJson.version,
            description,
            editor: configJson.editor || '',
            [manager_constant_2.EDITOR_FIELD]: Reflect.get(configJson, manager_constant_2.EDITOR_FIELD) || {},
            extension_path: packageFolder,
            icon_url,
        };
    }
    static async scanFolderByPath(dirPath, lang) {
        const realPath = (0, path_1.resolve)(dirPath);
        const configPathList = await this.getConfigPath(realPath);
        if (configPathList.length < 1)
            return [];
        const configJsonList = await Promise.all(configPathList.map((configPath) => Scanner.getEditorConfig(configPath, lang)));
        return configJsonList.filter((item) => item !== undefined);
    }
    static async scanByPaths(dirPaths, lang) {
        if (!dirPaths)
            throw new Error(`please pass in the paths you want to scan`);
        const realPaths = Array.isArray(dirPaths) ? dirPaths : [dirPaths];
        const uniquePaths = Array.from(new Set(realPaths.map((item) => (0, common_1.formatPath)(item))));
        const list = await Promise.all(uniquePaths.map((item) => Scanner.scanFolderByPath(item, lang)));
        return list.flat();
    }
    static async queryLocalExtensionDetail(folderPath, lang) {
        const configPath = (0, path_1.resolve)(folderPath, manager_constant_2.EXTENSION_CONFIG_FILE);
        if (!(await (0, fs_extra_1.pathExists)(configPath)))
            throw new Error(`${folderPath}  is not a valid cocos extension`);
        const configJson = await (0, fs_extra_1.readJSON)(configPath);
        const fileList = await (0, fs_extra_1.readdir)(folderPath, { withFileTypes: true });
        const detailReg = lang ? new RegExp(`^readme(\\.${lang})\\.md$`, 'i') : /^readme\.md$/i;
        const size = await (0, resource_helper_1.queryFolderSize)(folderPath);
        const detailInfo = {
            name: Scanner.formatPkgName(configJson.name),
            version: configJson.version,
            author: configJson.author || '',
            editor_limit: configJson[manager_constant_2.EDITOR_LIMIT] || '',
            icon_url: '',
            detail: '',
            size,
        };
        for (let i = 0, len = fileList.length; i < len; i++) {
            const temp = fileList[i];
            if (temp.isDirectory())
                continue;
            if (manager_constant_1.EXTENSION_COVER_REG.test(temp.name)) {
                detailInfo.icon_url = (0, path_1.resolve)(folderPath, temp.name);
            }
            else if (detailReg.test(temp.name)) {
                const buffer = await (0, fs_extra_1.readFile)((0, path_1.resolve)(folderPath, temp.name));
                detailInfo.detail = buffer.toString();
            }
        }
        return detailInfo;
    }
    static async analysisDependsByConfigPath(configPath, extensionsConfig, analysisCache = {}) {
        const dependsInfoList = [];
        if (!(await (0, fs_extra_1.pathExists)(configPath)))
            return dependsInfoList;
        const packageJson = await (0, fs_extra_1.readJSON)(configPath);
        Reflect.set(analysisCache, packageJson.name, packageJson.version);
        const creatorJson = Reflect.get(packageJson, manager_constant_2.EDITOR_FIELD);
        if (!creatorJson)
            return dependsInfoList;
        const depends = Reflect.get(creatorJson, 'dependencies');
        if (!depends)
            return dependsInfoList;
        const dependKeys = Object.keys(depends);
        for (let i = 0, len = dependKeys.length; i < len; i++) {
            const sep = resource_helper_1.fileNameReg.exec(dependKeys[i]);
            if (!sep)
                continue;
            const [, , tempRemote, pkgName] = sep;
            const pkgVersion = Reflect.get(depends, dependKeys[i]);
            dependsInfoList.push({
                name: pkgName,
                version: pkgVersion,
                source: tempRemote || '',
            });
            if (Reflect.has(analysisCache, pkgName) && (0, semver_1.eq)(analysisCache[pkgName], pkgVersion))
                continue;
            const subDepends = extensionsConfig.find((item) => item.name === pkgName && (0, semver_1.eq)(item.version, Reflect.get(depends, dependKeys[i])));
            if (subDepends) {
                const subExtensions = await Scanner.analysisDependsByConfigPath((0, path_1.join)(subDepends.extension_path, manager_constant_2.EXTENSION_CONFIG_FILE), extensionsConfig, analysisCache);
                subExtensions && dependsInfoList.push(...subExtensions);
            }
        }
        return dependsInfoList;
    }
    static async getDepends(configPathList) {
        const pathList = Array.isArray(configPathList) ? configPathList : [configPathList];
        if (pathList.length < 1)
            return [];
        const currentLocalExtensions = await Scanner.scanByPaths(provider_1.Provider.getInstance().extensionPaths);
        const dependsCollect = await Promise.all(pathList.map((item) => Scanner.analysisDependsByConfigPath(item, currentLocalExtensions)));
        return dependsCollect.reduce((total, per) => {
            if (!per)
                return total;
            total.push(...per);
            return total;
        }, []);
    }
}
exports.Scanner = Scanner;
