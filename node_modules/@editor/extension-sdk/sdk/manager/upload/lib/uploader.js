"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uploader = void 0;
const form_data_1 = __importDefault(require("form-data"));
const semver_1 = require("semver");
const path_1 = require("path");
const axios_1 = require("axios");
const fs_extra_1 = require("fs-extra");
const config_1 = require("../../config");
const utils_1 = require("../../utils");
const uploader_constant_1 = require("../uploader.constant");
const publish_1 = require("../../api/publish");
const manager_constant_1 = require("../../manager.constant");
class Uploader {
    packagePath;
    uploadHooks;
    status = uploader_constant_1.EUploadStatus.PREPARING;
    packageJson;
    cancelSource = utils_1.cancelToken.source();
    constructor(packagePath, uploadHooks) {
        this.packagePath = packagePath;
        this.uploadHooks = uploadHooks;
        this.packagePath = (0, path_1.resolve)(this.packagePath);
    }
    async validatePackage() {
        const packageConfig = (0, path_1.join)(this.packagePath, manager_constant_1.EXTENSION_CONFIG_FILE);
        if (!(await (0, fs_extra_1.pathExists)(packageConfig)))
            throw new Error(`${this.packagePath} is not a valid cocos extension`);
        this.packageJson = await (0, fs_extra_1.readJSON)(packageConfig);
        if (!Reflect.has(this.packageJson, 'name') || !Reflect.has(this.packageJson, 'version'))
            throw new Error(`${this.packagePath} require name and version`);
        if (this.packageJson.name.toLowerCase() !== this.packageJson.name)
            throw new Error(`${this.packagePath} require lowercase package name`);
        const editorLimit = Reflect.get(this.packageJson, manager_constant_1.EDITOR_LIMIT) || this.packageJson[manager_constant_1.EDITOR_FIELD]?.version;
        if (editorLimit) {
            if (editorLimit.indexOf('-') > -1) {
                const [front, end] = editorLimit.split('-');
                if (!(0, semver_1.valid)((0, semver_1.coerce)(front)) || !(0, semver_1.valid)((0, semver_1.coerce)(end)))
                    throw new Error(`package in ${this.packagePath} require a valid editor version`);
            }
            else if (!(0, semver_1.valid)((0, semver_1.coerce)(editorLimit))) {
                throw new Error(`package in ${this.packagePath} require a valid editor version`);
            }
        }
        this.status = uploader_constant_1.EUploadStatus.READY;
        if (this.uploadHooks && this.uploadHooks.beforeUpload)
            await this.uploadHooks.beforeUpload(this.packageJson);
    }
    async compressExtension() {
        const tempFolder = (0, config_1.getTempFolder)();
        await (0, fs_extra_1.ensureDir)(tempFolder);
        if (this.status !== uploader_constant_1.EUploadStatus.READY)
            return;
        this.status = uploader_constant_1.EUploadStatus.COMPRESSING;
        const zipPath = (0, path_1.join)(tempFolder, `${this.packageJson.name}@${this.packageJson.version}.zip`);
        await (0, utils_1.zip)(this.packagePath, zipPath);
        this.status = uploader_constant_1.EUploadStatus.COMPRESSED;
        if (this.uploadHooks && this.uploadHooks.compressed)
            await this.uploadHooks.compressed(zipPath);
        return zipPath;
    }
    async createFormData(filePath) {
        const buffer = await (0, fs_extra_1.readFile)(filePath);
        const formData = new form_data_1.default();
        formData.append('file', buffer, {
            filename: (0, path_1.basename)(filePath),
            filepath: filePath,
        });
        return formData;
    }
    async publishExtension(zipPath) {
        const pathExist = zipPath && (await (0, fs_extra_1.pathExists)(zipPath));
        if (this.status !== uploader_constant_1.EUploadStatus.COMPRESSED || !pathExist) {
            if (pathExist)
                await (0, fs_extra_1.remove)(zipPath);
            return;
        }
        try {
            const form = await this.createFormData(zipPath);
            this.status = uploader_constant_1.EUploadStatus.UPLOADING;
            await (0, publish_1.apiPublishExtension)(form, {
                cancelToken: this.cancelSource.token,
                onUploadProgress: (progress) => {
                    if (this.uploadHooks && this.uploadHooks.uploadProgress) {
                        const total = typeof FormData !== 'undefined'
                            ? progress.total || 1
                            : form.getLengthSync();
                        this.uploadHooks.uploadProgress(progress.loaded / total, this.packagePath);
                    }
                },
            });
            this.status = uploader_constant_1.EUploadStatus.UPLOADED;
            if (this.uploadHooks && this.uploadHooks.uploaded)
                this.uploadHooks.uploaded();
        }
        catch (err) {
            if (err instanceof axios_1.CanceledError)
                return;
            this.status = uploader_constant_1.EUploadStatus.FAILED;
            throw err;
        }
        finally {
            if (pathExist)
                await (0, fs_extra_1.remove)(zipPath);
            this.status = uploader_constant_1.EUploadStatus.COMPLETE;
        }
    }
    async upload() {
        await this.validatePackage();
        const zipPath = await this.compressExtension();
        await this.publishExtension(zipPath);
    }
    async cancelUpload() {
        if (this.status === uploader_constant_1.EUploadStatus.UPLOADING) {
            this.cancelSource.cancel();
        }
        this.status = uploader_constant_1.EUploadStatus.CANCELED;
    }
}
exports.Uploader = Uploader;
