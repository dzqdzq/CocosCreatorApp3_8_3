"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uninstall = void 0;
const fs_extra_1 = require("fs-extra");
const utils_1 = require("./../utils");
const resource_1 = require("./../resource");
const provider_1 = require("./../provider");
const download_helper_1 = require("./../download/download.helper");
const manager_constant_1 = require("./../manager.constant");
class Uninstall {
    hooks;
    extensionName;
    extensionFolder;
    constructor(hooks) {
        this.hooks = hooks;
    }
    async validateExtensionsFolder() {
        const folders = new Set();
        const rootFolderList = this.extensionFolder || provider_1.Provider.getInstance().extensionPaths;
        for (let i = 0, len = rootFolderList.length; i < len; i++) {
            const temp = rootFolderList[i];
            if ((await (0, fs_extra_1.pathExists)(temp)) && (await (0, fs_extra_1.stat)(temp)).isDirectory())
                folders.add((0, utils_1.formatPath)(temp));
        }
        this.extensionFolder = Array.from(folders);
    }
    async chmodAndRemove(extensionPath) {
        if (!(await (0, fs_extra_1.pathExists)(extensionPath)))
            return;
        await (0, utils_1.recursiveChmod)(extensionPath, '0700');
        await (0, fs_extra_1.remove)(extensionPath);
    }
    async scanExtensions(folderPath) {
        const localExtensions = await resource_1.Scanner.scanByPaths(folderPath);
        const uninstallPath = [];
        localExtensions.forEach((item) => {
            if (item.name === this.extensionName)
                uninstallPath.push((0, utils_1.formatPath)(item.extension_path));
        });
        if (uninstallPath.length > 0)
            await Promise.all(uninstallPath.map((item) => this.chmodAndRemove(item)));
        const physicalPathConfig = await (0, download_helper_1.findUpConfig)(folderPath);
        if (physicalPathConfig)
            await this.refreshPackage(physicalPathConfig);
    }
    async refreshPackage(packagePath) {
        const packageJson = await (0, fs_extra_1.readJSON)(packagePath);
        const creatorConfig = Reflect.get(packageJson, manager_constant_1.EDITOR_FIELD);
        if (creatorConfig) {
            const registry = Reflect.get(creatorConfig, 'registry');
            if (registry && Reflect.has(registry, 'remote')) {
                Reflect.deleteProperty(Reflect.get(registry, 'remote'), this.extensionName);
            }
            const dependencies = Reflect.get(creatorConfig, 'dependencies');
            if (dependencies)
                Reflect.deleteProperty(dependencies, this.extensionName);
            Reflect.set(packageJson, manager_constant_1.EDITOR_FIELD, creatorConfig);
            await (0, fs_extra_1.writeJSON)(packagePath, packageJson, { spaces: 2 });
        }
    }
    refreshProgress(process) {
        if (this.hooks && this.hooks.uninstallProgress)
            this.hooks.uninstallProgress(process);
    }
    async uninstall(extensionName, targetFolders) {
        if (!extensionName)
            return;
        this.extensionName = extensionName;
        if (targetFolders && targetFolders.length > 0)
            this.extensionFolder = targetFolders;
        if (this.hooks && this.hooks.beforeUninstall)
            await this.hooks.beforeUninstall();
        await this.validateExtensionsFolder();
        this.refreshProgress(1 / 5);
        if (this.extensionFolder.length < 1) {
            this.refreshProgress(5 / 5);
            return;
        }
        await Promise.all(this.extensionFolder.map((item) => this.scanExtensions(item)));
        this.refreshProgress(5 / 5);
        if (this.hooks && this.hooks.uninstalled)
            await this.hooks.uninstalled();
    }
}
exports.Uninstall = Uninstall;
