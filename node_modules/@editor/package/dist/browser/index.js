"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PackageManager=void 0;const package_1=require("./package"),ipc=require("@base/electron-base-ipc"),events_1=require("events"),pkg=require("../../package.json"),ipcFlag=`${pkg.name}@${pkg.version}`;class PackageManager extends events_1.EventEmitter{constructor(){super(...arguments),this.path2pkg={},this.name2pkg={}}contributionTo(e,t){if(t.info.contributions)for(let n in t.info.contributions){const r=this.name2pkg[n];if(r)try{const o=t.info.contributions[n];r.contributionTo(e,t,o)}catch(e){console.error(`[${t.name}] Data from "${n}" cannot be accepted.`),console.error(e)}}}contributionFrom(e){for(let t in this.path2pkg){const n=this.path2pkg[t],r=e.name;if(n.json&&n.json.contributions&&n.json.contributions[r])try{e.contributionTo("register",n.generateInfo(),n.json.contributions[r]),n.enabled&&e.contributionTo("enable",n.generateInfo(),n.json.contributions[r])}catch(t){console.error(`[${e.name}] Data from "${n.name}" cannot be accepted.`),console.error(t)}}}register(e){if(this.path2pkg[e])return this.path2pkg[e].generateInfo();const t=new package_1.Package(e);this.path2pkg[e]=t,t.execHook("register");const n=t.generateInfo();return this.contributionTo("register",n),this.emit("register",n),ipc.broadcast(`${ipcFlag}:emit`,"register",n),n}unregister(e){const t=this.path2pkg[e];if(!t)return;t.enabled&&this.disable(e),delete this.path2pkg[e];const n=t.generateInfo();return this.contributionTo("unregister",n),this.emit("unregister",n),ipc.broadcast(`${ipcFlag}:emit`,"unregister",n),t.execHook("unregister"),n}async enable(e){const t=this.path2pkg[e];if(!t)return;if(this.name2pkg[t.name])return;if(t.enabled)return;if(this.emit("before-enable",t.generateInfo()),await t.enable(),!t.enabled){return t.generateInfo()}this.name2pkg[t.name]=t;const n=t.generateInfo();return this.contributionTo("enable",n),this.contributionFrom(t),this.emit("enable",n),ipc.broadcast(`${ipcFlag}:emit`,"enable",n),n}async disable(e){const t=this.path2pkg[e];if(!t)return;if(this.emit("before-disable",t.generateInfo()),!t.enabled)return;try{await t.disable()}catch(e){if(console.error(e),!t.enabled){return t.generateInfo()}}delete this.name2pkg[t.name];const n=t.generateInfo();return this.contributionTo("disable",n),this.contributionFrom(t),this.emit("disable",n),ipc.broadcast(`${ipcFlag}:emit`,"disable",n),n}find(e){return this.name2pkg[e]||null}exec(e,t,...n){return ipc.emit(`${ipcFlag}:exec`,e,t,...n)}execSync(e,t,...n){return ipc.emit(`${ipcFlag}:exec`,e,t,...n)}execWithoutReply(e,t,...n){ipc.emit(`${ipcFlag}:exec-without-reply`,e,t,...n)}reload(e){return ipc.emit(`${ipcFlag}:reload`,e)}debugRely(e){package_1.Package.debugRely(e)}}exports.PackageManager=PackageManager,module.exports=new PackageManager,ipc.on(`${ipcFlag}:exec`,async(e,t,n,...r)=>{let o,i=module.exports.find(t);if(!i){const n=new Error(`The '${t}' plug-in does not exist.`);throw e.reply(n),n}try{o=await i.exec(n,...r)}catch(t){if(t instanceof Error||(t=new Error("The exception needs to be 'Error'\n  You have thrown a normal data in a message.\n  The exception needs to be an error object.")),e.needCallback)return e.reply(t),o;throw t}return e.reply(null,o),o}),ipc.on(`${ipcFlag}:exec-without-reply`,async(e,t,n,...r)=>{let o=module.exports.find(t);if(!o){const n=new Error(`The '${t}' plug-in does not exist.`);throw e.reply(n),n}try{await o.execWithoutReply(n,...r)}catch(e){throw e instanceof Error||(e=new Error("The exception needs to be 'Error'\n  You have thrown a normal data in a message.\n  The exception needs to be an error object.")),e}}),ipc.on(`${ipcFlag}:reload`,async(e,t)=>{let n=module.exports.find(t);n?(await n.unload(),await n.load(),e.reply(null)):e.reply(new Error(`The '${t}' plug-in does not exist.`))});