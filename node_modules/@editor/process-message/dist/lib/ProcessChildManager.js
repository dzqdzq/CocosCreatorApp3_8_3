"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessChildManager = void 0;
const constants_1 = require("./constants");
class ProcessChildManager {
    constructor(process) {
        this.process = process;
        this.registerEventList = new Map();
        this._messageTriggerHandle = this._triggerMessageEvent.bind(this);
        this._cleanUpAndExitHandle = this._cleanUpAndExit.bind(this);
        this._initProcess();
    }
    _triggerMessageEvent(msg) {
        const channel = Reflect.get(msg, 'channel');
        if (!channel || !constants_1.ProcessRegisterHandleReg.test(channel))
            return;
        const handle = channel.replace(constants_1.ProcessRegisterHandleReg, '$1');
        const fnList = this.registerEventList.get(handle);
        if (!fnList || fnList.size < 1)
            return;
        const { source = '', target } = msg;
        fnList.forEach((item) => item({ source, target }));
    }
    /**
     * 取消订阅
     */
    _cleanUpAndExit() {
        this.process.off('message', this._messageTriggerHandle);
        this.process.off('close', this._cleanUpAndExitHandle);
        this.process.off('error', this._cleanUpAndExitHandle);
        this.process.off('exit', this._cleanUpAndExitHandle);
        this.registerEventList.clear();
    }
    // 初始化进程
    _initProcess() {
        // 订阅消息
        this.process.on('message', this._messageTriggerHandle);
        this.process.on('close', this._cleanUpAndExitHandle);
        this.process.on('error', this._cleanUpAndExitHandle);
        this.process.on('exit', this._cleanUpAndExitHandle);
    }
    // 监听主进程的消息
    onMainProcess(handle, fn) {
        if (!this.registerEventList.has(handle))
            this.registerEventList.set(handle, new Set());
        const fnList = this.registerEventList.get(handle);
        if (fnList.has(fn))
            return;
        fnList.add(fn);
    }
    // 取消主进程的指定消息监听
    offMainProcess(handle, fn) {
        if (!handle) {
            this.registerEventList.clear();
            return;
        }
        const fnList = this.registerEventList.get(handle);
        if (!fn) {
            fnList && fnList.clear();
            return;
        }
        if (!fnList || !fnList.has(fn))
            return;
        fnList.delete(fn);
    }
    // 发送消息到主进程
    sendToMain(handle, msg) {
        if (!msg)
            throw new Error('msg is not defined');
        this.process.connected &&
            this.process.send(Object.assign({ channel: `${constants_1.ProcessRegisterHandle}-${handle}` }, msg));
    }
}
exports.ProcessChildManager = ProcessChildManager;
