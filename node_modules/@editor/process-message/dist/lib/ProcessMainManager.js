"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessMainManager = void 0;
const constants_1 = require("./constants");
class ProcessMainManager {
    constructor(process) {
        this.process = process;
        this.registerEventList = new Map();
        this._messageTriggerHandle = this._triggerMessageEvent.bind(this);
        this._cleanUpAndExitHandle = this._cleanUpAndExit.bind(this);
        this._initProcess();
    }
    _triggerMessageEvent(msg) {
        const channel = Reflect.get(msg, 'channel');
        if (!channel || !constants_1.ProcessRegisterHandleReg.test(channel))
            return;
        const handle = channel.replace(constants_1.ProcessRegisterHandleReg, '$1');
        const fnList = this.registerEventList.get(handle);
        if (!fnList || fnList.size < 1)
            return;
        const { source = '', target } = msg;
        fnList.forEach((item) => item({ source, target }));
    }
    _cleanUpAndExit() {
        this.process.off('message', this._messageTriggerHandle);
        process.off('exit', this._cleanUpAndExitHandle);
        process.off('uncaughtException', this._cleanUpAndExitHandle);
        process.off('unhandledRejection', this._cleanUpAndExitHandle);
        this.registerEventList.clear();
    }
    // 初始化进程
    _initProcess() {
        // 订阅消息
        this.process.on('message', this._messageTriggerHandle);
        process.on('exit', this._cleanUpAndExitHandle);
        process.on('uncaughtException', this._cleanUpAndExitHandle);
        process.on('unhandledRejection', this._cleanUpAndExitHandle);
    }
    // 监听子进程发送过来的消息
    onChildProcess(handle, fn) {
        if (!this.registerEventList.has(handle))
            this.registerEventList.set(handle, new Set());
        const fnList = this.registerEventList.get(handle);
        if (fnList.has(fn))
            return;
        fnList.add(fn);
    }
    // 取消子进程监听消息
    offChildProcess(handle, fn) {
        if (!handle) {
            this.registerEventList.clear();
            return;
        }
        const fnList = this.registerEventList.get(handle);
        if (!fn) {
            fnList && fnList.clear();
            return;
        }
        if (!fnList || !fnList.has(fn))
            return;
        fnList.delete(fn);
    }
    // 发送消息到子进程
    sendToChild(handle, msg) {
        if (!this.process.send || !msg)
            throw new Error('send message failed');
        this.process.connected &&
            this.process.send(Object.assign({ channel: `${constants_1.ProcessRegisterHandle}-${handle}` }, msg));
    }
}
exports.ProcessMainManager = ProcessMainManager;
