"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcatBundler = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const cache_transformed_1 = require("./cache-transformed");
const concat_with_sourcemaps_1 = __importDefault(require("concat-with-sourcemaps"));
const bundler_1 = require("./bundler");
const indexed_source_map_1 = require("./indexed-source-map");
const url_1 = require("url");
const relateurl_1 = __importDefault(require("relateurl"));
class RegularConcat {
    constructor({ file, separator, }) {
        this._concat = new concat_with_sourcemaps_1.default(true, file, separator);
    }
    get code() {
        return this._concat.content.toString('utf8');
    }
    get sourceMap() {
        return this._concat.sourceMap.toString();
    }
    add(code, map) {
        this._concat.add(null, code, map);
    }
}
class ConcatBundler extends cache_transformed_1.CacheTransformed {
    constructor(options) {
        super(options);
        this.targetMode = bundler_1.TransformTargetModule.systemJsNamed;
        this.targetMode = (options.format === 'commonjs') ?
            bundler_1.TransformTargetModule.commonJs : bundler_1.TransformTargetModule.systemJsNamed;
    }
    getModuleId(path) {
        return this._getModuleIdOfOutFile(this.getRelativeOutputPath(path));
    }
    getFinalUrl(path) {
        return this.getModuleId(path);
    }
    async build({ outDir, usedInElectron509, sourceRoot, inlineSourceMap, indexedSourceMap: useIndexedSourceMap, }) {
        const outFile = path_1.default.join(outDir, 'index.js');
        const concat = new (useIndexedSourceMap ? indexed_source_map_1.IndexedSourceMap : RegularConcat)({
            file: outFile,
            separator: '\n',
        });
        const outURL = (0, url_1.pathToFileURL)(outFile);
        if (this.targetMode === bundler_1.TransformTargetModule.commonJs) {
            await this._concatToCommonJs(concat, outURL);
        }
        else {
            await this._concatToSystemJs(concat, outURL);
        }
        let sourceMapPromise;
        if (inlineSourceMap) {
            concat.add(`//# sourceMappingURL=data:application/json;base64,${Buffer.from(concat.sourceMap).toString('base64')}`);
        }
        else {
            const sourceMapFile = `${path_1.default.basename(outFile)}.map`;
            const sourceMapFileFullPath = path_1.default.join(path_1.default.dirname(outFile), sourceMapFile);
            const sourceMappingUrl = usedInElectron509 ?
                (0, url_1.pathToFileURL)(sourceMapFileFullPath).href :
                sourceMapFile;
            concat.add(`//# sourceMappingURL=${sourceMappingUrl}`);
            const sourceMapText = concat.sourceMap;
            // const hack509 = (sourceMap: any) => {
            //     // Electron 5.0.9 require path
            //     // sourceMap.file = outFile;
            //     // Do not include sources in source map
            //     delete sourceMap.sourcesContent;
            //     return sourceMap;
            // };
            // const sourceMapText = usedInElectron509
            //     ? JSON.stringify(hack509(JSON.parse(concat.sourceMap)), undefined, 2)
            //     : JSON.stringify(Object.assign({ sourceRoot: `${pathToFileURL(sourceRoot)}/` }, JSON.parse(concat.sourceMap)));
            sourceMapPromise = fs_extra_1.default.outputFile(sourceMapFileFullPath, sourceMapText, { encoding: 'utf8' });
        }
        await Promise.all([
            fs_extra_1.default.outputFile(outFile, concat.code, { encoding: 'utf8' }),
            sourceMapPromise,
        ]);
    }
    async _concatToCommonJs(concat, outURL) {
        wrapBigIIFEPre();
        await this.forEachModule(async (path, code, map, mapURL) => {
            if (map && mapURL) {
                relocateSourceFilePaths(map, mapURL, outURL);
            }
            wrapIIFEPre(this._getModuleIdOfOutFile(path));
            concat.add(/*path, */ code, map);
            wrapIIFEPost();
        });
        wrapBigIIFEPost();
        function wrapBigIIFEPre() {
            concat.add(`\
module.exports = (function(){ return {
`);
        }
        function wrapBigIIFEPost() {
            concat.add(`\
}; })();`);
        }
        function wrapIIFEPre(path) {
            concat.add(`['${path}']: (function(exports, require){`);
        }
        function wrapIIFEPost() {
            concat.add(`}),`);
        }
    }
    async _concatToSystemJs(concat, outURL) {
        await this.forEachModule(async (path, code, map, mapURL) => {
            if (map && mapURL) {
                relocateSourceFilePaths(map, mapURL, outURL);
            }
            concat.add(/*path, */ code, map);
        });
    }
    _getModuleIdOfOutFile(relativeOutPath) {
        const parts = relativeOutPath.split(/[\\/]/g);
        return `q-bundled:///${parts.map((part) => encodeURIComponent(part)).join('/')}`;
    }
}
exports.ConcatBundler = ConcatBundler;
function relocateSourceFilePaths(sourceMap, sourceMapURL, newSourceMapURL) {
    if (!sourceMap.sources) {
        return;
    }
    const sources = sourceMap.sources;
    const resolveRelative = new relateurl_1.default(newSourceMapURL.href);
    sources.map((source, iSource) => {
        const sourceURL = new URL(source, sourceMapURL);
        const resolved = resolveRelative.relate(sourceURL.href);
        sources[iSource] = resolved;
    });
    return sourceMap;
}
//# sourceMappingURL=concat-bundler.js.map