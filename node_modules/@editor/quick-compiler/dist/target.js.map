{"version":3,"file":"target.js","sourceRoot":"","sources":["../src/target.ts"],"names":[],"mappings":";;;AAGA,yCAA8E;AAmBvE,KAAK,UAAU,kBAAkB,CAAC,EACrC,OAAO,EACP,OAAO,EACP,YAAY,EACZ,OAAO,EACP,OAAO,GAOV;IACG,MAAM,mBAAmB,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;IAE5E,MAAM,YAAY,GAAiB,IAAI,GAAG,EAAE,CAAC;IAC7C,MAAM,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAC,GAAG,CAAC,KAAK,EAAE,WAAoB,EAAE,EAAE;QACrE,MAAM,aAAa,GAAG,GAAG,EAAE,CAAC,OAAO,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QAEnE,IAAI,CAAC,IAAA,2BAAgB,EAAC,WAAW,CAAC,EAAE;YAChC,IAAI,CAAC,CAAC,MAAM,OAAO,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,EAAE;gBAC1C,aAAa,EAAE,CAAC;gBAChB,OAAO;aACV;YAED,MAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACjD,MAAM,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC;YAClC,IAAI,CAAC,CAAC,WAAW,IAAI,YAAY,CAAC,KAAK,CAAC;gBACpC,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,QAAQ,KAAK,QAAQ;gBACrD,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;gBAC9G,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;gBAC9B,aAAa,EAAE,CAAC;gBAChB,OAAO;aACV;SACJ;QAED,IAAI,CAAC,CAAC,MAAM,OAAO,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,EAAE;YAC9C,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;YAC9B,aAAa,EAAE,CAAC;YAChB,OAAO;SACV;IACL,CAAC,CAAC,CAAC,CAAC;IACJ,OAAO,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;AACpC,CAAC;AA3CD,gDA2CC","sourcesContent":["import ps from 'path';\nimport type { IBundler } from './bundler';\nimport type { FileRecord } from './file-record';\nimport { decodeRegularFilePath, FileUid, isVirtualFileUid } from './file-uid';\nimport { FsCache } from './fs-cache';\n\nexport interface TargetRecord {\n    files: Record<FileUid, FileRecord>;\n    /**\n     * 键值是依赖文件 Id。\n     */\n    externalDependencies: Record<string, string>;\n\n    /**\n     * 外部依赖所牵扯到的所有文件以及它们的时间戳。\n     * 键是依赖文件 Id。\n     */\n    externalDependencyWatchFiles: Record<string, number>;\n\n    externalDependencyImportMap: Record<string, string>;\n}\n\nexport async function detectChangedFiles({\n    rootDir,\n    entries,\n    targetRecord,\n    bundler,\n    fsCache,\n}: {\n    rootDir: string;\n    entries: FileUid[];\n    targetRecord: TargetRecord;\n    bundler: IBundler;\n    fsCache: FsCache;\n}) {\n    const startupFilesToAudit = entries.concat(Object.keys(targetRecord.files));\n\n    const filesToAudit: Set<FileUid> = new Set();\n    await Promise.all(startupFilesToAudit.map(async (startupFile: FileUid) => {\n        const delFromRecord = () => delete targetRecord.files[startupFile];\n\n        if (!isVirtualFileUid(startupFile)) {\n            if (!(await fsCache.pathExists(startupFile))) {\n                delFromRecord();\n                return;\n            }\n\n            const fileStat = await fsCache.stat(startupFile);\n            const fileTime = fileStat.mtimeMs;\n            if (!(startupFile in targetRecord.files) ||\n                targetRecord.files[startupFile].fileTime !== fileTime ||\n                Object.values(targetRecord.files[startupFile].dependencies).some((resolveRecord) => !resolveRecord.resolved)) {\n                filesToAudit.add(startupFile);\n                delFromRecord();\n                return;\n            }\n        }\n\n        if (!(await bundler.isOutFileValid(startupFile))) {\n            filesToAudit.add(startupFile);\n            delFromRecord();\n            return;\n        }\n    }));\n    return Array.from(filesToAudit);\n}\n"]}