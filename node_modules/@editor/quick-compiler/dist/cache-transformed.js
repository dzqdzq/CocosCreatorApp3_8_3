"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheTransformed = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const file_uid_1 = require("./file-uid");
const url_1 = require("url");
const utilts_1 = require("./utilts");
class CacheTransformed {
    constructor({ cacheDir, }) {
        this._cacheDir = cacheDir;
    }
    async store(path, code, map) {
        const realPath = this.getOutFilePath(path);
        await fs_extra_1.default.ensureDir(path_1.default.dirname(realPath));
        await Promise.all([
            await fs_extra_1.default.writeFile(realPath, code, { encoding: 'utf8' }),
            map ? await fs_extra_1.default.writeFile(`${realPath}.map`, map.toString(), { encoding: 'utf8' }) : undefined,
        ]);
    }
    async isOutFileValid(fileUid) {
        return await fs_extra_1.default.pathExists(this.getOutFilePath(fileUid));
    }
    getOutFileUrl(fileUid) {
        return (0, url_1.pathToFileURL)(this.getOutFilePath(fileUid)).href;
    }
    async serialize() {
        return;
    }
    async deserialize(json) {
    }
    get cacheDir() {
        return this._cacheDir;
    }
    async forEachModule(visitor) {
        const visitRecursive = async (dir, prefix, visitor) => {
            return await Promise.all((await fs_extra_1.default.readdir(dir)).map(async (fileName) => {
                const file = path_1.default.join(dir, fileName);
                const stat = await fs_extra_1.default.stat(file);
                const filePrefix = prefix ? `${prefix}/${fileName}` : fileName;
                if (stat.isDirectory()) {
                    await visitRecursive(file, filePrefix, visitor);
                }
                else {
                    await visitor(file, filePrefix);
                }
            }));
        };
        await visitRecursive(this._cacheDir, '', async (file, prefix) => {
            if (file.toLowerCase().endsWith('.js')) {
                const mapPath = `${file}.map`;
                const [code, map] = await Promise.all([
                    fs_extra_1.default.readFile(file),
                    fs_extra_1.default.readJson(mapPath).catch(() => undefined),
                ]);
                await visitor(prefix, code, map, map ? (0, url_1.pathToFileURL)(mapPath) : undefined);
            }
        });
    }
    getRelativeOutputPath(fileUid) {
        let relative;
        if ((0, file_uid_1.isVirtualFileUid)(fileUid)) {
            const encodedName = (0, utilts_1.encodeUrlAsFilePath)((0, file_uid_1.decodeVirtualFileUid)(fileUid));
            relative = path_1.default.join('virtual', encodedName.startsWith('.js') ? encodedName : `${encodedName}.js`);
        }
        else {
            relative = path_1.default.join('fs', transformOutputExtension((0, file_uid_1.decodeRegularFilePath)(fileUid)));
        }
        return relative;
    }
    getOutFilePath(fileUid) {
        return path_1.default.join(this._cacheDir, this.getRelativeOutputPath(fileUid));
    }
}
exports.CacheTransformed = CacheTransformed;
function transformOutputExtension(file) {
    const lower = file.toLowerCase();
    if (lower.endsWith('.json')) {
        return `${file.substr(0, file.length - 5)}.js`;
    }
    else if (lower.endsWith('.ts')) {
        return `${file.substr(0, file.length - 3)}.js`;
    }
    else {
        return file;
    }
}
//# sourceMappingURL=cache-transformed.js.map