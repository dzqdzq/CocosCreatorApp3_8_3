"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickCompiler = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const concat_bundler_1 = require("./concat-bundler");
const target_1 = require("./target");
const path_url_interop_1 = require("@editor/transform-utilities/dist/path-url-interop");
const fs_cache_1 = require("./fs-cache");
const progress_1 = require("./progress");
const seq_1 = require("./seq");
const winston_1 = __importDefault(require("winston"));
const ccbuild_1 = require("@cocos/ccbuild");
const file_uid_1 = require("./file-uid");
const virtual_modules_1 = require("./virtual-modules");
const globby_1 = __importDefault(require("globby"));
const winston_transport_1 = __importDefault(require("winston-transport"));
const VERSION = '1.2.32';
/**
 * @param options
 */
async function quickCompile(options, bundlers, statsQuery) {
    var _a;
    const { rootDir, outDir, platform = 'HTML5' } = options;
    const loggerOptions = {
        level: 'debug',
        format: winston_1.default.format.simple(),
    };
    if (options.logFile) {
        loggerOptions.transports = [
            new winston_1.default.transports.File({ level: 'debug', filename: options.logFile }),
            new EditorTransport({ level: 'warn' }),
        ];
    }
    else {
        loggerOptions.transports = [
            new EditorTransport(),
        ];
    }
    const logger = winston_1.default.createLogger(loggerOptions);
    logger.debug(`QuickCompiler v${VERSION}`);
    logger.debug(new Date().toUTCString());
    logger.debug(`Input options: ${JSON.stringify(options, undefined, 2)}`);
    const optionsRecord = recordOptions(options);
    const incrementalRecordFile = options.incrementalFile || path_1.default.join(outDir, '.incremental.json');
    // Try to read incremental cache.
    const rootRecord = await (async () => {
        try {
            const rootRecord = (await fs_extra_1.default.readJSON(incrementalRecordFile));
            if (rootRecord.version !== VERSION) {
                logger.debug(`[Quick-compiler] Version mismatch.`);
            }
            else {
                if (matchOptionsRecord(optionsRecord, rootRecord.options)) {
                    logger.debug(`[Quick-compiler] Incremental file seems great.`);
                    return rootRecord;
                }
                else {
                    logger.debug(`[Quick-compiler] Options doesn't match.\n` +
                        `Last: ${JSON.stringify(rootRecord.options, undefined, 2)}\n` +
                        `Current: ${JSON.stringify(optionsRecord, undefined, 2)}`);
                }
            }
        }
        catch (_a) {
            logger.debug(`[Quick-compiler] Version information lost.`);
        }
        logger.debug(`Clearing the outDir ${options.outDir}...`);
        await fs_extra_1.default.emptyDir(options.outDir);
        return {
            version: VERSION,
            options: optionsRecord,
            targets: new Array(options.targets.length).fill(null).map(() => {
                return {
                    files: {},
                    externalDependencies: {},
                    externalDependencyImportMap: {},
                    externalDependencyWatchFiles: {},
                };
            }),
        };
    })();
    const fsCache = new fs_cache_1.FsCache(rootDir);
    const targetLauncher = ((_a = options.targetLaunchPolicy) !== null && _a !== void 0 ? _a : 'seq') === 'seq'
        ? seq_1.sequenceDiscarding
        : seq_1.parallelDiscarding;
    await main();
    async function main() {
        await targetLauncher(options.targets, async (targetOption, targetIndex) => {
            logger.debug(`Starting target ${targetIndex}`);
            const label = `QuickCompiler:Compile target ${targetIndex}`;
            console.time(label);
            await targetMain(targetOption, rootRecord.targets[targetIndex], bundlers[targetIndex], targetIndex);
            console.timeEnd(label);
        });
        // Write incremental cache.
        await fs_extra_1.default.ensureDir(path_1.default.dirname(incrementalRecordFile));
        await fs_extra_1.default.writeFile(incrementalRecordFile, JSON.stringify(rootRecord, undefined, 4));
    }
    async function targetMain(targetOptions, targetRecord, bundler, targetIndex) {
        const onProgress = options.onProgress;
        const onTargetProgress = onProgress ? (message) => onProgress(targetIndex, message) : undefined;
        const virtualModules = new virtual_modules_1.VirtualModules();
        const include = (await fs_extra_1.default.readJson(path_1.default.join(options.rootDir, 'cc.config.json'))).includes;
        const files = [];
        const includeFiles = await (0, globby_1.default)(include, {
            cwd: options.rootDir,
            absolute: true,
        });
        files.push(...includeFiles.map((file) => { var _a; return (_a = (0, file_uid_1.encodeFilePath)(file, options.rootDir)) !== null && _a !== void 0 ? _a : file; }));
        const entryAliases = await getTargetPubEntries(targetOptions);
        if (targetOptions.includeIndex) {
            const featureUnits = statsQuery.getUnitsOfFeatures(targetOptions.includeIndex.features);
            logger.debug(`Modules involved in 'cc': ${featureUnits}`);
            const indexModuleSource = statsQuery.evaluateIndexModuleSource(featureUnits, (featureUnit) => statsQuery.getFeatureUnitFile(featureUnit).replace(/\\/g, '\\\\'));
            logger.debug(`The source of 'cc':\n${indexModuleSource}`);
            const vmIndex = (0, file_uid_1.encodeVirtualFileUid)('cc');
            virtualModules.set('cc', indexModuleSource);
            entryAliases['cc'] = vmIndex;
        }
        files.push(...Object.values(entryAliases));
        const changedFiles = await (0, target_1.detectChangedFiles)({
            rootDir,
            entries: files,
            targetRecord,
            bundler,
            fsCache,
        });
        const chunkDir = path_1.default.join(targetOptions.dir, 'external');
        if (changedFiles.length === 0) {
            logger.debug(`Seems like target ${targetIndex} has already up to date.`);
            return;
        }
        await (await Promise.resolve().then(() => __importStar(require('./core')))).core({
            rootDir,
            statsQuery,
            entries: changedFiles,
            targetRecord,
            targetOptions,
            bundler,
            chunkDir,
            fsCache,
            vm: virtualModules,
            logger,
            onProgress: onTargetProgress,
            platform,
        });
        const label = `QuickCompiler:Bundling target ${targetIndex}`;
        console.time(label);
        onTargetProgress === null || onTargetProgress === void 0 ? void 0 : onTargetProgress({
            stage: progress_1.Stage.bundle,
        });
        await bundler.build(Object.assign({
            outDir: path_1.default.join(targetOptions.dir, 'bundled'),
            sourceRoot: rootDir,
        }, targetOptions));
        console.timeEnd(label);
        if (targetOptions.loader) {
            await fs_extra_1.default.copyFile(path_1.default.join(__dirname, '..', 'static', 'loader.js'), path_1.default.join(targetOptions.dir, 'loader.js'));
        }
        await writeTargetImportMap(targetOptions, targetRecord, entryAliases, bundler, chunkDir);
    }
    async function getTargetPubEntries(targetOptions) {
        var _a, _b;
        const entryAliases = {};
        for (const featureUnit of statsQuery.getFeatureUnits()) {
            entryAliases[`${(_a = targetOptions.featureUnitPrefix) !== null && _a !== void 0 ? _a : ''}${featureUnit}`] = statsQuery.getFeatureUnitFile(featureUnit);
        }
        if ((_b = targetOptions.includeEditorExports) !== null && _b !== void 0 ? _b : true) {
            for (const editorPublicModule of statsQuery.getEditorPublicModules()) {
                entryAliases[editorPublicModule] = statsQuery.getEditorPublicModuleFile(editorPublicModule);
            }
        }
        for (const [k, v] of Object.entries(entryAliases)) {
            const uid = (0, file_uid_1.encodeFilePath)(v, rootDir);
            if (!uid) {
                throw new Error(`Entry ${v} is not under engine root.`);
            }
            else {
                entryAliases[k] = uid;
            }
        }
        return entryAliases;
    }
    async function writeTargetImportMap(targetOptions, targetRecord, entryAliases, bundler, chunkDir) {
        const importMap = { imports: {} };
        const importMapFile = path_1.default.join(targetOptions.dir, 'partial-import-map.json');
        for (const [alias, entry] of Object.entries(entryAliases)) {
            const finalUrl = bundler.getFinalUrl(entry);
            if (typeof finalUrl === 'string') {
                importMap.imports[alias] = finalUrl;
            }
            else {
                const relUrl = (0, path_url_interop_1.urlRelative)((0, path_url_interop_1.pathToFileURL)(importMapFile), (0, path_url_interop_1.pathToFileURL)(finalUrl.path));
                importMap.imports[alias] = relUrl;
            }
        }
        const chunkBaseURL = (0, path_url_interop_1.urlRelative)((0, path_url_interop_1.pathToFileURL)(importMapFile), (0, path_url_interop_1.pathToFileURL)(chunkDir));
        for (const [alias, chunkRelativeURL] of Object.entries(targetRecord.externalDependencyImportMap)) {
            importMap.imports[alias] = `./${chunkBaseURL}/${chunkRelativeURL}`;
        }
        await fs_extra_1.default.ensureDir(path_1.default.dirname(importMapFile));
        await fs_extra_1.default.writeFile(importMapFile, JSON.stringify(importMap, undefined, 4));
    }
}
class EditorTransport extends winston_transport_1.default {
    log(info, callback) {
        setImmediate(() => {
            this.emit('logged', info);
        });
        const MESSAGE = Symbol.for('message');
        const LEVEL = Symbol.for('level');
        const { [MESSAGE]: message, [LEVEL]: level, } = info;
        let consoleX;
        switch (level) {
            case 'error':
                consoleX = console.error;
                break;
            case 'warn':
                consoleX = console.warn;
                break;
            case 'info':
            case 'http':
            default:
                consoleX = console.info;
                break;
            case 'verbose':
            case 'debug':
            case 'silly':
                consoleX = console.debug;
                break;
        }
        consoleX.call(console, message);
        callback();
    }
}
class QuickCompiler {
    constructor(options) {
        this._statsQuery = null;
        this._options = Object.assign({}, options);
        this._bundlers = options.targets.map((targetOptions) => {
            return new concat_bundler_1.ConcatBundler({
                cacheDir: path_1.default.join(targetOptions.dir, 'transform-cache'),
                format: targetOptions.format,
            });
        });
    }
    async build() {
        await quickCompile(this._options, this._bundlers, await this._getOrCreateStatsQuery());
    }
    async buildImportMap(targetIndex, features, configurableFlags) {
        var _a, _b, _c, _d;
        const options = this._options;
        const { rootDir, } = options;
        const statsQuery = await this._getOrCreateStatsQuery();
        const moduleOverrides = this._setupModuleOverrides(statsQuery, features, configurableFlags, options.platform);
        const target = options.targets[targetIndex];
        const bundler = this._bundlers[targetIndex];
        let importMap = {};
        try {
            importMap = await fs_extra_1.default.readJson(path_1.default.join(target.dir, 'partial-import-map.json'));
        }
        catch (err) {
            console.error(`Failed to read engine build result. Please rebuild engine`);
            return;
        }
        for (const [k, v] of Object.entries(moduleOverrides)) {
            const targetUid = (0, file_uid_1.encodeFilePath)(v, rootDir);
            if (!targetUid) {
                continue;
            }
            const targetModuleId = (_a = bundler.getModuleId) === null || _a === void 0 ? void 0 : _a.call(bundler, targetUid);
            if (!targetModuleId) {
                continue;
            }
            let sourceModuleId = k;
            const sourceUid = (0, file_uid_1.encodeFilePath)(k, rootDir);
            if (sourceUid) {
                sourceModuleId = (_c = (_b = bundler.getModuleId) === null || _b === void 0 ? void 0 : _b.call(bundler, sourceUid)) !== null && _c !== void 0 ? _c : '';
            }
            if (!sourceModuleId) {
                continue;
            }
            ((_d = importMap.imports) !== null && _d !== void 0 ? _d : (importMap.imports = {}))[sourceModuleId] = targetModuleId;
        }
        await fs_extra_1.default.outputJson(path_1.default.join(target.dir, 'import-map.json'), importMap, { spaces: 2 });
    }
    async _getOrCreateStatsQuery() {
        if (this._statsQuery) {
            return this._statsQuery;
        }
        const statsQuery = await ccbuild_1.StatsQuery.create(this._options.rootDir);
        this._statsQuery = statsQuery;
        return statsQuery;
    }
    _setupModuleOverrides(statsQuery, features, configurableFlags, platform = 'HTML5') {
        const mode = 'PREVIEW';
        const intrinsicFlags = statsQuery.getIntrinsicFlagsOfFeatures(features);
        let buildTimeConstants = statsQuery.constantManager.genBuildTimeConstants({
            mode,
            platform,
            flags: {
                DEBUG: true,
            },
        });
        // @ts-ignore
        buildTimeConstants = Object.assign(Object.assign(Object.assign({}, buildTimeConstants), intrinsicFlags), configurableFlags);
        const moduleOverrides = statsQuery.evaluateModuleOverrides({
            mode,
            platform,
            buildTimeConstants,
        });
        return moduleOverrides;
    }
}
exports.QuickCompiler = QuickCompiler;
function recordOptions(options) {
    const record = Object.assign({}, options);
    delete record.logFile;
    delete record.targetLaunchPolicy;
    return JSON.parse(JSON.stringify(record));
}
function matchOptionsRecord(record, options) {
    return matchLhs(record, options);
    function matchLhs(lhs, rhs) {
        if (Array.isArray(lhs)) {
            return Array.isArray(rhs) && lhs.length === rhs.length &&
                lhs.every((v, i) => matchLhs(v, rhs[i]));
        }
        else if (typeof lhs === 'object' && lhs !== null) {
            return typeof rhs === 'object'
                && rhs !== null
                && Object.keys(lhs).every((key) => matchLhs(lhs[key], rhs[key]));
        }
        else if (lhs === null) {
            return rhs === null;
        }
        else {
            return lhs === rhs;
        }
    }
}
//# sourceMappingURL=index.js.map