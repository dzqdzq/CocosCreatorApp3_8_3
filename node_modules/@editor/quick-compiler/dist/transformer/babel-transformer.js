"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BabelTransformer = void 0;
const babel = __importStar(require("@babel/core"));
const preset_env_1 = __importDefault(require("@babel/preset-env"));
// @ts-ignore
const babel_plugin_const_enum_1 = __importDefault(require("babel-plugin-const-enum"));
// @ts-ignore
const plugin_transform_modules_umd_1 = __importDefault(require("@babel/plugin-transform-modules-umd"));
// @ts-ignore
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-ignore
const plugin_transform_modules_commonjs_1 = __importDefault(require("@babel/plugin-transform-modules-commonjs"));
// @ts-ignore
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const babel_plugin_dynamic_import_vars_1 = __importDefault(require("@cocos/babel-plugin-dynamic-import-vars"));
const bundler_1 = require("../bundler");
const module_specifier_visitor_1 = require("../module-specifier-visitor");
const creator_programming_babel_preset_cc_1 = require("@cocos/creator-programming-babel-preset-cc");
class BabelTransformer {
    static buildHelper() {
        // @ts-ignore
        return babel.buildExternalHelpers(null, 'module');
    }
    constructor({ targets, loose, targetModule, logger, optimizeDecorators, }) {
        this._loose = loose;
        this._targets = targets;
        this._targetModule = targetModule;
        this._logger = logger;
        this._optimizeDecorators = optimizeDecorators;
    }
    async transform(source, options) {
        var _a;
        const { _logger, } = this;
        const { fileName, isFile, sourceFileName, moduleId, replaceModuleSpecifier, isBabelHelper, } = options;
        const sourceMaps = !!sourceFileName;
        const targetModule = this._targetModule;
        const babelOptionsBase = {
            moduleIds: targetModule === bundler_1.TransformTargetModule.systemJsNamed,
            moduleId,
            filename: fileName,
            sourceMaps,
            sourceFileName,
            configFile: false,
            babelrc: false,
        };
        const addTransformModulesPlugin = (plugins) => {
            if (targetModule === bundler_1.TransformTargetModule.umd) {
                plugins.push([plugin_transform_modules_umd_1.default]);
            }
            else if (targetModule === bundler_1.TransformTargetModule.commonJs) {
                plugins.push([plugin_transform_modules_commonjs_1.default]);
            }
            else if (targetModule === bundler_1.TransformTargetModule.systemJs || targetModule === bundler_1.TransformTargetModule.systemJsNamed) {
                plugins.push([plugin_transform_modules_systemjs_1.default]);
            }
            return plugins;
        };
        if (isBabelHelper) {
            const babelFileResult = await babel.transformAsync(source, Object.assign(Object.assign({}, babelOptionsBase), { plugins: [
                    [babel_plugin_const_enum_1.default, { transform: 'constObject' }]
                ].concat(addTransformModulesPlugin([])) }));
            if (!babelFileResult) {
                throwUnexpectedBabelError();
            }
            else {
                return {
                    code: babelFileResult.code,
                };
            }
        }
        // const helperModuleRequest = getModuleRequestTo(babelHelpersModuleUid);
        let resolveModuleSpecifier;
        if (replaceModuleSpecifier) {
            // Resolves them and record the useful information.
            const moduleSpecifierResolveMap = {};
            const processModuleSpecifier = (moduleSpecifier) => {
                const replacement = replaceModuleSpecifier(moduleSpecifier);
                if (replacement) {
                    moduleSpecifierResolveMap[moduleSpecifier] = replacement;
                }
            };
            resolveModuleSpecifier = {
                visitor: (0, module_specifier_visitor_1.makeVisitorOnModuleSpecifiers)((moduleSpecifierPath) => {
                    const moduleSpecifier = moduleSpecifierPath.node.value;
                    processModuleSpecifier(moduleSpecifier);
                    // An in-place babel plugin which apply the resolve result.
                    if (moduleSpecifier in moduleSpecifierResolveMap) {
                        moduleSpecifierPath.replaceWith(babel.types.stringLiteral(moduleSpecifierResolveMap[moduleSpecifier]));
                    }
                }),
            };
        }
        // 2020.10.10: esbuild will treat empty files(not using es6 features) as commonjs modules.
        // 1. for commonjs modules, esbuild will generate strange _commonjs wrapper to handle.
        // 2. If a module (transitively) export star from commonjs modules, the module is
        // treated as commonjs module and will only export a default binding.
        const injectEmptyExportStmt = {
            visitor: { Program: { exit: (path) => {
                        if (path.node.body.length === 0) {
                            path.node.body.push(babel.types.exportNamedDeclaration(undefined, []));
                        }
                    } } },
        };
        const transformCodePassResult = await babel.transformAsync(source, Object.assign(Object.assign({}, babelOptionsBase), { presets: [
                [{ plugins: [
                            [babel_plugin_const_enum_1.default, { transform: 'constObject' }],
                            [plugin_proposal_dynamic_import_1.default],
                        ] }],
                [preset_env_1.default, {
                        modules: false,
                        targets: this._targets,
                        loose: this._loose,
                    }],
                [{ plugins: [
                            [injectEmptyExportStmt],
                            [babel_plugin_dynamic_import_vars_1.default],
                            [resolveModuleSpecifier],
                            ...addTransformModulesPlugin([]),
                        ] }],
                [creator_programming_babel_preset_cc_1.babelPresetCC, {
                        allowDeclareFields: true,
                        ccDecoratorHelpers: 'inline',
                        fieldDecorators: this._optimizeDecorators.fieldDecorators,
                    }],
                [{ plugins: [
                        // [importHelperPlugin, { helperModuleName: helperModuleRequest }],
                        ] }],
            ] }));
        if (!transformCodePassResult || !transformCodePassResult.code) {
            throwUnexpectedBabelError();
        }
        if ((_a = transformCodePassResult.map) === null || _a === void 0 ? void 0 : _a.sourcesContent) {
            if (isFile) {
                delete transformCodePassResult.map.sourcesContent;
            }
        }
        return {
            code: transformCodePassResult.code,
            map: transformCodePassResult.map ? JSON.stringify(transformCodePassResult.map) : undefined,
        };
        function throwUnexpectedBabelError() {
            throw new Error(`Babel returned empty result`);
        }
    }
}
exports.BabelTransformer = BabelTransformer;
//# sourceMappingURL=babel-transformer.js.map