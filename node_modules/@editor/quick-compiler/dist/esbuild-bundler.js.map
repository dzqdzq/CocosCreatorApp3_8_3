{"version":3,"file":"esbuild-bundler.js","sourceRoot":"","sources":["../src/esbuild-bundler.ts"],"names":[],"mappings":";;AAIA,+CAA+C;AAE/C,6EAA6E;AAC7E,2BAA2B;AAC3B,kBAAkB;AAClB,6CAA6C;AAC7C,wCAAwC;AACxC,+DAA+D;AAC/D,uEAAuE;AACvE,iEAAiE;AACjE,qFAAqF;AAErF,4FAA4F;AAC5F,sHAAsH;AACtH,mEAAmE;AACnE,wDAAwD;AACxD,2CAA2C;AAC3C,oDAAoD;AACpD,eAAe;AACf,sBAAsB;AACtB,8BAA8B;AAC9B,aAAa;AACb,QAAQ;AACR,MAAM;AACN,cAAc;AACd,iDAAiD;AAEjD,8CAA8C;AAC9C,gBAAgB;AAChB,YAAY;AAEZ,0DAA0D;AAC1D,wDAAwD;AACxD,mCAAmC;AACnC,qEAAqE;AACrE,sDAAsD;AACtD,4BAA4B;AAC5B,oCAAoC;AACpC,iDAAiD;AACjD,+BAA+B;AAC/B,6BAA6B;AAC7B,mCAAmC;AACnC,uCAAuC;AACvC,4BAA4B;AAC5B,0DAA0D;AAC1D,2BAA2B;AAC3B,cAAc;AACd,sCAAsC;AACtC,0DAA0D;AAC1D,wDAAwD;AACxD,8CAA8C;AAC9C,4DAA4D;AAC5D,YAAY;AACZ,4CAA4C;AAC5C,mFAAmF;AACnF,qDAAqD;AACrD,oDAAoD;AACpD,+DAA+D;AAC/D,sDAAsD;AACtD,uBAAuB;AACvB,6DAA6D;AAE7D,4EAA4E;AAC5E,uCAAuC;AACvC,8CAA8C;AAC9C,kEAAkE;AAClE,uHAAuH;AACvH,wHAAwH;AACxH,uHAAuH;AACvH,oFAAoF;AACpF,2GAA2G;AAC3G,4FAA4F;AAC5F,8BAA8B;AAC9B,wCAAwC;AACxC,uBAAuB;AACvB,gFAAgF;AAChF,oEAAoE;AACpE,yCAAyC;AACzC,yBAAyB;AACzB,6CAA6C;AAC7C,oFAAoF;AACpF,8BAA8B;AAC9B,mEAAmE;AACnE,wGAAwG;AACxG,mDAAmD;AACnD,6CAA6C;AAC7C,sEAAsE;AACtE,0IAA0I;AAC1I,6BAA6B;AAC7B,uBAAuB;AACvB,gBAAgB;AAChB,eAAe;AACf,+CAA+C;AAC/C,6EAA6E;AAC7E,qGAAqG;AAErG,kBAAkB;AAClB,QAAQ;AACR,IAAI","sourcesContent":["import fs from 'fs-extra';\nimport ps from 'path';\nimport { IBundler } from './bundler';\nimport { CacheTransformed } from './cache-transformed';\n// import esBuild, { Metadata } from 'esbuild';\n\n// export class EsBuildBundler extends CacheTransformed implements IBundler {\n//     public async build({\n//         outDir,\n//     }: Parameters<IBundler['build']>[0]) {\n//         const entries: string[] = [];\n//         const entryHome = ps.join(this.cacheDir, 'exports');\n//         for (const entryFileName of (await fs.readdir(entryHome))) {\n//             if (entryFileName.toLowerCase().endsWith('.js')) {\n//                 const entryFile = ps.normalize(ps.join(entryHome, entryFileName));\n\n//                 const systemProxyFile = ps.join(this.cacheDir, '__proxy', entryFileName);\n//                 const relativeUrl = `./${ps.relative(ps.dirname(systemProxyFile), entryFile).replace(/\\\\/g, '/')}`;\n//                 await fs.ensureDir(ps.dirname(systemProxyFile));\n//                 await fs.writeFile(systemProxyFile, `\n// import * as esExp from '${relativeUrl}';\n// System.register([], function(_context, _export) {\n//     return {\n//         execute() {\n//             _export(esExp);\n//         },\n//     }\n// });\n// `, 'utf8');\n//                 entries.push(systemProxyFile);\n\n//                 // entries.push(entryFile);\n//             }\n//         }\n\n//         const bundleOutDir = ps.join(outDir, 'bundle');\n//         await fs.ensureDir(ps.dirname(bundleOutDir));\n//         console.time('esbuild');\n//         const buildMetaFile = ps.join(outDir, 'bundle-meta.json');\n//         const esBuildResult = await esBuild.build({\n//             bundle: true,\n//             entryPoints: entries,\n//             outdir: ps.join(outDir, 'bundle'),\n//             splitting: true,\n//             format: 'esm',\n//             sourcemap: 'inline',\n//             metafile: buildMetaFile,\n//             write: false,\n//             external: ['@cocos/ammo', '@cocos/cannon'],\n//             color: true,\n//         });\n//         console.timeEnd('esbuild');\n//         for (const warning of esBuildResult.warnings) {\n//             const location = !warning.location ? '' :\n//                 `${warning.location.file}`;\n//             console.warn(`${location}: ${warning.text}`);\n//         }\n//         console.time(`Transform trunks`);\n//         await Promise.all(esBuildResult.outputFiles!.map(async (outputFile) => {\n//             const { path, contents } = outputFile;\n//             await fs.ensureDir(ps.dirname(path));\n//             if (!path.toLocaleLowerCase().endsWith('.js')) {\n//                 await fs.writeFile(path, contents);\n//             } else {\n//                 return await fs.writeFile(path, contents);\n\n//                 // const source = Buffer.from(contents).toString('utf8');\n//                 // let code: string;\n//                 // let inputSourceMap: any;\n//                 // // Note: . would not match the last new line\n//                 // // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll\n//                 // // See https://stackoverflow.com/questions/1979884/how-to-use-javascript-regex-over-multiple-lines\n//                 // const sourceMapMatch = /\\/\\/# sourceMappingURL=data:application\\/json;base64,(.*)/s.exec(source);\n//                 // if (sourceMapMatch && typeof sourceMapMatch[1] === 'string') {\n//                 //     inputSourceMap = JSON.parse(Buffer.from(sourceMapMatch[1], 'base64').toString());\n//                 //     code = source.substr(0, source.length - sourceMapMatch[0].length);\n//                 // } else {\n//                 //     code = source;\n//                 // }\n//                 // const transformResult = await babel.transformAsync(code, {\n//                 //     plugins: [babelPluginTransformModulesUmd],\n//                 //     inputSourceMap,\n//                 // });\n//                 // if (!transformResult) {\n//                 //     console.error(`Failed to transform bundle chunk to UMD!`);\n//                 // } else {\n//                 //     const codeWithMap = transformResult.map ?\n//                 //         `${transformResult.code}\\n//# sourceMappingURL=${ps.basename(path)}.map` :\n//                 //         transformResult.code;\n//                 //     await Promise.all([\n//                 //         fs.writeFile(path, codeWithMap, 'utf8'),\n//                 //         !transformResult.map ? undefined : fs.writeFile(`${path}.map`, JSON.stringify(transformResult.map), 'utf8'),\n//                 //     ]);\n//                 // }\n//             }\n//         }));\n//         console.timeEnd(`Transform trunks`);\n//         // const buildMeta = await fs.readJson(buildMetaFile) as Metadata;\n//         // await Promise.all(Object.entries(buildMeta.outputs).map(async ([path, outputInfo]) => {\n\n//         // }));\n//     }\n// }\n"]}