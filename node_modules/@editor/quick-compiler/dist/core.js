"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.core = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const module_resolve_1 = require("@editor/transform-utilities/dist/module-resolve");
const path_url_interop_1 = require("@editor/transform-utilities/dist/path-url-interop");
const url_1 = require("url");
const jss = __importStar(require("javascript-stringify"));
const file_uid_1 = require("./file-uid");
const virtual_modules_1 = require("./virtual-modules");
const bundle_externals_1 = require("./bundle-externals");
const bundler_1 = require("./bundler");
const progress_1 = require("./progress");
const seq_1 = require("./seq");
const relateurl_1 = __importDefault(require("relateurl"));
const ccbuild_1 = require("@cocos/ccbuild");
const babel_transformer_1 = require("./transformer/babel-transformer");
const externalProtocol = 'external:';
async function core({ rootDir, statsQuery, entries, targetOptions, targetRecord, bundler, chunkDir, fsCache, vm, logger, onProgress, platform = 'HTML5', }) {
    const babelHelpersModuleName = 'quick-compiler.babel-helpers';
    const babelHelpersModuleUid = (0, file_uid_1.encodeVirtualFileUid)(babelHelpersModuleName);
    const moduleQuery = new ccbuild_1.Modularize.ModuleQuery({
        engine: rootDir,
        platform: 'WEB_EDITOR',
    });
    const moduleExportMap = await moduleQuery.getExportMap();
    const virtualModules = vm !== null && vm !== void 0 ? vm : new virtual_modules_1.VirtualModules();
    await setupVirtualModules(platform);
    const moduleResolver = new module_resolve_1.ModuleResolver({
        rootDir,
    });
    // Do audition.
    const audition = { audited: new Set() };
    const transformProgress = {
        stage: progress_1.Stage.transform,
        total: 0,
        progress: 0,
        file: '',
    };
    const updateTransformProgress = onProgress
        ? () => onProgress(transformProgress)
        : undefined;
    await main();
    async function main() {
        await Promise.all(entries.concat([babelHelpersModuleUid]).map((fileUid) => audit(fileUid)));
        if (await rebuildExternalDependenciesIsNeeded()) {
            onProgress === null || onProgress === void 0 ? void 0 : onProgress({
                stage: progress_1.Stage.external,
            });
            await createExternalDependenciesStuffs();
        }
    }
    async function setupVirtualModules(platform) {
        const dynamicConstants = statsQuery.constantManager.exportDynamicConstants({
            // platform and mode are dynamic values, indeed we don't have to pass these value.
            platform,
            mode: 'PREVIEW',
            flags: {
                DEBUG: true,
                CULL_MESHOPT: false, // NOTE: CULL_MESHOPT should be disabled in 'editor' and 'preview' engine, it should only impact 'Build' result.
            },
        });
        virtualModules.set('internal:constants', () => dynamicConstants);
        virtualModules.set(babelHelpersModuleName, () => {
            return babel_transformer_1.BabelTransformer.buildHelper();
        });
    }
    /**
     * @param fileUid
     */
    async function audit(fileUid) {
        if (audition.audited.has(fileUid)) {
            return;
        }
        audition.audited.add(fileUid);
        if (fileUid in targetRecord.files) {
            return;
        }
        let source;
        let fileTime = 0;
        const isVirtual = (0, file_uid_1.isVirtualFileUid)(fileUid);
        if (isVirtual) {
            const name = (0, file_uid_1.decodeVirtualFileUid)(fileUid);
            if (!virtualModules.has(name)) {
                logger.error(`Can not find module(virtual): ${name}`);
                return;
            }
            source = virtualModules.get(name);
        }
        else {
            fileTime = (await fsCache.stat(fileUid)).mtimeMs;
            source = await fsCache.readFile(fileUid);
            if (fileUid.toLowerCase().endsWith('.json')) {
                // Because AMD (which is our engine code format, in editor or previewer)
                // is not able to import a json module, in [SystemJS](https://github.com/systemjs/systemjs/issues/2045).
                // We should transform the json module here.
                source = `export default ${jss.stringify(JSON.parse(source), undefined, 2)}`;
            }
        }
        // Update total
        ++transformProgress.total;
        transformProgress.file = fileUid;
        updateTransformProgress === null || updateTransformProgress === void 0 ? void 0 : updateTransformProgress();
        transformProgress.file = '';
        logger.debug(`[QuickCompiler] Transforming ${fileUid}...`);
        const newFileRecord = {
            fileTime,
            dependencies: {},
            status: false,
        };
        targetRecord.files[fileUid] = newFileRecord;
        const transformResult = await (async () => {
            try {
                return await compileFile(source, fileUid, newFileRecord, bundler);
            }
            catch (err) {
                logger.error(err);
                return;
            }
        })();
        newFileRecord.status = !!transformResult;
        // Update progress
        ++transformProgress.progress;
        updateTransformProgress === null || updateTransformProgress === void 0 ? void 0 : updateTransformProgress();
        const store = !transformResult ? undefined :
            bundler.store(fileUid, transformResult.code, transformResult.map);
        await store;
        await (0, seq_1.sequenceDiscarding)(Object.entries(newFileRecord.dependencies).reduce((result, [_moduleSpecifier, resolveRecord]) => {
            if (!resolveRecord.external && resolveRecord.resolved) {
                result.push(resolveRecord.resolved);
            }
            return result;
        }, []), async (dependency) => await audit(dependency));
    }
    /**
     * @param source
     * @param fileUid
     * @param record
     */
    async function compileFile(source, fileUid, record, bundler) {
        var _a, _b, _c, _d;
        const targetModule = (_a = bundler.targetMode) !== null && _a !== void 0 ? _a : bundler_1.TransformTargetModule.esm;
        const targets = targetOptions.targets;
        const loose = (_b = targetOptions.loose) !== null && _b !== void 0 ? _b : false;
        const optimizeDecorators = statsQuery.getOptimizeDecorators();
        const transformer = new babel_transformer_1.BabelTransformer({
            targets,
            loose,
            targetModule,
            logger,
            optimizeDecorators,
        });
        const outFileURL = bundler.getOutFileUrl(fileUid);
        const resolveRelativeFromOutFile = new relateurl_1.default(outFileURL);
        let fileName;
        let sourceFileName;
        let isFile = false;
        if ((0, file_uid_1.isVirtualFileUid)(fileUid)) {
            sourceFileName = `virtual:///${(0, file_uid_1.decodeVirtualFileUid)(fileUid)}`;
        }
        else {
            fileName = path_1.default.resolve(rootDir, (0, file_uid_1.decodeRegularFilePath)(fileUid));
            isFile = true;
            const fileURL = (0, url_1.pathToFileURL)(fileName);
            if (targetOptions.usedInElectron509) {
                sourceFileName = fileURL.href;
            }
            else {
                sourceFileName = resolveRelativeFromOutFile.relate(fileURL.href);
            }
        }
        const moduleId = (_d = (_c = bundler.getModuleId) === null || _c === void 0 ? void 0 : _c.call(bundler, fileUid)) !== null && _d !== void 0 ? _d : fileUid;
        const getModuleRequestTo = (targetFileUid) => (0, path_url_interop_1.moduleSpecifierURLRelative)(outFileURL, bundler.getOutFileUrl(targetFileUid));
        const readDepRecord = (moduleSpecifier) => {
            if (!(moduleSpecifier in record.dependencies)) {
                return undefined;
            }
            const resolveRecord = record.dependencies[moduleSpecifier];
            if (resolveRecord.resolved && !resolveRecord.external) {
                const replacement = (0, module_resolve_1.replaceWithOutputExtension)(getModuleRequestTo(resolveRecord.resolved));
                return replacement;
            }
            else {
                return undefined;
            }
        };
        const replaceModuleSpecifier = (moduleSpecifier) => {
            if (moduleSpecifier in record.dependencies) {
                return readDepRecord(moduleSpecifier);
            }
            let resolvedModule;
            if (virtualModules.has(moduleSpecifier)) {
                resolvedModule = {
                    file: moduleSpecifier,
                    isExternal: false,
                };
            }
            else if (moduleSpecifier.startsWith(externalProtocol)) {
                if (moduleSpecifier.endsWith('.wasm') || moduleSpecifier.endsWith('.js.mem') || moduleSpecifier.endsWith('.wasm.fallback')) {
                    // for module ending with '.wasm' or '.js.mem', we only export an external url.
                    virtualModules.set(moduleSpecifier, () => {
                        return `export default '${moduleSpecifier}';`;
                    });
                    resolvedModule = {
                        file: moduleSpecifier,
                        isExternal: false,
                    };
                }
                else {
                    const externalInEngine = moduleSpecifier.replace(externalProtocol, 'native/external/');
                    resolvedModule = {
                        file: path_1.default.join(rootDir, externalInEngine),
                        isExternal: true,
                    };
                }
            }
            else if (!fileName) { // isVirtualFileUid(fileUid)
                resolvedModule = {
                    file: moduleSpecifier,
                    isExternal: false,
                };
            }
            else if (moduleExportMap[moduleSpecifier]) {
                resolvedModule = {
                    file: moduleExportMap[moduleSpecifier],
                    isExternal: false,
                };
            }
            else {
                resolvedModule = moduleResolver.resolveSync(moduleSpecifier, fileName);
                if (resolvedModule && !resolvedModule.isExternal) {
                    const lower = resolvedModule.file.toLowerCase();
                    if (lower.endsWith('.d.ts')) {
                        // If a module is resolved to a declaration file.
                        // We are trying to figure out the real code file.
                        const baseName = resolvedModule.file.substr(0, resolvedModule.file.length - 5);
                        let found = false;
                        for (const extension of ['.js', '.json']) {
                            const name = `${baseName}${extension}`;
                            if (fs_extra_1.default.pathExistsSync(name)) {
                                resolvedModule.file = name;
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            resolvedModule = null;
                        }
                    }
                }
            }
            const resolveRecord = record.dependencies[moduleSpecifier] = { resolved: undefined };
            if (!resolvedModule) {
                logger.debug(`Failed to resolve ${moduleSpecifier} from ${fileName}`);
            }
            else if (resolvedModule.isExternal) {
                resolveRecord.resolved = getDependencyFileId(resolvedModule.file);
                resolveRecord.external = true;
            }
            else {
                const depFileId = getFileUidFromResolved(resolvedModule.file);
                if (!depFileId) {
                    logger.error(`File ${resolvedModule.file} referenced from ${fileName !== null && fileName !== void 0 ? fileName : fileUid} is not under source root.`);
                }
                else {
                    resolveRecord.resolved = depFileId;
                }
            }
            return readDepRecord(moduleSpecifier);
        };
        return await transformer.transform(source, {
            fileName,
            sourceFileName,
            isFile,
            moduleId,
            replaceModuleSpecifier,
            isBabelHelper: fileUid === babelHelpersModuleUid,
        });
    }
    /**
     *
     */
    function countExternalDependencies() {
        const dependenciesMap = {};
        for (const fileRecord of Object.values(targetRecord.files)) {
            Object.assign(dependenciesMap, Object.entries(fileRecord.dependencies).reduce((result, [moduleSpecifier, resolveRecord]) => {
                if (resolveRecord.external && resolveRecord.resolved) {
                    result[moduleSpecifier] = resolveRecord.resolved;
                }
                return result;
            }, {}));
        }
        return dependenciesMap;
    }
    /**
     *
     */
    async function rebuildExternalDependenciesIsNeeded() {
        /// / TODO!!!!! remove
        // return true;
        // eslint-disable-next-line no-constant-condition
        if (true) {
            const old = targetRecord.externalDependencies;
            const now = countExternalDependencies();
            const keysOld = Object.keys(old);
            const keysNew = Object.keys(now);
            if (keysOld.length !== keysNew.length ||
                !keysOld.every((keyOld) => keysNew.includes(keyOld) && old[keyOld] === now[keyOld]) ||
                !keysNew.every((keyNew) => keysOld.includes(keyNew))) {
                logger.debug(`Dependencies changed from ${JSON.stringify(old, undefined, 2)} to ${JSON.stringify(now, undefined, 2)}`);
                return true;
            }
        }
        // 任何外部依赖文件更新了，都需要重新构建。
        for (const file of Object.keys(targetRecord.externalDependencyWatchFiles)) {
            const stamp = targetRecord.externalDependencyWatchFiles[file];
            try {
                const stat = await fs_extra_1.default.stat(getDependencyFile(file));
                if (stat.mtimeMs !== stamp) {
                    logger.debug(`[QuickCompiler] External dependency "${file}" changed.`);
                    return true;
                }
            }
            catch (_a) {
                logger.debug(`[QuickCompiler] Miss external dependency "${file}".`);
                return true;
            }
        }
        return false;
    }
    /**
     * @param chunkDir
     * @param importMapFile
     */
    async function createExternalDependenciesStuffs() {
        targetRecord.externalDependencyWatchFiles = {};
        targetRecord.externalDependencyImportMap = {};
        const dependenciesMap = countExternalDependencies();
        const dependenciesMapResolved = {};
        for (const key of Object.keys(dependenciesMap)) {
            dependenciesMapResolved[key] = getDependencyFile(dependenciesMap[key]);
        }
        const dependencyEntries = Object.entries(dependenciesMapResolved).map(([k, v]) => [v, k]);
        logger.debug(`Bundling external dependencies: ${JSON.stringify(dependenciesMapResolved, undefined, 2)}`);
        const bundleResult = await (0, bundle_externals_1.bundleExternals)(dependencyEntries, {
            rootDir,
            perf: targetOptions.perf,
        });
        if (await fs_extra_1.default.pathExists(chunkDir)) {
            await fs_extra_1.default.emptyDir(chunkDir);
        }
        await bundleResult.write({
            format: targetOptions.format,
            sourceMap: true,
            chunkDir,
        });
        for (const moduleSpecifier of Object.keys(dependenciesMapResolved)) {
            const entry = dependenciesMapResolved[moduleSpecifier];
            const chunkRelativeURL = bundleResult.entryMap[entry].split(/[\\/]/g).map((part) => encodeURIComponent(part)).join('/');
            targetRecord.externalDependencyImportMap[moduleSpecifier] = chunkRelativeURL;
        }
        const watchFiles = {};
        for (const watchFile of bundleResult.watchFiles) {
            try {
                const stat = await fs_extra_1.default.stat(watchFile);
                watchFiles[getDependencyFileId(watchFile)] = stat.mtimeMs;
            }
            catch (_a) {
            }
        }
        targetRecord.externalDependencies = dependenciesMap;
        targetRecord.externalDependencyWatchFiles = watchFiles;
    }
    /**
     * @param moduleNameOrFile
     */
    function getFileUidFromResolved(moduleNameOrFile) {
        if (virtualModules.has(moduleNameOrFile)) {
            return (0, file_uid_1.encodeVirtualFileUid)(moduleNameOrFile);
        }
        const relativeFromRoot = path_1.default.relative(path_1.default.join(rootDir), moduleNameOrFile);
        if (relativeFromRoot.length === 0 ||
            relativeFromRoot.startsWith('..') ||
            path_1.default.isAbsolute(relativeFromRoot)) {
            return null;
        }
        else {
            return relativeFromRoot;
        }
    }
    /**
     * @param dependencyFile
     */
    function getDependencyFileId(dependencyFile) {
        return path_1.default.relative(rootDir, dependencyFile);
    }
    /**
     * @param dependencyFileId
     */
    function getDependencyFile(dependencyFileId) {
        return path_1.default.resolve(rootDir, dependencyFileId);
    }
}
exports.core = core;
//# sourceMappingURL=core.js.map