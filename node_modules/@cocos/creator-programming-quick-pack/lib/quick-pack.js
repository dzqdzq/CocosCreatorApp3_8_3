"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPack = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const url_1 = require("url");
const creator_programming_mod_lo_1 = require("@cocos/creator-programming-mod-lo");
const writer_1 = require("./utils/chunk-io/writer");
const loader_context_1 = require("./utils/loader-context");
const url_2 = require("@cocos/creator-programming-common/lib/url");
const logger_1 = require("@cocos/creator-programming-common/lib/logger");
const asserts_1 = require("@cocos/creator-programming-common/lib/asserts");
const creator_programming_common_1 = require("@cocos/creator-programming-common");
const launch_policy_1 = require("@cocos/creator-programming-common/lib/launch-policy");
const i18n_1 = require("@cocos/creator-programming-common/lib/i18n");
const specifier_1 = require("@cocos/creator-programming-common/lib/specifier");
const middleware_1 = require("./middleware");
const share_1 = require("@cocos/creator-programming-mod-lo/lib/cjs/share");
const getLauncher = (par) => par ? launch_policy_1.parallelDiscarding : launch_policy_1.launchSequentially;
// TODO: parallel
const ALL_PARALLEL = false;
const launchLinkDependencies = getLauncher(ALL_PARALLEL);
const launchInstantiateDependencies = getLauncher(ALL_PARALLEL);
class QuickPack {
    constructor({ modLo, sourceMaps, origin, workspace, verbose, logger, }) {
        this._moduleRecords = {};
        this._verbose = verbose !== null && verbose !== void 0 ? verbose : false;
        this._middleware = new middleware_1.QuickPackMiddleware(workspace);
        this._origin = origin;
        this._modLo = modLo;
        this._sourceMaps = sourceMaps !== null && sourceMaps !== void 0 ? sourceMaps : true;
        const theLogger = logger !== null && logger !== void 0 ? logger : (0, logger_1.createLogger)({});
        this._chunkWriter = new writer_1.ChunkWriter({
            chunkHomePath: this._middleware.chunkHomePath,
            importMapPath: this._middleware.importMapPath,
            resolutionDetailMapPath: this._middleware.resolutionDetailMapPath,
            logger: theLogger,
        });
        this._logger = theLogger;
    }
    async build(specifiers, options) {
        var _a, _b;
        const context = {
            modules: new Map(),
            cleanResolution: (_a = options === null || options === void 0 ? void 0 : options.cleanResolution) !== null && _a !== void 0 ? _a : false,
            retryResolutionOnUnchangedModule: (_b = options === null || options === void 0 ? void 0 : options.retryResolutionOnUnchangedModule) !== null && _b !== void 0 ? _b : false,
        };
        const chunkAlias = {};
        for (const specifier of specifiers) {
            const url = await this._resolveEntry(typeof specifier === 'string' ? specifier : specifier.href);
            if (!url) {
                continue;
            }
            const inspectRecord = await this._getOrCreateInspectRecord(url, context);
            await this._instantiateAll(inspectRecord, new Set());
            const moduleRecord = this._moduleRecords[url.href];
            if (!moduleRecord) {
                this._logger.debug(`Entry ${url} did not library a chunk.`);
                continue;
            }
            const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
            chunkAlias[typeof specifier === 'string' ? specifier : specifier.href] = moduleRecord.chunkId;
            (0, asserts_1.asserts)(chunk);
        }
        this._chunkWriter.setEntryChunks(chunkAlias);
        await this._middleware.lock();
        await this._chunkWriter.persist();
        const serializedMainRecord = this._serializeMainRecord();
        await fs_extra_1.default.outputJson(this._middleware.mainRecordPath, serializedMainRecord, { encoding: 'utf8', spaces: 2 });
        const serializedAssemblyRecord = this._chunkWriter.serializeRecord();
        await fs_extra_1.default.outputJson(this._middleware.assemblyRecordPath, serializedAssemblyRecord, { encoding: 'utf8', spaces: 2 });
        await this._middleware.unlock();
        return {
            depsGraph: this._getDepsGraphFromModuleRecords(),
        };
    }
    async createLoaderContext() {
        return new loader_context_1.LoaderContext(this._middleware.workspace);
    }
    async clear() {
        this._moduleRecords = {};
        const recordFile = this._middleware.mainRecordPath;
        try {
            await fs_extra_1.default.unlink(recordFile);
        }
        catch (err) {
            this._logger.debug(`Failed to delete record file ${recordFile}: ${err}`);
        }
        await this._chunkWriter.clear();
    }
    async loadCache() {
        try {
            const serializedMainRecord = await fs_extra_1.default.readJson(this._middleware.mainRecordPath);
            const serializedAssemblyRecord = await fs_extra_1.default.readJson(this._middleware.assemblyRecordPath);
            this._deserializeMainRecord(serializedMainRecord);
            this._chunkWriter.deserializeRecord(serializedAssemblyRecord);
        }
        catch (err) {
            this._logger.debug(`Record file loaded failed with error: ${err}`);
        }
    }
    async _resolveEntry(specifier) {
        try {
            const resolved = await this._modLo.resolve(specifier, undefined, 'esm');
            if (resolved.isExternal) {
                this._logger.error(`Entry(${specifier}) shall not be resolved to an external.`);
                return;
            }
            else {
                return resolved.url;
            }
        }
        catch (err) {
            this._logger.error((0, i18n_1.i18nTranslate)('quick_pack_could_not_resolve_entry', { specifier }));
            return;
        }
    }
    async _getOrCreateInspectRecord(url, context) {
        const existedInspectRecord = context.modules.get(url.href);
        if (existedInspectRecord) {
            return existedInspectRecord;
        }
        // eslint-disable-next-line prefer-const
        let inspectRecord;
        const inspectPromise = this._inspectWithCache(url);
        const linkPromise = inspectPromise.then(async (moduleInspectInfo) => {
            if (moduleInspectInfo) {
                if (moduleInspectInfo.moduleRecord.erroneous) {
                    // If the module is erroneous, we can't link it.
                }
                else {
                    const dependencies = await this._link(url, moduleInspectInfo.moduleRecord, context);
                    inspectRecord.dependencies = dependencies;
                }
            }
        });
        inspectRecord = {
            inspect: inspectPromise,
            link: linkPromise,
            dependencies: undefined,
        };
        context.modules.set(url.href, inspectRecord);
        // Optional, `ALL_PARALLEL` makes debugging easier.
        if (!ALL_PARALLEL) {
            await linkPromise;
        }
        return inspectRecord;
    }
    async _instantiateAll(inspectRecord, visited) {
        if (visited.has(inspectRecord)) {
            return;
        }
        visited.add(inspectRecord);
        await inspectRecord.link;
        if (inspectRecord.dependencies) {
            await launchInstantiateDependencies(inspectRecord.dependencies, async (dependency) => {
                if (dependency) {
                    await this._instantiateAll(dependency, visited);
                }
            });
        }
    }
    async _inspectWithCache(url) {
        let mTimestamp;
        try {
            mTimestamp = await this._modLo.getMTimestamp(url);
        }
        catch (err) {
            // If error was thrown when query the mtime, we ignore it and suppose the time as current time.
            // This makes so that if the module is erroneous finally, it will be reload in next time.
            mTimestamp = Date.now();
        }
        const oldModuleRecord = this._moduleRecords[url.href];
        if (oldModuleRecord) {
            if ((0, creator_programming_mod_lo_1.isEqualMTimestamp)(mTimestamp, oldModuleRecord.mTimestamp)) {
                return { moduleRecord: oldModuleRecord, updated: false };
            }
            this._logger.debug(`Detected change: ${url}. Last mtime: ${(0, creator_programming_mod_lo_1.mTimestampToString)(oldModuleRecord.mTimestamp)}, Current mtime: ${(0, creator_programming_mod_lo_1.mTimestampToString)(mTimestamp)}`);
            this._moduleRecords[url.href] = null;
            await this._chunkWriter.removeChunk(oldModuleRecord.chunkId);
        }
        if (this._verbose) {
            this._logger.debug(`Inspect ${url}`);
        }
        const moduleRecord = await this._inspect(url, mTimestamp).catch((err) => {
            this._logger.error(err);
        });
        if (!moduleRecord) {
            return undefined;
        }
        return { moduleRecord, updated: true };
    }
    async _link(url, moduleRecord, context) {
        const chunkImports = {};
        if (context.cleanResolution) {
            moduleRecord.resolutions = undefined;
        }
        let forceResolve = false;
        if (!moduleRecord.resolutions) {
            forceResolve = true;
            moduleRecord.resolutions = new Array(moduleRecord.imports.length).fill(null);
        }
        const resolutions = moduleRecord.resolutions;
        const depRecords = await launchLinkDependencies(moduleRecord.imports, async (specifier, iImport) => {
            var _a, _b;
            let resolution = resolutions[iImport];
            if (forceResolve || // Not resolved before
                resolution.resolved.type === 'error' && context.retryResolutionOnUnchangedModule // Resolved but failed
            ) {
                resolution = await this._resolve(specifier, url, moduleRecord.type);
                resolutions[iImport] = resolution;
            }
            (0, asserts_1.assertsNonNullable)(resolution);
            const chunkImportKey = (_a = specifier.resolved) !== null && _a !== void 0 ? _a : specifier.value;
            if (resolution.resolved.type === 'error') {
                chunkImports[chunkImportKey] = {
                    resolved: { type: 'error', text: resolution.resolved.text },
                    messages: resolution.messages.slice(),
                };
                return;
            }
            if (resolution.resolved.type === 'external') {
                const isResolvedToBare = !(0, url_2.tryParseURL)(resolution.resolved.specifierOrURL);
                if (isResolvedToBare) {
                    // Only bare specifier may resolved to bare
                    (0, asserts_1.asserts)(!specifier.resolved, `Something wrong with rewriting and resolve ${specifier.value}`);
                    return;
                }
                chunkImports[chunkImportKey] = {
                    resolved: {
                        type: 'external',
                        specifierOrURL: resolution.resolved.specifierOrURL,
                    },
                    messages: resolution.messages.slice(),
                };
                return;
            }
            (0, asserts_1.asserts)(resolution.resolved.type === 'module');
            const { url: resolvedURL } = resolution.resolved;
            const inspectRecord = await this._getOrCreateInspectRecord(resolvedURL, context);
            await inspectRecord.inspect;
            const resolvedChunk = (_b = this._moduleRecords[resolvedURL.href]) === null || _b === void 0 ? void 0 : _b.chunkId;
            if (resolvedChunk) {
                chunkImports[chunkImportKey] = {
                    resolved: {
                        type: 'chunk',
                        id: resolvedChunk,
                    },
                    messages: resolution.messages.slice(),
                };
            }
            else {
                this._logger.debug(`We're missing the chunk ${resolvedURL.href}, referenced as '${specifier.value}'.`);
            }
            return inspectRecord;
        });
        const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
        (0, asserts_1.asserts)(chunk);
        chunk.imports = Object.keys(chunkImports).sort().reduce((result, k) => {
            result[k] = chunkImports[k];
            return result;
        }, {});
        return depRecords;
    }
    async _inspect(url, mTimestamp) {
        const resolver = this._createResolver();
        let jsSource;
        let specifiers;
        let type;
        try {
            let mod = await this._modLo.load(url);
            type = mod.type;
            ({
                source: jsSource,
                moduleSpecifiers: specifiers,
            } = await mod.systemjs(resolver));
        }
        catch (err) {
            this._logger.debug(`We encountered an load error: ${err}`);
            const chunkId = await this._addErroneousChunk(url, err);
            const moduleRecord = {
                erroneous: true,
                mTimestamp,
                chunkId,
            };
            this._moduleRecords[url.href] = moduleRecord;
            return moduleRecord;
        }
        const chunkId = await this._addChunk(url, jsSource);
        const moduleRecord = {
            mTimestamp,
            chunkId,
            imports: specifiers,
            type,
        };
        this._moduleRecords[url.href] = moduleRecord;
        return moduleRecord;
    }
    _createResolver() {
        let nSpecifier = 0;
        const resolver = (specifier) => {
            if ((0, specifier_1.isBareSpecifier)(specifier)) {
                // If it's bare specifier, we do not rewrite it.
                return undefined;
            }
            const rewritten = `__unresolved_${nSpecifier}`;
            ++nSpecifier;
            return rewritten;
        };
        return resolver;
    }
    async _addChunk(url, jsSource) {
        const { code, map } = jsSource;
        const chunkId = await this._chunkWriter.addChunk(url, code, this._sourceMaps ? map : undefined);
        return chunkId;
    }
    async _addErroneousChunk(url, err) {
        const reporterModuleSource = `
// This module is auto-generated to report error emitted when try to load module ${url} at runtime.
throw new Error(\`${String(err)}\`);
        `;
        const data64URL = new url_1.URL(`data:text/javascript,${encodeURIComponent(reporterModuleSource)}`);
        // Should not fail
        const reporterModule = await this._modLo.load(data64URL);
        const { source: reporterModuleSourceTransformed } = await reporterModule.systemjs();
        const chunkId = this._chunkWriter.addChunk(data64URL, reporterModuleSourceTransformed.code, reporterModuleSourceTransformed.map);
        return chunkId;
    }
    async _resolve(specifier, parentURL, type) {
        const messages = [];
        const specifierValue = specifier.value;
        try {
            const resolved = await this._modLo.resolve(specifierValue, parentURL, type);
            if (this._verbose) {
                if (resolved.isExternal) {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as external dependency ${resolved.specifierOrURL}.`);
                }
                else {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as ${resolved.url}.`);
                }
            }
            return {
                resolved: resolved.isExternal ? {
                    type: 'external',
                    specifierOrURL: resolved.specifierOrURL,
                } : {
                    type: 'module',
                    url: resolved.url,
                },
                messages,
            };
        }
        catch (err) {
            this._logger.debug(`Failed to resolve '${specifier.value}' from '${parentURL.href}'(module type: ${type}). Reason: ${err}`);
            // messages.push({
            //     level: 'error',
            //     text: i18nTranslate(
            //         'quick_pack_failed_to_resolve',
            //         { specifier: specifierValue, parentURL: parentURL.href, cause: err },
            //     ),
            // });
            // If we can't resolve a bare specifier from CommonJS, treat it as external
            if ((0, specifier_1.isBareSpecifier)(specifier.value) && type === 'commonjs') {
                return {
                    resolved: {
                        type: 'module',
                        url: new url_1.URL(`data:text/javascript,${encodeURIComponent(`
                        export const ${share_1.cjsMetaUrlExportName} = '${specifier.value}';
                        `)}`),
                    },
                    messages,
                };
            }
            // For otherwise errors, we deliver them to "messages".
            if (specifierValue.includes('/')) {
                const lastPortion = specifierValue.split('/').pop();
                if (lastPortion && !lastPortion.includes('.')) {
                    messages.push({
                        level: 'warn',
                        text: (0, i18n_1.i18nTranslate)('resolve_error_hint_extension'),
                    });
                }
            }
            return {
                resolved: {
                    type: 'error',
                    text: String(err),
                },
                messages,
            };
        }
    }
    _serializeMainRecord() {
        return {
            modules: Object.entries(this._moduleRecords).reduce((result, [key, moduleRecord]) => {
                if (moduleRecord) {
                    result[key] = moduleRecord;
                }
                return result;
            }, {}),
        };
    }
    _deserializeMainRecord(serialized) {
        const moduleRecords = this._moduleRecords = serialized.modules;
        for (const moduleRecord of Object.values(moduleRecords)) {
            if (!moduleRecord.erroneous && moduleRecord.resolutions) {
                for (const resolution of moduleRecord.resolutions) {
                    if (resolution.resolved.type === 'module') {
                        resolution.resolved.url = new url_1.URL(resolution.resolved.url);
                    }
                }
            }
        }
    }
    /**
     * This method should be called after all modules are instantiated.
     */
    _getDepsGraphFromModuleRecords() {
        const depGraphs = {};
        for (let k in this._moduleRecords) {
            const mr = this._moduleRecords[k];
            if (mr.resolutions) {
                depGraphs[k] = mr.resolutions.map((res) => {
                    const resolved = res.resolved;
                    switch (resolved.type) {
                        case 'module':
                            if ((0, creator_programming_common_1.isCjsInteropUrl)(resolved.url)) {
                                return (0, creator_programming_common_1.getCjsInteropTarget)(resolved.url).href;
                            }
                            return resolved.url.href;
                        case 'external':
                            return resolved.specifierOrURL;
                        case 'error':
                        default:
                            return undefined;
                    }
                    // NOTE: filter undefined value and de-duplication
                }).filter((depPath, index, arr) => depPath !== undefined && arr.indexOf(depPath) === index);
            }
        }
        return depGraphs;
    }
}
exports.QuickPack = QuickPack;
//# sourceMappingURL=quick-pack.js.map