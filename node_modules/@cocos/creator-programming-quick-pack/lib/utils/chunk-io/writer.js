"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChunkWriter = void 0;
const base_1 = require("./base");
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const asserts_1 = require("@cocos/creator-programming-common/lib/asserts");
const url_1 = require("url");
const relateurl_1 = __importDefault(require("relateurl"));
const crypto_1 = __importDefault(require("crypto"));
class ChunkWriter extends base_1.ChunkIOBase {
    constructor({ chunkHomePath: sourceCacheDir, importMapPath, resolutionDetailMapPath, logger, }) {
        super({ chunkHomePath: sourceCacheDir });
        this._logger = logger;
        this._importMapPath = importMapPath;
        this._resolutionDetailMapPath = resolutionDetailMapPath;
    }
    async persist() {
        await this._writeMaps();
    }
    async clear() {
        const importMapPath = this._importMapPath;
        try {
            await fs_extra_1.default.unlink(importMapPath);
        }
        catch (err) {
            this._logger.debug(`Failed to delete import map at ${importMapPath}: ${err}`);
        }
        await super.clear();
    }
    async getChunk(id) {
        return this._build.chunks[id];
    }
    async addChunk(moduleURL, code, map) {
        const chunkId = this._generateChunkId(moduleURL, code);
        const chunkCodeFilePath = this._calculateChunkCodeFileName(chunkId);
        const timestamp = Date.now();
        this._build.chunks[chunkId] = {
            imports: {},
            timestamp,
        };
        // const metadataCacheFile = this._getMetadataCacheFile(qpLocation);
        let sourceMappingURL;
        let serializedMap;
        if (map) {
            serializedMap = typeof map === 'string'
                ? map
                : JSON.stringify(map);
            sourceMappingURL = `${path_1.default.basename(chunkCodeFilePath)}.map`;
        }
        const codeWithMap = sourceMappingURL
            ? `${code}\n//# sourceMappingURL=${sourceMappingURL}`
            : code;
        await Promise.all([
            // Write metadata
            // fs.outputFile(metadataCacheFile, JSON.stringify(metadata, undefined, 2), { encoding: 'utf8' }),
            // Write code
            fs_extra_1.default.outputFile(chunkCodeFilePath, codeWithMap, { encoding: 'utf8' }),
            // Write map
            serializedMap
                ? fs_extra_1.default.outputFile(`${chunkCodeFilePath}.map`, serializedMap, { encoding: 'utf8' })
                : undefined,
        ]);
        return chunkId;
    }
    async removeChunk(id) {
        delete this._build.chunks[id];
    }
    setEntryChunks(entryChunks) {
        this._build.entries = entryChunks;
    }
    _generateChunkId(moduleURL, code) {
        const shasum = crypto_1.default.createHash('sha1');
        shasum.update(moduleURL.href);
        const hash = shasum.digest('hex');
        (0, asserts_1.asserts)(hash.length === 40);
        return hash;
    }
    async _writeMaps() {
        const importMapFileURL = (0, url_1.pathToFileURL)(this._importMapPath);
        const resolutionDetailMapFileURL = (0, url_1.pathToFileURL)(this._resolutionDetailMapPath);
        const { importMap, resolutionDetailMap: resolutionDetailMap, } = this._buildMaps(importMapFileURL, resolutionDetailMapFileURL);
        await fs_extra_1.default.outputJson((0, url_1.fileURLToPath)(importMapFileURL), importMap, { spaces: 2, encoding: 'utf8', });
        await fs_extra_1.default.outputJson((0, url_1.fileURLToPath)(resolutionDetailMapFileURL), resolutionDetailMap, { spaces: 2, encoding: 'utf8', });
    }
    _buildMaps(importMapFileURL, resolutionDetailMapFileURL) {
        const { chunks, entries, } = this._build;
        const resolutionDetailMap = {};
        const importMapRelate = new relateurl_1.default(importMapFileURL.href);
        const resolutionDetailMapRelate = new relateurl_1.default(resolutionDetailMapFileURL.href);
        const getChunkRelativePathFromImportMap = (chunkId) => {
            // Can happen when reload A -> B
            // A is unchanged, but can not load B(since `forceAll: true`)
            // A's dep records are not clear
            (0, asserts_1.asserts)(chunkId in chunks, 'Something went wrong: module A depends on B, but B is not correctly generated.');
            const chunkSourceFile = this._calculateChunkCodeFileName(chunkId);
            const relativePath = importMapRelate.relate((0, url_1.pathToFileURL)(chunkSourceFile).href);
            return `./${relativePath}`;
        };
        const getChunkRelativePathFromResolutionDetailMap = (chunkId) => {
            // Can happen when reload A -> B
            // A is unchanged, but can not load B(since `forceAll: true`)
            // A's dep records are not clear
            (0, asserts_1.asserts)(chunkId in chunks, 'Something went wrong: module A depends on B, but B is not correctly generated.');
            const chunkSourceFile = this._calculateChunkCodeFileName(chunkId);
            const relativePath = resolutionDetailMapRelate.relate((0, url_1.pathToFileURL)(chunkSourceFile).href);
            return `./${relativePath}`;
        };
        const importMap = {};
        importMap.imports = {};
        const imports = importMap.imports;
        const involvedModules = [];
        for (const [alias, chunkId] of Object.entries(entries)) {
            imports[alias] = getChunkRelativePathFromImportMap(chunkId);
            involvedModules.unshift(chunkId);
        }
        importMap.scopes = {};
        const scopes = importMap.scopes;
        const visited = new Set();
        while (involvedModules.length !== 0) {
            const chunkId = involvedModules.pop();
            if (visited.has(chunkId)) {
                continue;
            }
            visited.add(chunkId);
            if (!(chunkId in chunks)) {
                this._logger.debug(`Chunk ${chunkId} is absent. Skipped it.`);
                continue;
            }
            const chunk = chunks[chunkId];
            const importsEntries = Object.entries(chunk.imports);
            if (importsEntries.length === 0) {
                continue;
            }
            const chunkPathFromImportMap = getChunkRelativePathFromImportMap(chunkId);
            const specifierMap = scopes[chunkPathFromImportMap] = {};
            const chunkPathFromResolutionDetailMap = getChunkRelativePathFromResolutionDetailMap(chunkId);
            for (const [specifier, { resolved, messages }] of importsEntries) {
                const getOrCreateResolutionDetail = () => { var _a, _b; var _c; return (_b = (_c = ((_a = resolutionDetailMap[chunkPathFromResolutionDetailMap]) !== null && _a !== void 0 ? _a : (resolutionDetailMap[chunkPathFromResolutionDetailMap] = {})))[specifier]) !== null && _b !== void 0 ? _b : (_c[specifier] = {}); };
                if (resolved.type === 'chunk') {
                    specifierMap[specifier] = getChunkRelativePathFromImportMap(resolved.id);
                    involvedModules.push(resolved.id);
                }
                else if (resolved.type === 'external') {
                    specifierMap[specifier] = resolved.specifierOrURL;
                }
                else if (resolved.type === 'error') {
                    getOrCreateResolutionDetail().error = resolved.text;
                }
                if (messages.length !== 0) {
                    getOrCreateResolutionDetail().messages = messages.slice();
                }
            }
        }
        return {
            importMap,
            resolutionDetailMap,
        };
    }
}
exports.ChunkWriter = ChunkWriter;
//# sourceMappingURL=writer.js.map