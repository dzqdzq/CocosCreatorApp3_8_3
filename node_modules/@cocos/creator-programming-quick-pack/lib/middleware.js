"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPackMiddleware = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const url_1 = require("url");
const constants_1 = require("./constants");
const proper_lockfile_1 = __importDefault(require("proper-lockfile"));
class QuickPackMiddleware {
    constructor(workspace) {
        this._lockedFiles = [];
        this._workspace = workspace;
        this._workspaceURL = (0, url_1.pathToFileURL)(path_1.default.join(workspace, path_1.default.sep));
    }
    get workspace() {
        return this._workspace;
    }
    get workspaceURL() {
        return this._workspaceURL;
    }
    get mainRecordPath() {
        return path_1.default.join(this._workspace, 'main-record.json');
    }
    get assemblyRecordPath() {
        return path_1.default.join(this._workspace, 'assembly-record.json');
    }
    get chunkHomePath() {
        return (0, url_1.fileURLToPath)(new URL(constants_1.CHUNK_HOME_RELATIVE_URL, this._workspaceURL));
    }
    get importMapPath() {
        return (0, url_1.fileURLToPath)(new URL(constants_1.IMPORT_MAP_RELATIVE_URL, this._workspaceURL));
    }
    get resolutionDetailMapPath() {
        return (0, url_1.fileURLToPath)(new URL(constants_1.RESOLUTION_DETAIL_MAP_RELATIVE_URL, this._workspaceURL));
    }
    async lock() {
        const filesToLock = [
            this.assemblyRecordPath,
            this.importMapPath,
        ];
        for (let file of filesToLock) {
            if (fs_1.default.existsSync(file)) {
                // NOTE: proper-lockfile will create a lock folder to mark the file as locked, and keep updating the mtime of this folder.
                // If the process throws an exception or is blocked, mtime will stop updating and the stale lock will become invalid.
                await proper_lockfile_1.default.lock(file, { retries: { forever: true }, stale: 5000 });
                if (!this._lockedFiles.includes(file)) {
                    this._lockedFiles.push(file);
                }
            }
        }
    }
    async unlock() {
        for (const file of this._lockedFiles) {
            if (fs_1.default.existsSync(file) && await proper_lockfile_1.default.check(file)) {
                await proper_lockfile_1.default.unlock(file);
            }
        }
        this._lockedFiles.length = 0;
    }
}
exports.QuickPackMiddleware = QuickPackMiddleware;
//# sourceMappingURL=middleware.js.map