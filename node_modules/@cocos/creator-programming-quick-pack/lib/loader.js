"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPackLoaderContext = exports.QuickPackLoader = exports.ResourceNotFoundError = void 0;
const loader_context_1 = require("./utils/loader-context");
Object.defineProperty(exports, "QuickPackLoaderContext", { enumerable: true, get: function () { return loader_context_1.LoaderContext; } });
const base_1 = require("./utils/chunk-io/base");
const url_1 = require("url");
const i18n_1 = require("@cocos/creator-programming-common/lib/i18n");
const middleware_1 = require("./middleware");
const fs_extra_1 = __importDefault(require("fs-extra"));
const constants_1 = require("./constants");
class ResourceNotFoundError extends Error {
    constructor(id) {
        super((0, i18n_1.i18nTranslate)('quick_pack_loader_resource_not_found_error', { id }));
    }
}
exports.ResourceNotFoundError = ResourceNotFoundError;
const baseURL = new url_1.URL('pack:///');
class QuickPackLoader {
    constructor(context, options = {}) {
        this._timestampsCache = {};
        this._middleware = new middleware_1.QuickPackMiddleware(context.workspace);
        this._chunkReader = new base_1.ChunkIOBase({ chunkHomePath: this._middleware.chunkHomePath });
    }
    get importMapURL() {
        return constants_1.IMPORT_MAP_RELATIVE_URL;
    }
    get resolutionDetailMapURL() {
        return constants_1.RESOLUTION_DETAIL_MAP_RELATIVE_URL;
    }
    async lock() {
        await this._middleware.lock();
    }
    async unlock() {
        await this._middleware.unlock();
    }
    async loadAny(url) {
        // First, normalize it
        const absolute = new url_1.URL(url, baseURL);
        absolute.search = ''; // Discard any search params
        switch (absolute.href) {
            case new url_1.URL(constants_1.IMPORT_MAP_RELATIVE_URL, baseURL).href:
                return {
                    type: 'json',
                    json: await this.loadImportMap(),
                };
            case new url_1.URL(constants_1.RESOLUTION_DETAIL_MAP_RELATIVE_URL, baseURL).href:
                return {
                    type: 'json',
                    json: await this.loadResolutionDetailMap(),
                };
            default:
                return {
                    type: 'chunk',
                    chunk: await this.loadChunk(url),
                };
        }
    }
    /**
     * Loads the import map.
     * @returns The import map object.
     */
    async loadImportMap() {
        return await fs_extra_1.default.readJson(this._middleware.importMapPath);
    }
    /**
     * Loads the resolution detail map.
     * @returns The resolution detail map object.
     */
    async loadResolutionDetailMap() {
        return await fs_extra_1.default.readJson(this._middleware.resolutionDetailMapPath);
    }
    /**
     * Load specific chunk.
     * @param url The URL of the chunk, if relative, would be resolved from `this.baseURL`.
     * @returns The chunk info.
     */
    async loadChunk(url) {
        const resourceId = this.getChunkId(url);
        return await this.loadChunkFromId(resourceId);
    }
    /**
     * Gets the opacity, unique ID of the chunk, to query timestamp or load the chunk.
     * @param url URL of the chunk.
     * @returns The chunk ID.
     */
    getChunkId(url) {
        // First, normalize it
        const absolute = new url_1.URL(url, baseURL);
        absolute.search = ''; // Discard any search params
        // Next, deduce a relative reference from it
        const baseHref = baseURL.href;
        const href = absolute.href;
        let normalizedReference = '';
        if (href.startsWith(baseHref)) {
            normalizedReference = href.slice(baseHref.length);
        }
        if (!normalizedReference) {
            throw new Error(`Bad pack resource URL: ${url}`);
        }
        return normalizedReference;
    }
    /**
     * Load specific chunk.
     * @param id The chunk ID.
     * @returns The chunk ID.
     */
    async loadChunkFromId(id) {
        const file = (0, url_1.fileURLToPath)(new url_1.URL(id, this._middleware.workspaceURL));
        return {
            type: 'file',
            path: file,
        };
    }
    /**
     * 获取指定资源的 mtime 时间戳。若不存在则返回负值。
     */
    async queryTimestamp(resource) {
        var _a;
        return (_a = this._timestampsCache[resource]) !== null && _a !== void 0 ? _a : -1;
    }
    /**
     * 获取指定所有资源的 mtime 时间戳。不存在的资源将返回负值。
     */
    async queryTimestamps(resources) {
        return resources.map((resource) => { var _a; return (_a = this._timestampsCache[resource]) !== null && _a !== void 0 ? _a : -1; });
    }
    async reload() {
        const serializedAssemblyRecord = await fs_extra_1.default.readJson(this._middleware.assemblyRecordPath);
        this._chunkReader.deserializeRecord(serializedAssemblyRecord);
        this._timestampsCache = Object.entries(await this._chunkReader.queryAllTimestamps()).reduce((result, [chunkRelativeURL, timestamp]) => {
            result[`${constants_1.CHUNK_HOME_RELATIVE_URL}${chunkRelativeURL}`] = timestamp;
            return result;
        }, {});
    }
}
exports.QuickPackLoader = QuickPackLoader;
//# sourceMappingURL=loader.js.map