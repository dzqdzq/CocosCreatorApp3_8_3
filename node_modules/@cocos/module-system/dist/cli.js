#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const build_1 = require("./build");
commander_1.program
    .name('ccms')
    .description('CLI to support a module system for Cocos engine')
    .version((0, fs_extra_1.readJsonSync)((0, path_1.join)(__dirname, '../package.json')).version);
commander_1.program
    .command('init')
    .description(`init interface declaration of module system to the path 'CURRENT_PATH/@types/module-system.d.ts'`)
    .action(() => {
    const cwd = process.cwd();
    const typesPath = (0, path_1.join)(cwd, '@types');
    (0, fs_extra_1.ensureDirSync)(typesPath);
    (0, fs_extra_1.copyFileSync)((0, path_1.join)(__dirname, '../module-system.d.ts'), (0, path_1.join)(typesPath, './module-system.d.ts'));
});
commander_1.program
    .command('build')
    .description('build module system to the specified platform.')
    .requiredOption('-p, --platform <string>', `target platform such as 'windows', 'web-mobile', etc.`)
    .requiredOption('-o, --out <string>', 'the path of output.')
    .option('-m, --minify', `whether to minify the output lib.`)
    .option('-s, --source-map', 'whether to generate source map of the lib.')
    .option('-h, --hmr', 'whether to build lib with a HMR extra.')
    .action(options => {
    options.minify = options.minify ?? false;
    options.sourceMap = options.sourceMap ?? false;
    options.hmr = options.hmr ?? false;
    return (0, build_1.build)(options);
});
commander_1.program.parse();
//# sourceMappingURL=cli.js.map