import { Context } from './config-interface';
import * as ConfigInterface from './config-interface';
import { PlatformType as _PlatformType } from "../../modularize/lib/index";
export { ConfigInterface };
/**
 * Query any any stats of the engine.
 * @group Merged Types
 */
export declare class StatsQuery {
  /**
   * @param engine Path to the engine root.
   */
  static create(engine: string): Promise<StatsQuery>;
  /**
   * Constant manager for engine and user.
   */
  constantManager: StatsQuery.ConstantManager;
  /**
   * Gets the path to the engine root.
   */
  get path(): string;
  /**
   * Gets the path to tsconfig.
   */
  get tsConfigPath(): string;
  /**
   * Gets all optimzie decorators
   */
  getOptimizeDecorators(): ConfigInterface.IOptimizeDecorators;
  /**
   * Gets all features defined.
   */
  getFeatures(): string[];
  /**
   * Returns if the specified feature is defined.
   * @param feature Feature ID.
   */
  hasFeature(feature: string): boolean;
  /**
   * Gets all feature units included in specified features.
   * @param featureIds Feature ID.
   */
  getUnitsOfFeatures(featureIds: string[]): string[];
  getIntrinsicFlagsOfFeatures(featureIds: string[]): Record<string, number | boolean | string>;
  /**
   * Gets all feature units in their names.
   */
  getFeatureUnits(): string[];
  /**
   * Gets the path to source file of the feature unit.
   * @param moduleId Name of the feature unit.
   */
  getFeatureUnitFile(featureUnit: string): string;
  /**
   * Gets all editor public modules in their names.
   */
  getEditorPublicModules(): string[];
  /**
   * Gets the path to source file of the editor-public module.
   * @param moduleName Name of the public module.
   */
  getEditorPublicModuleFile(moduleName: string): string;
  /**
   * Gets the source of `'cc'`.
   * @param featureUnits Involved feature units.
   * @param mapper If exists, map the feature unit name into another module request.
   */
  evaluateIndexModuleSource(featureUnits: string[], mapper?: (featureUnit: string) => string): string;
  /**
   * Evaluates the source of `'internal-constants'`(`'cc/env'`),
   * @param context
   */
  evaluateEnvModuleSourceFromRecord(record: Record<string, unknown>): string;
  /**
   * Evaluates module overrides under specified context.
   * @param context
   */
  evaluateModuleOverrides(context: Context): Record<string, string>;
  private static _readModulesInDir;
  private static _baseNameToFeatureUnitName;
  private static _editorBaseNameToModuleName;
  private constructor();
  private _evalTest;
  private _evalPathTemplate;
  private _initialize;
  private _engine;
  private _index;
  private _features;
  private _config;
  private _featureUnits;
  private _editorPublicModules;
}
/**
 * @group Merged Types
 */
export declare namespace StatsQuery {
  namespace ConstantManager {
    type PlatformType = _PlatformType;
    type IPlatformConfig = { [key in PlatformType]: boolean };
    interface IInternalFlagConfig {
      SERVER_MODE: boolean;
      NOT_PACK_PHYSX_LIBS: boolean;
      WEBGPU: boolean;
      /**
       * Native code (wasm/asmjs) bundle mode, 0: asmjs, 1: wasm, 2: both
       * @default 2
       */
      NATIVE_CODE_BUNDLE_MODE: number;
      /**
       * An internal constant to indicate whether we cull the meshopt wasm module and asm.js module.
       *
       * @default false
       */
      CULL_MESHOPT: boolean;
      /**
       * An internal constant to indicate whether we use wasm assets as minigame subpackage.
       * This is useful when we need to reduce code size.
       */
      WASM_SUBPACKAGE: boolean;
    }
    interface IPublicFlagConfig {
      DEBUG: boolean;
      NET_MODE: number;
    }
    interface IFlagConfig extends IInternalFlagConfig, IPublicFlagConfig {}
    interface IModeConfig {
      EDITOR: boolean;
      PREVIEW: boolean;
      BUILD: boolean;
      TEST: boolean;
    }
    interface IConstantOptions {
      platform: PlatformType;
      flagConfig: IFlagConfig;
    }
    type ModeType = keyof IModeConfig;
    type FlagType = keyof IFlagConfig;
    interface BuildTimeConstants extends IPlatformConfig, IFlagConfig, IModeConfig {}
    interface CCEnvConstants extends IPlatformConfig, IPublicFlagConfig, IModeConfig {}
    type ValueType = boolean | number;
    interface ConstantOptions {
      mode: ModeType;
      platform: PlatformType;
      flags: Partial<Record<FlagType, ValueType>>;
    }
  }
  class ConstantManager {
    private _engineRoot;
    constructor(engineRoot: string);
    exportDynamicConstants({
      mode,
      platform,
      flags
    }: ConstantManager.ConstantOptions): string;
    genBuildTimeConstants(options: ConstantManager.ConstantOptions): ConstantManager.BuildTimeConstants;
    genCCEnvConstants(options: ConstantManager.ConstantOptions): ConstantManager.CCEnvConstants;
    exportStaticConstants({
      mode,
      platform,
      flags
    }: ConstantManager.ConstantOptions): string;
    genInternalConstants(): string;
    genCCEnv(): string;
    private _genConstantDeclaration;
    private _getConfig;
    private _hasCCGlobal;
    private _hasDynamic;
    private _evalExpression;
    private _applyOptionsToConfig;
  }
}