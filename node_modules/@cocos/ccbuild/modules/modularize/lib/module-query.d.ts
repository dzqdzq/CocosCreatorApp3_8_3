import { ModuleConfig, PlatformType } from './module-config';
export interface ModuleQueryContext {
  /**
   * The engine root path.
   */
  engine: string;
  /**
   * The platform to resolve conditional export.
   */
  platform: PlatformType;
  /**
   * The custom export condition.
   * The higher the array is sorted, the higher the priority is.
   *
   * @example
   * ```ts
   * [ 'webgl1',  'cannon' ]  // the backend of 'gfx' and 'physics' modules.
   * ```
   */
  customExportConditions?: string[];
}
/**
 * The module info manager.
 */
export declare class ModuleQuery {
  private _context;
  private _cachedModuleName2PkgJson?;
  private _resolvedCache;
  private _cachedHasEditorSpecificExport;
  constructor(context: ModuleQueryContext);
  /**
   * Get all modules' name defined in engine workspaces.
   */
  getAllModules(): Promise<string[]>;
  /**
   * Get modules' all exports by module name.
   */
  getExports(moduleName: string): Promise<string[]>;
  /**
   * Get all the modules' exports.
   */
  getAllExports(): Promise<string[]>;
  /**
   * Get the map from module name to module path.
   */
  getExportMap(): Promise<Record<string, string>>;
  /**
   * Resolve module package.json path by module name.
   */
  resolvePackageJson(moduleName: string): Promise<string>;
  /**
   * Get module config by module name.
   */
  getConfig(moduleName: string): Promise<ModuleConfig>;
  /**
   * Resolve module entry path by import source.
   */
  resolveExport(source: string): Promise<string | void>;
  /**
   * To detect whether the module has a './editor' export.
   * @param moduleName
   */
  hasEditorSpecificExport(moduleName: string): Promise<boolean>;
  private _ensureModuleName2PkgJson;
  private _isWebPlatform;
  private _isMiniGamePlatform;
  private _isNativePlatform;
}