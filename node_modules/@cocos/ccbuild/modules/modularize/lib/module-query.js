"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModuleQuery = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const platform_config_1 = require("./platform-config");
const glob_1 = __importDefault(require("glob"));
const utils_1 = require("../../utils/lib/index.js");
/**
 * The module info manager.
 */
class ModuleQuery {
  constructor(context) {
    this._resolvedCache = {}; // module name to module entry file path
    this._cachedHasEditorSpecificExport = {};
    this._context = context;
  }
  /**
   * Get all modules' name defined in engine workspaces.
   */
  async getAllModules() {
    await this._ensureModuleName2PkgJson();
    if (!this._cachedModuleName2PkgJson) {
      throw new Error(`Failed to resolve engine modules.`);
    }
    return Object.keys(this._cachedModuleName2PkgJson);
  }
  /**
   * Get modules' all exports by module name.
   */
  async getExports(moduleName) {
    const config = await this.getConfig(moduleName);
    const moduleExports = [];
    if (!config.exports) {
      return moduleExports;
    }
    for (let exportPort in config.exports) {
      if (exportPort === '.' || exportPort === './') {
        moduleExports.push(moduleName);
      } else {
        exportPort = utils_1.ps.join(moduleName, exportPort);
        if (exportPort.endsWith('/')) {
          exportPort = exportPort.slice(0, -1);
        }
        moduleExports.push(exportPort);
      }
    }
    return moduleExports;
  }
  /**
   * Get all the modules' exports.
   */
  async getAllExports() {
    const allModules = await this.getAllModules();
    const allExports = [];
    for (const moduleName of allModules) {
      allExports.push(...(await this.getExports(moduleName)));
    }
    return allExports;
  }
  /**
   * Get the map from module name to module path.
   */
  async getExportMap() {
    const allExports = await this.getAllExports();
    const map = {};
    for (const exportPort of allExports) {
      const resolved = await this.resolveExport(exportPort);
      if (resolved) {
        map[exportPort] = resolved;
      }
    }
    return map;
  }
  /**
   * Resolve module package.json path by module name.
   */
  async resolvePackageJson(moduleName) {
    await this._ensureModuleName2PkgJson();
    if (!this._cachedModuleName2PkgJson) {
      throw new Error(`Failed to resolve engine modules.`);
    }
    const pkgJson = this._cachedModuleName2PkgJson[moduleName];
    if (!pkgJson) {
      throw new Error(`Failed resolve package json of module: ${moduleName}.`);
    }
    return pkgJson;
  }
  /**
   * Get module config by module name.
   */
  async getConfig(moduleName) {
    const modulePath = await this.resolvePackageJson(moduleName);
    if (!modulePath) {
      throw new Error(`Failed to resolve engine module: ${moduleName}.`);
    }
    return await fs_extra_1.default.readJson(modulePath);
  }
  /**
   * Resolve module entry path by import source.
   */
  async resolveExport(source) {
    var _a;
    if (this._resolvedCache[source]) {
      return this._resolvedCache[source];
    }
    if (source.startsWith('.')) {
      // no relative path resolve
      return;
    }
    const allModules = await this.getAllModules();
    const moduleName = allModules.find(moduleName => source.startsWith(moduleName));
    if (!moduleName) {
      return;
    }
    let exportPort = '.';
    if (utils_1.ps.relative(moduleName, source) !== '') {
      exportPort = './' + utils_1.ps.relative(moduleName, source);
    }
    const moduleRootDir = utils_1.ps.dirname(await this.resolvePackageJson(moduleName));
    const config = await this.getConfig(moduleName);
    // NOTE: '.' export port can cover all export ports.
    const rootExport = (_a = config.exports) === null || _a === void 0 ? void 0 : _a[exportPort];
    if (!rootExport) {
      return;
    }
    // custom condition
    if (this._context.customExportConditions) {
      for (const condition of this._context.customExportConditions) {
        if (typeof rootExport[condition] === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport[condition]);
        }
      }
    }
    // platform condition
    const platform = this._context.platform.toLowerCase();
    if (this._isWebPlatform(platform)) {
      if (typeof rootExport.web === 'string') {
        return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.web);
      } else if (typeof rootExport.web === 'object') {
        if (typeof rootExport.web[platform] === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.web[platform]);
        } else if (typeof rootExport.web.default === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.web.default);
        }
      }
    } else if (this._isMiniGamePlatform(platform)) {
      if (typeof rootExport.minigame === 'string') {
        return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.minigame);
      } else if (typeof rootExport.minigame === 'object') {
        if (typeof rootExport.minigame[platform] === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.minigame[platform]);
        } else if (typeof rootExport.minigame.default === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.minigame.default);
        }
      }
    } else if (this._isNativePlatform(platform)) {
      if (typeof rootExport.native === 'string') {
        return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.native);
      } else if (typeof rootExport.native === 'object') {
        if (typeof rootExport.native[platform] === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.native[platform]);
        } else if (typeof rootExport.native.default === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.native.default);
        }
      }
    }
    // types condition
    if (typeof rootExport.types === 'string') {
      return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.types);
    } else if (typeof rootExport === 'string') {
      return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport);
    } else {
      throw new Error(`Cannot resolve export: '${source}'.`);
    }
  }
  /**
   * To detect whether the module has a './editor' export.
   * @param moduleName
   */
  async hasEditorSpecificExport(moduleName) {
    var _a;
    if (typeof this._cachedHasEditorSpecificExport[moduleName] === 'boolean') {
      return this._cachedHasEditorSpecificExport[moduleName];
    }
    const pkgJson = await this.resolvePackageJson(moduleName);
    const pkg = await fs_extra_1.default.readJson(pkgJson);
    return this._cachedHasEditorSpecificExport[moduleName] = typeof ((_a = pkg.exports) === null || _a === void 0 ? void 0 : _a['./editor']) !== 'undefined';
  }
  async _ensureModuleName2PkgJson() {
    if (this._cachedModuleName2PkgJson) {
      return;
    }
    const enginePkg = await fs_extra_1.default.readJson(utils_1.ps.join(this._context.engine, 'package.json'));
    let pkgFiles = [];
    if (enginePkg.workspaces) {
      for (const ws of enginePkg.workspaces) {
        pkgFiles.push(...glob_1.default.sync(utils_1.ps.join(this._context.engine, ws), {
          ignore: '**/node_modules/**/*'
        }));
      }
    }
    pkgFiles = pkgFiles.map(file => {
      if (fs_extra_1.default.statSync(file).isDirectory()) {
        const pkgFile = utils_1.ps.join(file, 'package.json');
        if (fs_extra_1.default.existsSync(pkgFile)) {
          return pkgFile;
        }
      }
      return file;
    });
    pkgFiles = pkgFiles.filter(file => file.endsWith('package.json'));
    pkgFiles = pkgFiles.filter((file, index) => pkgFiles.indexOf(file) === index);
    this._cachedModuleName2PkgJson = {};
    for (const pkg of pkgFiles) {
      const name = (await fs_extra_1.default.readJson(pkg)).name;
      this._cachedModuleName2PkgJson[name] = pkg;
    }
  }
  _isWebPlatform(platform) {
    return platform.toUpperCase() in platform_config_1.WebPlatform || platform.toUpperCase() === 'HTML5';
  }
  _isMiniGamePlatform(platform) {
    return platform.toUpperCase() in platform_config_1.MinigamePlatform;
  }
  _isNativePlatform(platform) {
    return platform.toUpperCase() in platform_config_1.NativePlatform || platform.toUpperCase() === 'NATIVE';
  }
}
exports.ModuleQuery = ModuleQuery;