"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EngineBuilder = void 0;
const fs = __importStar(require("fs-extra"));
const ps = __importStar(require("path"));
const transformer_1 = require("../../../transformer/lib/index.js");
const stats_query_1 = require("../../../stats-query/lib/index.js");
const utils_1 = require("../../../utils/lib/index.js");
const json5 = __importStar(require("json5"));
const dedent_1 = __importDefault(require("dedent"));
const glob_1 = require("glob");
const field_decorator_helper_1 = require("./field-decorator-helper");
const external_wasm_loader_1 = require("./plugins/external-wasm-loader");
const node_module_loader_1 = require("./plugins/node-module-loader");
const module_query_plugin_1 = require("./plugins/module-query-plugin");
const modularize_1 = require("../../../modularize/lib/index.js");
var babel = transformer_1.babel.core;
var t = babel.types;
var traverse = babel.traverse;
const pluginSyntaxTS = transformer_1.babel.plugins.syntaxTS;
const syntaxDecorators = transformer_1.babel.plugins.syntaxDecorators;
class EngineBuilder {
  constructor() {
    this._entries = [];
    this._entriesForPass2 = new Set();
    this._virtual2code = {};
    this._virtualOverrides = {};
    this._buildResult = {};
    this._resolveExtension = ['.ts', '.js', '.json']; // not an option
    // TODO: for now OH global interface conflict with Rect and Path, struct
    // so we need to rename them.
    this._renameMap = {
      Rect: 'RectAlias',
      Path: 'PathAlias',
      struct: 'structAlias'
    };
    this._fieldDecoratorHelper = new field_decorator_helper_1.FieldDecoratorHelper();
    this._plugins = [];
    this._excludeTransform = [/native\/external\//];
    this._handledCache = {};
  }
  async build(options) {
    const {
      root
    } = options;
    this._buildResult = {};
    const handleIdList = async idList => {
      for (const id of idList) {
        const handleResult = await this._handleId(id);
        if (handleResult) {
          this._buildResult[handleResult.file] = handleResult;
        }
      }
    };
    await this._initOptions(options);
    await this._initPlugins(options);
    for (const plugin of this._plugins) {
      if (plugin.buildStart) {
        await plugin.buildStart();
      }
    }
    // pass1: build ts for native engine
    console.log('[Build Engine]: pass1 - traverse and compile modules');
    console.time('pass1');
    await handleIdList(this._entries);
    console.timeEnd('pass1');
    // pass2: build web version for jsb type declarations
    console.log('[Build Engine]: pass2 - apply jsb interface info');
    console.time('pass2');
    this._handledCache = {}; // clear cache
    while (this._entriesForPass2.size !== 0) {
      const entries2 = Array.from(this._entriesForPass2);
      this._entriesForPass2.clear();
      this._moduleOverrides = Object.entries(this._moduleOverrides).reduce((result, [k, v]) => {
        if (!fs.existsSync(k) || !entries2.includes(k)) {
          result[k] = v;
        }
        return result;
      }, {});
      await handleIdList(entries2);
    }
    console.timeEnd('pass2');
    if (options.outDir) {
      for (const file in this._buildResult) {
        const res = this._buildResult[file];
        const output = ps.join(options.outDir, ps.relative(root, file));
        fs.outputFileSync(output, res.code, 'utf8');
      }
      this._buildIndex();
      await this._copyTypes();
    }
    for (const plugin of this._plugins) {
      if (plugin.buildEnd) {
        await plugin.buildEnd();
      }
    }
    return this._buildResult;
  }
  async _initPlugins(options) {
    var _a;
    this._moduleQuery = new modularize_1.ModuleQuery({
      engine: options.root,
      platform: options.platform
    });
    this._plugins.push((0, module_query_plugin_1.moduleQueryPlugin)(this._moduleQuery), (0, node_module_loader_1.nodeModuleLoaderFactory)(), (0, external_wasm_loader_1.externalWasmLoaderFactory)({
      engineRoot: options.root,
      outDir: options.outDir,
      cullMeshopt: (_a = options.flagConfig.CULL_MESHOPT) !== null && _a !== void 0 ? _a : false
    }));
  }
  async _initOptions(options) {
    var _a;
    this._options = options;
    const {
      root,
      flagConfig,
      platform,
      mode
    } = options;
    const statsQuery = await stats_query_1.StatsQuery.create(root);
    const constantManager = statsQuery.constantManager;
    const features = (_a = options.features) !== null && _a !== void 0 ? _a : statsQuery.getFeatures();
    const featureUnits = statsQuery.getUnitsOfFeatures(features);
    this._entries = featureUnits.map(fu => (0, utils_1.formatPath)(statsQuery.getFeatureUnitFile(fu)));
    this._buildTimeConstants = constantManager.genBuildTimeConstants({
      platform,
      mode,
      flags: flagConfig
    });
    const intrinsicFlags = statsQuery.getIntrinsicFlagsOfFeatures(features);
    Object.assign(this._buildTimeConstants, intrinsicFlags);
    this._moduleOverrides = statsQuery.evaluateModuleOverrides({
      mode: options.mode,
      platform: options.platform,
      buildTimeConstants: this._buildTimeConstants
    });
    this._moduleOverrides = Object.entries(this._moduleOverrides).reduce((result, [k, v]) => {
      result[(0, utils_1.formatPath)(k)] = (0, utils_1.formatPath)(v);
      return result;
    }, {});
    // paths in tsconfig.json 
    const tsconfigFile = ps.join(root, './tsconfig.json');
    if (fs.existsSync(tsconfigFile)) {
      const tsconfigContent = fs.readFileSync(tsconfigFile, 'utf8');
      const tsconfig = json5.parse(tsconfigContent);
      const compilerOptions = tsconfig.compilerOptions;
      if (compilerOptions && compilerOptions.baseUrl && compilerOptions.paths) {
        for (const [key, paths] of Object.entries(compilerOptions.paths)) {
          this._moduleOverrides[key] = (0, utils_1.formatPath)(ps.join(ps.dirname(tsconfigFile), compilerOptions.baseUrl, paths[0]));
        }
      }
    }
    this._virtual2code['internal:constants'] = constantManager.exportStaticConstants({
      platform,
      mode,
      flags: flagConfig
    });
    this._virtual2code[this._fieldDecoratorHelper.getModuleName()] = this._fieldDecoratorHelper.genModuleSource();
    for (const virtualName in this._virtual2code) {
      this._virtualOverrides[virtualName] = (0, utils_1.formatPath)(ps.join(root, '__virtual__', virtualName.replace(/:/g, '_'))) + '.ts';
    }
  }
  async _handleId(idOrSource, importer) {
    const resolvedId = await this._resolve(idOrSource, importer);
    if (typeof resolvedId === 'undefined') {
      throw new Error(`Cannot resolve module: ${idOrSource} ${importer ? `in file ${importer}` : ''}`);
    }
    // In case circular reference
    if (this._handledCache[resolvedId]) {
      return;
    }
    this._handledCache[resolvedId] = true;
    const code = await this._load(resolvedId);
    if (typeof code === 'undefined') {
      throw new Error(`Cannot load module: ${resolvedId} ${importer ? `in file ${importer}` : ''}`);
    }
    const overrideId = this._getOverrideId(idOrSource, importer);
    // handle output file
    let file = overrideId || resolvedId;
    if (file.endsWith('.json')) {
      file = file.slice(0, -5) + '.ts';
    }
    if (this._buildResult[file]) {
      // skip cached file
      return this._buildResult[file];
    }
    const depIdList = this._getDepIdList(file, code);
    // we handle the dep module first, because we need to get the resolved dep id to transform the import specifier in current module.
    for (const depId of depIdList) {
      await this._handleId(depId, file);
    }
    const transformResult = await this._transform(resolvedId, code);
    const handleResult = this._buildResult[file] = {
      code: transformResult.code,
      file,
      originalId: idOrSource,
      resolvedId,
      map: transformResult.map
    };
    return handleResult;
  }
  _getOverrideId(id, importer) {
    var _a;
    let overrideId;
    for (const p of this._plugins) {
      overrideId = (_a = p.transformId) === null || _a === void 0 ? void 0 : _a.call(p, id, importer);
      if (overrideId) {
        return overrideId;
      }
    }
    if (id in this._virtualOverrides) {
      overrideId = this._virtualOverrides[id];
    } else if (id in this._moduleOverrides) {
      overrideId = this._moduleOverrides[id];
    } else if (!ps.isAbsolute(id) && importer) {
      const absolutePath = this._resolveRelative(id, importer);
      if (absolutePath && this._moduleOverrides[absolutePath] === importer) {
        this._entriesForPass2.add(absolutePath); // for next pass
        return;
      }
      if (absolutePath && absolutePath in this._moduleOverrides) {
        overrideId = this._moduleOverrides[absolutePath];
      }
    }
    return overrideId;
  }
  async _resolve(id, importer) {
    var _a, _b;
    for (const p of this._plugins) {
      const resolvedId = await ((_a = p.resolve) === null || _a === void 0 ? void 0 : _a.call(p, id, importer));
      if (resolvedId) {
        return resolvedId;
      }
    }
    if (!importer) {
      return id; // entry
    } else if (id in this._virtualOverrides) {
      return id; // virtual module does not have real fs path
    } else if (id in this._moduleOverrides) {
      return this._moduleOverrides[id];
    } else if (ps.isAbsolute(id)) {
      return id;
    } else {
      const resolved = this._resolveRelative(id, importer);
      if (resolved) {
        return (_b = this._moduleOverrides[resolved]) !== null && _b !== void 0 ? _b : resolved;
      }
    }
  }
  _resolveRelative(id, importer) {
    const file = (0, utils_1.formatPath)(ps.join(ps.dirname(importer), id));
    if (ps.extname(file) && fs.existsSync(file)) {
      return file;
    }
    // resolve extension less
    for (const ext of this._resolveExtension) {
      const fileExt = file + ext;
      const indexExt = (0, utils_1.formatPath)(ps.join(file, 'index')) + ext;
      if (fs.existsSync(fileExt)) {
        return fileExt;
      } else if (fs.existsSync(indexExt)) {
        return indexExt;
      }
    }
  }
  async _load(id) {
    var _a;
    for (const p of this._plugins) {
      const loadedCode = await ((_a = p.load) === null || _a === void 0 ? void 0 : _a.call(p, id));
      if (loadedCode) {
        return loadedCode;
      }
    }
    if (fs.existsSync(id)) {
      let code = fs.readFileSync(id, 'utf8');
      if (id.endsWith('.json')) {
        code = `export default ${code};`;
      }
      return code;
    } else if (this._virtualOverrides[id]) {
      return this._virtual2code[id];
    }
  }
  _getDepIdList(file, code) {
    let depIdList = [];
    (0, utils_1.asserts)(!file.includes('\\'), 'We should use posix path');
    for (const ex of this._excludeTransform) {
      if (ex.test(file)) {
        return depIdList;
      }
    }
    // eg. zlib.js dependent on zlib.d.ts
    if (ps.extname(file) === '.js') {
      const dtsFile = (0, utils_1.toExtensionLess)(file) + '.d.ts';
      if (fs.existsSync(dtsFile)) {
        depIdList.push(dtsFile); // emit the .d.ts file
      }
    }

    const importExportVisitor = path => {
      // @ts-expect-error TODO: fix type
      const source = path.node.source;
      if (source) {
        const specifier = source.value;
        // add dependency
        depIdList.push(specifier);
      }
    };
    const res = babel.parseSync(code, {
      configFile: false,
      plugins: [[pluginSyntaxTS], [syntaxDecorators, {
        version: '2018-09',
        decoratorsBeforeExport: true
      }]]
    });
    babel.traverse(res, {
      ImportDeclaration: importExportVisitor,
      ExportDeclaration: importExportVisitor,
      CallExpression: path => {
        if (path.node.callee.type === 'Import') {
          const arg0 = path.node.arguments[0];
          if (arg0.type === 'StringLiteral') {
            depIdList.push(arg0.value);
          }
        }
      },
      TSImportType: path => {
        const specifier = path.node.argument.value;
        depIdList.push(specifier);
      }
    });
    depIdList = depIdList.filter((id, index) => depIdList.indexOf(id) === index);
    return depIdList;
  }
  async _transform(file, code) {
    file = (0, utils_1.formatPath)(file);
    (0, utils_1.asserts)(!file.includes('\\'), 'We should use posix path');
    for (const ex of this._excludeTransform) {
      if (ex.test(file)) {
        return {
          code
        };
      }
    }
    let needFieldHelperModule = false;
    const importExportVisitor = path => {
      // @ts-expect-error TODO: fix type
      const source = path.node.source;
      if (source) {
        const specifier = source.value;
        // transform import/export declaration if needed
        const overrideId = this._getOverrideId(specifier, file);
        if (overrideId) {
          let relativePath = (0, utils_1.formatPath)(ps.relative(ps.dirname(file), overrideId));
          if (!relativePath.startsWith('.')) {
            relativePath = './' + relativePath;
          }
          if (ps.extname(relativePath) === '.ts') {
            relativePath = relativePath.slice(0, -3); // remove '.ts'
          }

          traverse(path.node, {
            StringLiteral(path) {
              path.replaceWith(babel.types.stringLiteral(relativePath));
              path.skip();
            }
          }, path.scope);
        }
      }
      const importExportSpecifier = path => {
        const name = path.node.local.name;
        const alias = this._renameMap[name];
        if (alias) {
          path.replaceWith(babel.types.exportSpecifier(babel.types.identifier(alias), babel.types.identifier(alias)));
        }
      };
      path.traverse({
        ExportSpecifier: importExportSpecifier,
        ImportSpecifier: importExportSpecifier
      });
    };
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;
    const transformResult = babel.transformSync(code, {
      configFile: false,
      plugins: [[pluginSyntaxTS], [syntaxDecorators, {
        version: '2018-09',
        decoratorsBeforeExport: true
      }], [() => {
        return {
          name: 'custom-transform',
          pre(file) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const pluginPass = this;
            traverse(file.ast, {
              ClassProperty(path) {
                const decoratorsPath = path.get('decorators');
                if (Array.isArray(decoratorsPath)) {
                  const propertyValuePath = path.get('value');
                  const helperIdentifier = self._fieldDecoratorHelper.addHelper(pluginPass.file);
                  needFieldHelperModule = true;
                  decoratorsPath.forEach(decPath => {
                    const expPath = decPath.get('expression');
                    const type = expPath.node.type;
                    if (type === 'CallExpression') {
                      const decName = expPath.node.callee.name;
                      const args = expPath.node.arguments;
                      decPath.replaceWith(t.decorator(t.callExpression(helperIdentifier, [t.identifier(decName), propertyValuePath.node ? t.arrowFunctionExpression([], propertyValuePath.node) : t.nullLiteral(), ...args])));
                    } else if (type === 'Identifier') {
                      const decName = expPath.node.name;
                      decPath.replaceWith(t.decorator(t.callExpression(helperIdentifier, [t.identifier(decName), propertyValuePath.node ? t.arrowFunctionExpression([], propertyValuePath.node) : t.nullLiteral()])));
                    }
                  });
                }
              }
            });
          },
          visitor: {
            ImportDeclaration: importExportVisitor,
            ExportDeclaration: importExportVisitor,
            // TODO: here we rename class Rect and Path
            CallExpression: path => {
              if (path.node.callee.type === 'MemberExpression') {
                const memberExpressionPath = path.get('callee');
                const objectPath = memberExpressionPath.get('object');
                const name = objectPath.node.name;
                const alias = self._renameMap[name];
                if (typeof alias === 'string' && path.node.callee.object.type === 'Identifier') {
                  objectPath.replaceWith(t.identifier(alias));
                }
                // TODO: for now, OH doesn't support standard console interface,
                // so we need to ignore the type checking for console call expressions.
                else if (name === 'console') {
                  path.node.leadingComments = [{
                    type: 'CommentLine',
                    value: ' @ts-ignore'
                  }];
                }
              } else if (path.node.callee.type === 'Import') {
                // TODO: for now, we transform `import('./xxx/xxx.js')` into `window.__cc_module_context__.import('./xxx/xxx.js')`
                // we need to support import(`project://xxx`) in the future.
                path.replaceWith(t.callExpression(t.memberExpression(t.memberExpression(t.identifier('window'), t.identifier('__cc_module_context__')), t.identifier('import')), path.node.arguments));
                const arg0 = path.node.arguments[0];
                if (arg0.type === 'StringLiteral') {
                  const specifier = arg0.value;
                  // transform import/export declaration if needed
                  const overrideId = this._getOverrideId(specifier, file);
                  if (overrideId) {
                    let relativePath = (0, utils_1.formatPath)(ps.relative(ps.dirname(file), overrideId));
                    if (!relativePath.startsWith('.')) {
                      relativePath = './' + relativePath;
                    }
                    if (ps.extname(relativePath) === '.ts') {
                      relativePath = relativePath.slice(0, -3); // remove '.ts'
                    }

                    traverse(path.node, {
                      StringLiteral(path) {
                        path.replaceWith(babel.types.stringLiteral(relativePath));
                        path.skip();
                      }
                    }, path.scope);
                  }
                }
              }
            },
            TSImportType: path => {
              const specifier = path.node.argument.value;
              // transform import/export declaration if needed
              const overrideId = this._getOverrideId(specifier, file);
              if (overrideId) {
                let relativePath = (0, utils_1.formatPath)(ps.relative(ps.dirname(file), overrideId));
                if (!relativePath.startsWith('.')) {
                  relativePath = './' + relativePath;
                }
                if (ps.extname(relativePath) === '.ts') {
                  relativePath = relativePath.slice(0, -3); // remove '.ts'
                }

                traverse(path.node, {
                  StringLiteral(path) {
                    path.replaceWith(babel.types.stringLiteral(relativePath));
                    path.skip();
                  }
                }, path.scope);
              }
            },
            ClassDeclaration(path) {
              const idPath = path.get('id');
              const name = idPath.node.name;
              const alias = self._renameMap[name];
              if (typeof alias === 'string') {
                idPath.replaceWith(t.identifier(alias));
              }
            },
            NewExpression(path) {
              const calleePath = path.get('callee');
              // @ts-expect-error TODO: fix type
              const name = calleePath.node.name;
              if (name) {
                const alias = self._renameMap[name];
                if (typeof alias === 'string') {
                  calleePath.replaceWith(t.identifier(alias));
                }
              }
            },
            TSTypeAnnotation(path) {
              // @ts-expect-error TODO: fix type
              const typeName = path.node.typeAnnotation.typeName;
              const childPath = path.get('typeAnnotation');
              if (typeName) {
                const name = typeName.name;
                const alias = self._renameMap[name];
                if (typeof alias === 'string') {
                  path.replaceWith(t.tsTypeAnnotation({
                    type: 'TSExpressionWithTypeArguments',
                    expression: t.identifier(alias)
                  }));
                }
              } else if (childPath.type === 'TSLiteralType') {
                const literalPath = childPath.get('literal');
                if (literalPath.type === 'TemplateLiteral') {
                  path.replaceWith(t.tsTypeAnnotation(t.tsStringKeyword()));
                }
              }
            },
            Identifier(path) {
              const name = path.node.name;
              const alias = self._renameMap[name];
              if (typeof alias === 'string') {
                if (path.parent.type === 'ObjectProperty' || path.parent.type === 'TSPropertySignature') {
                  if (path.parent.key !== path.node) {
                    path.replaceWith(t.identifier(alias));
                  }
                } else if (path.parent.type === 'MemberExpression' || path.parent.type === 'OptionalMemberExpression') {
                  if (path.parent.property !== path.node) {
                    path.replaceWith(t.identifier(alias));
                  }
                } else if (!(path.parent.type === 'ClassMethod' && (path.parent.kind === 'get' || path.parent.kind === 'set' || path.parent.key === path.node)) && path.parent.type !== 'ClassProperty') {
                  const newIdentifier = t.identifier(alias);
                  if (path.node.typeAnnotation) {
                    newIdentifier.typeAnnotation = path.node.typeAnnotation;
                  }
                  path.replaceWith(newIdentifier);
                }
              }
            }
          }
        };
      }]]
    });
    if (needFieldHelperModule) {
      await this._handleId(this._fieldDecoratorHelper.getModuleName(), file);
    }
    return {
      code: transformResult === null || transformResult === void 0 ? void 0 : transformResult.code
    };
  }
  _buildIndex() {
    const {
      outDir,
      root
    } = this._options;
    if (outDir) {
      const indexFile = (0, utils_1.formatPath)(ps.join(outDir, 'index.ts'));
      const ccFile = (0, utils_1.formatPath)(ps.join(outDir, 'cc.ts'));
      const systemCCFile = (0, utils_1.formatPath)(ps.join(outDir, 'system-cc.js'));
      let indexContent = '';
      this._entries.forEach(item => {
        const relative = (0, utils_1.formatPath)(ps.relative(root, (0, utils_1.toExtensionLess)(item)));
        indexContent += `export * from './${relative}';\n`;
      });
      const ccContent = (0, dedent_1.default)`import * as cc from './index';
            // @ts-ignore
            window.cc_module = cc;`;
      const systemCCContent = (0, dedent_1.default)`System.register([], function (exports, module) {
                return {
                    execute: function () {
                        window.__cc_module_context__ = module;
            
                        exports(window.cc_module);
                    }
                };
            });
            `;
      fs.outputFileSync(indexFile, indexContent, 'utf8');
      fs.outputFileSync(ccFile, ccContent, 'utf8');
      fs.outputFileSync(systemCCFile, systemCCContent, 'utf8');
    }
  }
  async _copyTypes() {
    const {
      root,
      outDir
    } = this._options;
    if (!outDir) {
      return;
    }
    let dtsFiles;
    try {
      const ccAmbientTypesQuery = await this._requireEngineModules('@types/cc-ambient-types/query');
      dtsFiles = ccAmbientTypesQuery.getDtsFiles();
    } catch (e) {
      // NOTE: if failed to resolve '@types/cc-ambient-types', we use the legacy way to copy dts files.
      dtsFiles = glob_1.glob.sync((0, utils_1.formatPath)(ps.join(root, './@types/**/*.d.ts')));
      const externalDtsFiles = glob_1.glob.sync((0, utils_1.formatPath)(ps.join(root, './native/external/**/*.d.ts')));
      dtsFiles = dtsFiles.concat(externalDtsFiles);
    }
    for (const file of dtsFiles) {
      const code = fs.readFileSync(file, 'utf8');
      const relativePath = ps.relative(root, file);
      const targetPath = (0, utils_1.formatPath)(ps.join(outDir, relativePath));
      fs.outputFileSync(targetPath, code, 'utf8');
    }
    // copy lib.dom.d.ts
    // we use 4.2 version of typescript
    const originalDomDts = (0, utils_1.formatPath)(ps.join(__dirname, '../../../../static/lib.dom.d.ts'));
    const targetDomDts = (0, utils_1.formatPath)(ps.join(outDir, '@types/lib.dom.d.ts'));
    const code = fs.readFileSync(originalDomDts, 'utf8');
    fs.outputFileSync(targetDomDts, code, 'utf8');
  }
  async _requireEngineModules(moduleName) {
    const resolvedPath = await this._moduleQuery.resolveExport(moduleName);
    if (!resolvedPath) {
      throw new Error(`Can't resolve engine module: ${moduleName}.`);
    }
    return require(resolvedPath);
  }
}
exports.EngineBuilder = EngineBuilder;