import { StatsQuery } from "../../stats-query/lib/index";
/**
 * @group Merged Types
 */
export declare function buildEngine(options: buildEngine.Options): Promise<buildEngine.Result>;
/**
 * @group Merged Types
 */
export declare namespace buildEngine {
  type ModuleFormat = 'esm' | 'cjs' | 'system' | 'iife';
  interface Options {
    /**
     * 引擎仓库目录。
     */
    engine: string;
    /**
     * 输出目录。
     */
    out: string;
    mode: StatsQuery.ConstantManager.ModeType;
    platform: StatsQuery.ConstantManager.PlatformType;
    flags?: Partial<StatsQuery.ConstantManager.IFlagConfig>;
    /**
     * 包含的功能。
     */
    features?: string[];
    /**
     * 输出模块格式。
     * @default 'system'
     */
    moduleFormat?: ModuleFormat;
    /**
     * 是否对生成的脚本进行压缩。
     * @default false
     */
    compress?: boolean;
    /**
     * 是否生成 source map。
     * 若为 `inline` 则生成内联的 source map。
     * @default false
     */
    sourceMap?: boolean | 'inline';
    /**
     * 若 `sourceMap` 为 `true`，此选项指定了 source map 的路径。
     * @default `${outputPath.map}`
     */
    sourceMapFile?: string;
    /**
     * 若为 `true`，分割出 **所有** 引擎子模块。
     * 否则，`.moduleEntries` 指定的所有子模块将被合并成一个单独的 `"cc"` 模块。
     * @default false
     */
    split?: boolean;
    /**
     * 原生代码的打包模式
     * - 为 `wasm` 时使用 wasm 版本原生库
     * - 为 `asmjs` 时使用 asmjs 版本的原生库
     * - 为 `both` 时同时在结果中包含 wasm 与 asmjs 两个版本的原生库
     */
    nativeCodeBundleMode?: 'wasm' | 'asmjs' | 'both';
    /**
     * Wasm compression mode, 'brotli' means to compress .wasm to .wasm.br.
     * @note Currently, only WeChat and ByteDance mini-game support to load '.wasm.br' file.
     */
    wasmCompressionMode?: 'brotli';
    /**
     * If true, all deprecated features/API are excluded.
     * You can also specify a version range(in semver range) to exclude deprecations in specified version(s).
     * @default false
     */
    noDeprecatedFeatures?: string | boolean;
    /**
     * Experimental.
     */
    incremental?: string;
    /**
     * BrowsersList targets.
     */
    targets?: string | string[] | Record<string, string>;
    /**
     * Enable loose compilation.
     *
     * @deprecated since 1.1.20, we force using true internal.
     */
    loose?: boolean;
    /**
     * How to generate the reference to external assets:
     * - `'relative-from-out'`
     * Generate the path relative from `out` directory, does not contain the leading './'.
     *
     * - `'relative-from-chunk'`
     * Generate the path relative from the referencing output chunk.
     *
     * - `'dynamic'`(default)
     * Use runtime `URL` API to resolve the absolute URL.
     * This requires `URL` and `import.meta.url` to be valid.
     */
    assetURLFormat?: 'relative-from-out' | 'relative-from-chunk' | 'runtime-resolved';
    /**
     * Preserve engine type info, this options will build a TS engine to the output directory.
     * It's useful when we need to take a step towards the AOT optimization.
     * This options is only supported on Open Harmony platform for now.
     * @default false
     */
    preserveType?: boolean;
    visualize?: boolean | {
      file?: string;
    };
    /**
     * Generate cocos/native-binding/decorators.ts for native platforms
     */
    generateDecoratorsForJSB?: boolean;
    /**
     * Whether to generate 'named' register code for systemjs module format.
     * SystemJS default register code: System.register([], function(){...});
     * SystemJS named register code: System.register('module_name', [], function(){...});
     * @note It's only avaiable when options.moduleFormat is 'system'.
     */
    enableNamedRegisterForSystemJSModuleFormat?: boolean;
  }
  interface Result {
    /**
     * Mappings between feature unit name and their actual chunk file, for example:
     * ```js
     * {
     *   "core": "./core.js",
     *   "gfx-webgl": "./gfx-webgl.js",
     * }
     * ```
     */
    exports: Record<string, string>;
    /**
     * The compulsory import mappings that should be applied.
     */
    chunkAliases: Record<string, string>;
    /**
     * The dependency graph, only including dependency chunks.
     *
     * @deprecated please use `chunkDepGraph` instead.
     */
    dependencyGraph?: Record<string, string[]>;
    chunkDepGraph: Record<string, string[]>;
    assetDepGraph: Record<string, string[]>;
    hasCriticalWarns: boolean;
  }
  function transform(code: string, moduleOption: ModuleFormat, loose?: boolean): Promise<{
    code: string;
  }>;
  function isSourceChanged(incrementalFile: string): Promise<boolean>;
  /**
   * Enumerates all chunk files that used by specified feature units.
   * @param meta Metadata of build result.
   * @param featureUnits Feature units.
   */
  function enumerateDependentChunks(meta: buildEngine.Result, featureUnits: string[]): string[];
  /**
   * Enumerates all asset files that used by specified feature units.
   * @param meta Metadata of build result.
   * @param featureUnits Feature units.
   */
  function enumerateDependentAssets(meta: buildEngine.Result, featureUnits: string[]): string[];
  /**
   * Enumerates all chunk files and asset files that used by specified feature units.
   * @param meta Metadata of build result.
   * @param featureUnits Feature units.
   */
  function enumerateAllDependents(meta: buildEngine.Result, featureUnits: string[]): string[];
}