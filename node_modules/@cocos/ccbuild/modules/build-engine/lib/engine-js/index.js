"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildJsEngine = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const transformer_1 = require("../../../transformer/lib/index.js");
const bundler_1 = require("../../../bundler/lib/index.js");
const fs_1 = __importDefault(require("fs"));
const ts_paths_1 = __importDefault(require("./rollup-plugins/ts-paths"));
const module_query_plugin_1 = __importDefault(require("./rollup-plugins/module-query-plugin"));
const remove_deprecated_features_1 = __importDefault(require("./rollup-plugins/remove-deprecated-features"));
const external_wasm_loader_1 = require("./rollup-plugins/external-wasm-loader");
const stats_query_1 = require("../../../stats-query/lib/index.js");
const utils_1 = require("../../../utils/lib/index.js");
const systemjs_named_register_plugin_1 = require("./rollup-plugins/systemjs-named-register-plugin");
var babelPluginTransformForOf = transformer_1.babel.plugins.transformForOf;
var babelPresetEnv = transformer_1.babel.presets.presetEnv;
var babelPluginDynamicImportVars = transformer_1.babel.plugins.cocosDynamicImportVars;
var babelPresetCC = transformer_1.babel.presets.presetCC.babelPresetCC;
var helpers = transformer_1.babel.presets.presetCC.helpers;
// import rollup
var rollup = bundler_1.rollup.core;
var rpBabel = bundler_1.rollup.plugins.babel.babel;
var json = bundler_1.rollup.plugins.json;
var resolve = bundler_1.rollup.plugins.nodeResolve;
var commonjs = bundler_1.rollup.plugins.commonjs;
var rpTerser = bundler_1.rollup.plugins.terser.terser;
var rpVirtual = bundler_1.rollup.plugins.virtual;
const modularize_1 = require("../../../modularize/lib/index.js");
// import rpProgress = Bundler.plugins.progress;
const decoratorRecorder = __importStar(require("./babel-plugins/decorator-parser"));
const realPath = function () {
  const realpath = typeof fs_1.default.realpath.native === 'function' ? fs_1.default.realpath.native : fs_1.default.realpath;
  return file => new Promise((resolve, reject) => {
    realpath(file, (err, path) => {
      if (err && err.code !== 'ENOENT') {
        reject(err);
      } else {
        resolve(err ? file : path);
      }
    });
  });
}();
function makePathEqualityKey(path) {
  return process.platform === 'win32' ? path.toLocaleLowerCase() : path;
}
async function buildJsEngine(options) {
  var _a, _b, _c, _d, _e, _f, _g;
  const doUglify = !!options.compress;
  const engineRoot = path_1.default.resolve(options.engine);
  const rollupFormat = (_a = options.moduleFormat) !== null && _a !== void 0 ? _a : 'iife';
  const statsQuery = await stats_query_1.StatsQuery.create(engineRoot);
  const moduleQuery = new modularize_1.ModuleQuery({
    engine: engineRoot,
    platform: options.platform
  });
  if (options.features) {
    for (const feature of options.features) {
      if (!statsQuery.hasFeature(feature)) {
        console.warn(`'${feature}' is not a valid feature.`);
      }
    }
  }
  let features;
  let split = (_b = options.split) !== null && _b !== void 0 ? _b : false;
  if (options.features && options.features.length !== 0) {
    features = options.features;
  } else {
    features = statsQuery.getFeatures();
    if (split !== true) {
      split = true;
      console.warn(`You did not specify features which implies 'split: true'. ` + `Explicitly set 'split: true' to suppress this warning.`);
    }
  }
  let {
    nativeCodeBundleMode
  } = options;
  nativeCodeBundleMode !== null && nativeCodeBundleMode !== void 0 ? nativeCodeBundleMode : nativeCodeBundleMode = 'both'; // default is true
  const flags = (_c = options.flags) !== null && _c !== void 0 ? _c : {};
  flags.CULL_MESHOPT = !features.includes('meshopt');
  const intrinsicFlags = statsQuery.getIntrinsicFlagsOfFeatures(features);
  let buildTimeConstants = statsQuery.constantManager.genBuildTimeConstants({
    mode: options.mode,
    platform: options.platform,
    flags
  });
  buildTimeConstants = Object.assign(Object.assign({}, intrinsicFlags), buildTimeConstants);
  // if (typeof options.forceJitValue !== undefined) {
  //     buildTimeConstants['SUPPORT_JIT'] = options.forceJitValue as boolean;
  // }
  const moduleOverrides = Object.entries(statsQuery.evaluateModuleOverrides({
    mode: options.mode,
    platform: options.platform,
    buildTimeConstants
  })).reduce((result, [k, v]) => {
    result[makePathEqualityKey(k)] = v;
    return result;
  }, {});
  const featureUnits = statsQuery.getUnitsOfFeatures(features);
  const rpVirtualOptions = {};
  const vmInternalConstants = statsQuery.constantManager.exportStaticConstants({
    platform: options.platform,
    mode: options.mode,
    flags
  });
  console.debug(`Module source "internal-constants":\n${vmInternalConstants}`);
  rpVirtualOptions['internal:constants'] = vmInternalConstants;
  rpVirtualOptions[helpers.CC_HELPER_MODULE] = helpers.generateHelperModuleSource();
  // for some modules that we need to instantiate before cc module
  // const forceStandaloneModules = ['wait-for-ammo-instantiation'];
  const forceStandaloneModules = [];
  let rollupEntries;
  if (split) {
    rollupEntries = featureUnits.reduce((result, featureUnit) => {
      result[featureUnit] = statsQuery.getFeatureUnitFile(featureUnit);
      return result;
    }, {});
  } else {
    rollupEntries = {
      cc: 'cc'
    };
    const selectedFeatureUnits = [];
    for (const featureUnit of featureUnits) {
      if (forceStandaloneModules.includes(featureUnit)) {
        rollupEntries[featureUnit] = statsQuery.getFeatureUnitFile(featureUnit);
      } else {
        selectedFeatureUnits.push(featureUnit);
      }
    }
    rpVirtualOptions.cc = statsQuery.evaluateIndexModuleSource(selectedFeatureUnits, featureUnit => (0, utils_1.filePathToModuleRequest)(statsQuery.getFeatureUnitFile(featureUnit)));
    rollupEntries.cc = 'cc';
    console.debug(`Module source "cc":\n${rpVirtualOptions.cc}`);
  }
  const presetEnvOptions = {
    loose: (_d = options.loose) !== null && _d !== void 0 ? _d : true,
    // We need explicitly specified targets.
    // Ignore it to avoid the engine's parent dirs contain unexpected config.
    ignoreBrowserslistConfig: true
  };
  if (options.targets) {
    presetEnvOptions.targets = options.targets;
  }
  const babelPlugins = [];
  if (!options.targets) {
    babelPlugins.push([babelPluginTransformForOf, {
      loose: true
    }]);
  }
  babelPlugins.push([babelPluginDynamicImportVars, {
    resolve: {
      forwardExt: 'resolved'
    }
  }]);
  const {
    fieldDecorators,
    editorDecorators
  } = statsQuery.getOptimizeDecorators();
  const babelOptions = {
    babelHelpers: 'bundled',
    extensions: ['.js', '.ts'],
    exclude: [/node_modules[/\\]@cocos[/\\]ammo/, /node_modules[/\\]@cocos[/\\]cannon/, /node_modules[/\\]@cocos[/\\]physx/, /\.asm\.js/],
    comments: false,
    overrides: [{
      // Eliminates the babel compact warning:
      // 'The code generator has deoptimised the styling of ...'
      // that came from node_modules/@cocos
      test: /node_modules[/\\]@cocos[/\\]/,
      compact: true
    }],
    plugins: babelPlugins,
    presets: [[babelPresetEnv, presetEnvOptions], [babelPresetCC, {
      allowDeclareFields: true,
      ccDecoratorHelpers: 'external',
      fieldDecorators,
      editorDecorators
    }]]
  };
  if (options.generateDecoratorsForJSB) {
    if (!process.env.ENGINE_PATH) {
      throw new Error('ENGINE_PATH environment variable not set');
    }
    (_e = babelOptions.presets) === null || _e === void 0 ? void 0 : _e.push([() => ({
      plugins: [[decoratorRecorder]]
    })]);
  }
  const rollupPlugins = [];
  if (options.noDeprecatedFeatures) {
    rollupPlugins.push((0, remove_deprecated_features_1.default)(typeof options.noDeprecatedFeatures === 'string' ? options.noDeprecatedFeatures : undefined));
  }
  rollupPlugins.push((0, external_wasm_loader_1.externalWasmLoader)({
    externalRoot: path_1.default.join(engineRoot, 'native/external'),
    nativeCodeBundleMode,
    wasmCompressionMode: options.wasmCompressionMode,
    cullMeshopt: buildTimeConstants.CULL_MESHOPT,
    format: 'relative-from-chunk',
    wasmSubpackage: buildTimeConstants.WASM_SUBPACKAGE
  }), {
    name: '@cocos/ccbuild|module-overrides',
    resolveId(source, importer) {
      if (moduleOverrides[source]) {
        return source;
      } else {
        return null;
      }
    },
    load(id) {
      const key = makePathEqualityKey(id);
      if (!(key in moduleOverrides)) {
        return null;
      }
      const replacement = moduleOverrides[key];
      console.debug(`Redirect module ${id} to ${replacement}`);
      return `export * from '${(0, utils_1.filePathToModuleRequest)(replacement)}';`;
    }
  }, rpVirtual(rpVirtualOptions), (0, module_query_plugin_1.default)(moduleQuery), (0, ts_paths_1.default)({
    configFileName: path_1.default.resolve(options.engine, 'tsconfig.json')
  }), resolve({
    extensions: ['.js', '.ts', '.json'],
    jail: await realPath(engineRoot),
    rootDir: engineRoot
  }), json({
    preferConst: true
  }), commonjs({
    include: [/node_modules[/\\]/, /asm\.js/],
    sourceMap: false
  }), rpBabel(Object.assign({
    skipPreflightCheck: true
  }, babelOptions)));
  // The named-registered format of `System.register('cocos-js/cc.js', [], function() {...})` needs to be generated when the feature of preloading JS list is enabled.
  // Otherwise, we will generate the default register code without name like `System.register([], function() {...})`.
  if (options.enableNamedRegisterForSystemJSModuleFormat && options.moduleFormat === 'system') {
    rollupPlugins.push((0, systemjs_named_register_plugin_1.rpNamedChunk)());
  }
  // if (options.progress) {
  //     rollupPlugins.unshift(rpProgress());
  // }
  if (doUglify) {
    // TODO: tree-shaking not clear!
    rollupPlugins.push(rpTerser({
      // see https://github.com/terser/terser#compress-options
      compress: {
        reduce_funcs: false,
        keep_fargs: false,
        unsafe_Function: true,
        unsafe_math: true,
        unsafe_methods: true,
        passes: 2 // first: remove deadcodes and const objects, second: drop variables
      },

      mangle: doUglify,
      keep_fnames: !doUglify,
      output: {
        beautify: !doUglify
      },
      // https://github.com/rollup/rollup/issues/3315
      // We only do this for CommonJS.
      // Especially, we cannot do this for IIFE.
      toplevel: rollupFormat === 'cjs'
    }));
  }
  const visualizeOptions = typeof options.visualize === 'object' ? options.visualize : options.visualize ? {} : undefined;
  if (visualizeOptions) {
    let rpVisualizer;
    try {
      // eslint-disable-next-line import/no-extraneous-dependencies
      rpVisualizer = await import('rollup-plugin-visualizer');
    } catch (_h) {
      console.warn('Visualizing needs \'rollup-plugin-visualizer\' to be installed. It\'s installed as dev-dependency.');
    }
    if (rpVisualizer) {
      const visualizeFile = (_f = visualizeOptions.file) !== null && _f !== void 0 ? _f : path_1.default.join(options.out, 'visualize.html');
      rollupPlugins.push(rpVisualizer.visualizer({
        filename: visualizeFile,
        title: 'Cocos Creator build visualizer',
        template: 'treemap'
      }));
    }
  }
  let hasCriticalWarns = false;
  const rollupWarningHandler = (warning, defaultHandler) => {
    var _a;
    if (typeof warning !== 'string') {
      if (warning.code === 'CIRCULAR_DEPENDENCY') {
        hasCriticalWarns = true;
      } else if (warning.code === 'THIS_IS_UNDEFINED') {
        // TODO: It's really inappropriate to do this...
        // Let's fix these files instead of suppressing rollup.
        if ((_a = warning.id) === null || _a === void 0 ? void 0 : _a.match(/(?:spine-core\.js$)|(?:dragonBones\.js$)/)) {
          console.debug(`Rollup warning 'THIS_IS_UNDEFINED' is omitted for ${warning.id}`);
          return;
        }
      }
    }
    defaultHandler(warning);
  };
  const rollupOptions = {
    input: rollupEntries,
    plugins: rollupPlugins,
    cache: false,
    onwarn: rollupWarningHandler
  };
  const perf = true;
  if (perf) {
    rollupOptions.perf = true;
  }
  const rollupBuild = await rollup.rollup(rollupOptions);
  const timing = (_g = rollupBuild.getTimings) === null || _g === void 0 ? void 0 : _g.call(rollupBuild);
  if (timing) {
    console.debug(`==== Performance ====`);
    console.debug(JSON.stringify(timing));
    console.debug(`====             ====`);
  }
  const {
    incremental: incrementalFile
  } = options;
  if (incrementalFile) {
    const watchFiles = {};
    const files = rollupBuild.watchFiles;
    await Promise.all(files.map(async watchFile => {
      try {
        const stat = await fs_extra_1.default.stat(watchFile);
        watchFiles[watchFile] = stat.mtimeMs;
      } catch (_a) {
        // the `watchFiles` may contain non-fs modules.
      }
    }));
    await fs_extra_1.default.ensureDir(path_1.default.dirname(incrementalFile));
    await fs_extra_1.default.writeFile(incrementalFile, JSON.stringify(watchFiles, undefined, 2));
  }
  const result = {
    chunkAliases: {},
    exports: {},
    chunkDepGraph: {},
    assetDepGraph: {},
    hasCriticalWarns: false
  };
  const rollupOutputOptions = {
    format: rollupFormat,
    sourcemap: options.sourceMap,
    sourcemapFile: options.sourceMapFile,
    name: rollupFormat === 'iife' ? 'ccm' : undefined,
    dir: options.out,
    // NOTE: parallel dynamic import has some issue on SystemJS, especially on OH platform
    // see: https://github.com/systemjs/systemjs/issues/2297
    inlineDynamicImports: options.platform === 'OPEN_HARMONY'
    // minifyInternalExports: false,
    // preserveEntrySignatures: "allow-extension",
  };

  const rollupOutput = await rollupBuild.write(rollupOutputOptions);
  const validEntryChunks = {};
  for (const output of rollupOutput.output) {
    if (output.type === 'chunk') {
      if (output.isEntry) {
        const chunkName = output.name;
        if (chunkName in rollupEntries || chunkName === 'cc') {
          validEntryChunks[chunkName] = output.fileName;
        }
      }
    }
  }
  Object.assign(result.exports, validEntryChunks);
  result.dependencyGraph = {};
  for (const output of rollupOutput.output) {
    if (output.type === 'chunk') {
      const depList = output.imports.concat(output.dynamicImports);
      result.dependencyGraph[output.fileName] = depList;
      result.chunkDepGraph[output.fileName] = depList;
      result.assetDepGraph[output.fileName] = output.referencedFiles.slice();
    }
  }
  result.hasCriticalWarns = hasCriticalWarns;
  return result;
}
exports.buildJsEngine = buildJsEngine;