"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathToAssetRefURL = exports.externalWasmLoader = void 0;
const bundler_1 = require("../../../../bundler/lib/index.js");
const transformer_1 = require("../../../../transformer/lib/index.js");
const url_1 = require("url");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const zlib_1 = require("zlib");
const util_1 = require("util");
var babel = transformer_1.babel.core;
var pluginTransformSystemJSModule = transformer_1.babel.plugins.transformModulesSystemjs;
var rollup = bundler_1.rollup.core;
var rpCjs = bundler_1.rollup.plugins.commonjs;
const crypto_1 = require("crypto");
const brotliCompress = (0, util_1.promisify)(zlib_1.brotliCompress);
const externalOrigin = 'external:';
function normalizePath(path) {
  return path.replace(/\\/g, '/');
}
const suffixReplaceConfig = {
  '.mem': '.mem.bin'
};
/**
 * emit asset and return the export statement
 */
async function emitAsset(context, filePath, options) {
  let basename = path_1.default.basename(filePath);
  for (const suffixToReplace in suffixReplaceConfig) {
    const replacement = suffixReplaceConfig[suffixToReplace];
    if (basename.endsWith(suffixToReplace)) {
      // some platforms doesn't support files with special suffix like '.mem', we replace it to '.bin'
      basename = basename.slice(0, -suffixToReplace.length) + replacement;
    }
  }
  const source = await fs_extra_1.default.readFile(filePath);
  let referenceId;
  let hash;
  if (basename.endsWith('.wasm') && options.wasmCompressionMode === 'brotli') {
    const compressOptions = {};
    const compressedSource = await brotliCompress(source, compressOptions);
    hash = (0, crypto_1.createHash)('sha256').update(compressedSource).digest('hex').slice(0, 8);
    const fileNamePrefix = basename.slice(0, -'.wasm'.length);
    referenceId = context.emitFile({
      type: 'asset',
      fileName: `assets/${fileNamePrefix}-${hash}.wasm.br`,
      source: compressedSource
    });
  } else {
    hash = (0, crypto_1.createHash)('sha256').update(source).digest('hex').slice(0, 8);
    referenceId = context.emitFile({
      type: 'asset',
      name: basename,
      source
    });
  }
  return `export default import.meta.ROLLUP_FILE_URL_${referenceId}; /* asset-hash:${hash} */`;
}
function shouldCullMeshoptModule(options, id) {
  return options.cullMeshopt && id.includes('meshopt');
}
const loadConfig = {
  '.wasm': {
    shouldCullModule(options, id) {
      return options.nativeCodeBundleMode === 'asmjs' || shouldCullMeshoptModule(options, id);
    },
    shouldEmitAsset(options, id) {
      return !this.shouldCullModule(options, id);
    },
    cullingContent: `export default '';`
  },
  '.js.mem': {
    shouldCullModule(options, id) {
      return options.nativeCodeBundleMode === 'wasm' || shouldCullMeshoptModule(options, id);
    },
    shouldEmitAsset(options, id) {
      return !this.shouldCullModule(options, id);
    },
    cullingContent: `export default '';`
  },
  '.wasm.js': {
    shouldCullModule(options, id) {
      return options.nativeCodeBundleMode === 'asmjs' || shouldCullMeshoptModule(options, id);
    },
    shouldEmitAsset(options, id) {
      return false;
    },
    cullingContent: `export default function () {}`
  },
  '.asm.js': {
    shouldCullModule(options, id) {
      return options.nativeCodeBundleMode === 'wasm' || shouldCullMeshoptModule(options, id);
    },
    shouldEmitAsset(options, id) {
      return false;
    },
    cullingContent: `export default function () {}`
  }
};
/**
 * This is a module bundler for minigame subpacakge.
 * We need an entry script called 'game.js' for each subpackage.
 */
class ExternalWasmModuleBundler {
  constructor(options) {
    this._loadedChunkMap = {}; // id to code
    this._options = options;
  }
  _resolveId(source) {
    const id = normalizePath(path_1.default.join(this._options.externalRoot, source.substring(externalOrigin.length)));
    return id;
  }
  async _load(id) {
    for (const suffix in loadConfig) {
      if (id.endsWith(suffix)) {
        const config = loadConfig[suffix];
        if (config.shouldCullModule(this._options, id)) {
          return config.cullingContent;
        } else if (config.shouldEmitAsset(this._options, id)) {
          return this._emitAsset(id);
        } else {
          return await this._transformSystemJs(id);
        }
      }
    }
    // fallback
    return await this._transformSystemJs(id);
  }
  // NOTE: we use rollup to transform CommonJS / ES Module to SystemJs.
  async _transformSystemJs(id) {
    const systemJsModuleId = externalOrigin + path_1.default.relative(this._options.externalRoot, id).replace(/\\/g, '/');
    const res = await rollup.rollup({
      input: id,
      plugins: [rpCjs()]
    });
    const output = await res.generate({
      format: 'system',
      name: systemJsModuleId
    });
    await res.close();
    return output.output[0].code;
  }
  _emitAsset(id) {
    let basename = path_1.default.basename(id);
    for (const suffixToReplace in suffixReplaceConfig) {
      const replacement = suffixReplaceConfig[suffixToReplace];
      if (basename.endsWith(suffixToReplace)) {
        // some platforms doesn't support files with special suffix like '.mem', we replace it to '.bin'
        basename = basename.slice(0, -suffixToReplace.length) + replacement;
      }
    }
    let buffer = fs_extra_1.default.readFileSync(id);
    const assetsDir = path_1.default.join(this._options.outDir, 'assets');
    if (basename.endsWith('.wasm') && this._options.wasmCompressionMode === 'brotli') {
      const compressOptions = {};
      const compressedSource = (0, zlib_1.brotliCompressSync)(buffer, compressOptions);
      const fileNamePrefix = basename.slice(0, -'.wasm'.length);
      basename = fileNamePrefix + '.wasm.br';
      buffer = compressedSource;
    }
    fs_extra_1.default.outputFileSync(path_1.default.join(assetsDir, basename), buffer);
    // output game.js
    const gameJs = path_1.default.join(assetsDir, 'game.js');
    if (!fs_extra_1.default.existsSync(gameJs)) {
      fs_extra_1.default.outputFileSync(gameJs, `console.log('[CC Subpackage] wasm assets loaded');`, 'utf8');
    }
    return `export default 'assets/${basename}';`;
  }
  _transform(id, code) {
    if (code.startsWith('System.register')) {
      // NOTE: if it's already SystemJS module, we don't need to transform it again.
      return code;
    }
    const systemJsModuleId = externalOrigin + path_1.default.relative(this._options.externalRoot, id).replace(/\\/g, '/');
    const res = babel.transformSync(code, {
      compact: true,
      plugins: [[pluginTransformSystemJSModule, {
        moduleId: systemJsModuleId
      }]]
    });
    code = res.code;
    return code;
  }
  async bundle() {
    // transform all external wasm modules
    for (const externalWasmModule of this._options.externalWasmModules) {
      const id = this._resolveId(externalWasmModule);
      const code = await this._load(id);
      this._loadedChunkMap[id] = this._transform(id, code);
    }
    // bundle
    const result = [`console.log('[CC Subpackage] wasm chunks loaded');`];
    for (const id in this._loadedChunkMap) {
      const code = this._loadedChunkMap[id];
      result.push(code);
    }
    return result.join('\n');
  }
}
/**
 * This plugin enable to load script or wasm with url based on 'external://' origin.
 */
function externalWasmLoader(options) {
  const externalWasmModules = [];
  return {
    name: '@cocos/ccbuild|external-loader',
    async resolveId(source, importer) {
      if (source.startsWith(externalOrigin)) {
        if (options.wasmSubpackage) {
          externalWasmModules.push(source);
          return {
            id: source,
            external: true
          };
        }
        return source;
      }
      return null;
    },
    async load(id) {
      if (id.startsWith(externalOrigin)) {
        const filePath = normalizePath(path_1.default.join(options.externalRoot, id.substring(externalOrigin.length)));
        for (const suffix in loadConfig) {
          if (filePath.endsWith(suffix)) {
            const config = loadConfig[suffix];
            if (config.shouldCullModule(options, id)) {
              return config.cullingContent;
            } else if (config.shouldEmitAsset(options, id)) {
              return emitAsset(this, filePath, options);
            } else {
              return (await fs_extra_1.default.readFile(filePath, 'utf8')).replace(/\r\n/g, '\n');
            }
          }
        }
        // some external module that doesn't obey the suffix specification, we return its content by default.
        return (await fs_extra_1.default.readFile(filePath, 'utf8')).replace(/\r\n/g, '\n');
      }
      return null;
    },
    // Generates the `import.meta.ROLLUP_FILE_URL_referenceId`.
    resolveFileUrl({
      // > The path and file name of the emitted asset, relative to `output.dir` without a leading `./`.
      fileName,
      // > The path and file name of the emitted file,
      // > relative to the chunk the file is referenced from.
      // > This will path will contain no leading `./` but may contain a leading `../`.
      relativePath
    }) {
      switch (options.format) {
        case 'relative-from-chunk':
          return `'${relativePath}'`;
        case 'relative-from-out':
          return `'${fileName}'`;
        case 'runtime-resolved':
        default:
          return undefined;
        // return `new URL('${fileName}', import.meta.url).href`;
      }
    },

    async generateBundle(opts, bundles) {
      if (externalWasmModules.length !== 0) {
        const bundler = new ExternalWasmModuleBundler(Object.assign(Object.assign({}, options), {
          externalWasmModules,
          outDir: opts.dir
        }));
        const code = await bundler.bundle();
        fs_extra_1.default.outputFileSync(path_1.default.join(opts.dir, 'chunks/game.js'), code, 'utf8');
      }
    }
  };
}
exports.externalWasmLoader = externalWasmLoader;
/**
 * Convert the file path to asset ref URL.
 * @param file File path in absolute.
 */
function pathToAssetRefURL(file) {
  return `${assetPrefix}${(0, url_1.pathToFileURL)(file).pathname}`;
}
exports.pathToAssetRefURL = pathToAssetRefURL;
const assetPrefix = 'asset:';