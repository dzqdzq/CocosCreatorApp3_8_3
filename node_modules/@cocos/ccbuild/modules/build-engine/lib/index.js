"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildEngine = void 0;
const engine_js_1 = require("./engine-js");
const transformer_1 = require("../../transformer/lib/index.js");
const fs_extra_1 = __importDefault(require("fs-extra"));
const engine_ts_1 = require("./engine-ts");
function verifyCache(options) {
  // TODO
  return false;
}
function applyDefaultOptions(options) {
  var _a;
  (_a = options.preserveType) !== null && _a !== void 0 ? _a : options.preserveType = false;
  options.loose = true; // force using true
  if (!options.flags) {
    options.flags = {};
  }
  switch (options.nativeCodeBundleMode) {
    case 'asmjs':
      options.flags.NATIVE_CODE_BUNDLE_MODE = 0;
      break;
    case 'wasm':
      options.flags.NATIVE_CODE_BUNDLE_MODE = 1;
      break;
    default:
      options.flags.NATIVE_CODE_BUNDLE_MODE = 2;
      break;
  }
}
function moduleOptionsToBabelEnvModules(moduleOptions) {
  switch (moduleOptions) {
    case 'cjs':
      return 'commonjs';
    case 'system':
      return 'systemjs';
    case 'iife':
    case 'esm':
      return false;
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    default:
      throw new Error(`Unknown module format ${moduleOptions}`);
  }
}
/**
 * @group Merged Types
 */
async function buildEngine(options) {
  applyDefaultOptions(options);
  if (verifyCache(options)) {
    throw 'TODO';
  }
  if (options.platform === 'OPEN_HARMONY') {
    if (options.preserveType) {
      // we use a custom engine builder for OPEN_HARMONY platform when enable preserveType option.
      return (0, engine_ts_1.buildTsEngine)(options);
    } else {
      return (0, engine_js_1.buildJsEngine)(options);
    }
  } else {
    if (options.preserveType) {
      console.warn(`Currently we haven't support building ts engine on the platform ${options.platform}`);
    }
    return (0, engine_js_1.buildJsEngine)(options);
  }
}
exports.buildEngine = buildEngine;
/**
 * @group Merged Types
 */
(function (buildEngine) {
  async function transform(code, moduleOption, loose) {
    const babelFormat = moduleOptionsToBabelEnvModules(moduleOption);
    const babelFileResult = await transformer_1.babel.core.transformAsync(code, {
      presets: [[transformer_1.babel.presets.presetEnv, {
        modules: babelFormat,
        loose: loose !== null && loose !== void 0 ? loose : true
      }]]
    });
    if (!babelFileResult || !babelFileResult.code) {
      throw new Error('Failed to transform!');
    }
    return {
      code: babelFileResult.code
    };
  }
  buildEngine.transform = transform;
  async function isSourceChanged(incrementalFile) {
    let record;
    try {
      record = await fs_extra_1.default.readJSON(incrementalFile);
    } catch (_a) {
      console.debug(`Failed to read incremental file: ${incrementalFile} - rebuild is needed.`);
      return true;
    }
    for (const file of Object.keys(record)) {
      const mtime = record[file];
      try {
        /* eslint-disable-next-line no-await-in-loop */
        const mtimeNow = (await fs_extra_1.default.stat(file)).mtimeMs;
        if (mtimeNow !== mtime) {
          console.debug(`Source ${file} in watch files record ${incrementalFile} has a different time stamp - rebuild is needed.`);
          return true;
        }
      } catch (_b) {
        console.debug(`Failed to read source ${file} in watch files record ${incrementalFile} - rebuild is needed.`);
        return true;
      }
    }
    return false;
  }
  buildEngine.isSourceChanged = isSourceChanged;
  // eslint-disable-next-line no-inner-declarations
  function _enumerateDependentChunks(meta, featureUnits) {
    const metaExports = meta.exports;
    const metaDepGraph = meta.chunkDepGraph;
    const result = [];
    const visited = new Set();
    const addChunk = chunkFileName => {
      if (visited.has(chunkFileName)) {
        return;
      }
      visited.add(chunkFileName);
      result.push(chunkFileName);
      if (metaDepGraph && chunkFileName in metaDepGraph) {
        for (const dependencyChunk of metaDepGraph[chunkFileName]) {
          addChunk(dependencyChunk);
        }
      }
    };
    for (const featureUnit of featureUnits) {
      const chunkFileName = metaExports[featureUnit];
      if (!chunkFileName) {
        console.error(`Feature unit ${featureUnit} is not in build result!`);
        continue;
      }
      addChunk(chunkFileName);
    }
    return result;
  }
  // eslint-disable-next-line no-inner-declarations
  function _enumerateDependentAssets(meta, dependentChunks) {
    const metaDepAsset = meta.assetDepGraph;
    let result = [];
    for (const chunkName of dependentChunks) {
      const depAssets = metaDepAsset[chunkName];
      if ((depAssets === null || depAssets === void 0 ? void 0 : depAssets.length) > 0) {
        result = result.concat(depAssets);
      }
    }
    return result;
  }
  /**
   * Enumerates all chunk files that used by specified feature units.
   * @param meta Metadata of build result.
   * @param featureUnits Feature units.
   */
  function enumerateDependentChunks(meta, featureUnits) {
    return _enumerateDependentChunks(meta, featureUnits);
  }
  buildEngine.enumerateDependentChunks = enumerateDependentChunks;
  /**
   * Enumerates all asset files that used by specified feature units.
   * @param meta Metadata of build result.
   * @param featureUnits Feature units.
   */
  function enumerateDependentAssets(meta, featureUnits) {
    const dependentChunks = _enumerateDependentChunks(meta, featureUnits);
    return _enumerateDependentAssets(meta, dependentChunks);
  }
  buildEngine.enumerateDependentAssets = enumerateDependentAssets;
  /**
   * Enumerates all chunk files and asset files that used by specified feature units.
   * @param meta Metadata of build result.
   * @param featureUnits Feature units.
   */
  function enumerateAllDependents(meta, featureUnits) {
    const dependentChunks = _enumerateDependentChunks(meta, featureUnits);
    const dependentAssets = _enumerateDependentAssets(meta, dependentChunks);
    return dependentAssets.concat(dependentChunks);
  }
  buildEngine.enumerateAllDependents = enumerateAllDependents;
})(buildEngine = exports.buildEngine || (exports.buildEngine = {}));