"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.build = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const gift = __importStar(require("tfig"));
const stats_query_1 = require("../../stats-query/lib/index.js");
const utils_1 = require("../../utils/lib/index.js");
const transformer_1 = require("../../transformer/lib/index.js");
const modularize_1 = require("../../modularize/lib/index.js");
var ts = transformer_1.typescript.core;
const DEBUG = false;
const REMOVE_OLD = !DEBUG;
const RECOMPILE = !DEBUG;
const REMOVE_UNBUNDLED_CACHE = !DEBUG;
async function build(options) {
  var _a;
  console.log(`Typescript version: ${ts.version}`);
  const {
    engine,
    outDir
  } = options;
  await fs_extra_1.default.ensureDir(outDir);
  // TODO: should this be a build options ?
  const withIndex = true;
  const withExports = false;
  const withEditorExports = true;
  console.debug(`With index: ${withIndex}`);
  console.debug(`With exports: ${withExports}`);
  console.debug(`With editor exports: ${withEditorExports}`);
  const statsQuery = await stats_query_1.StatsQuery.create(engine);
  const moduleQuery = new modularize_1.ModuleQuery({
    engine,
    platform: 'WEB_EDITOR',
    customExportConditions: ['types']
  });
  const moduleExportMap = await moduleQuery.getExportMap();
  // NOTE: to record the imported modules, we only bundle the imported modules, not all engine modules.
  const importedModules = [];
  const tsConfigPath = statsQuery.tsConfigPath;
  const unbundledOutDir = utils_1.ps.join(engine, '__dts_before_bundle');
  const parsedCommandLine = ts.getParsedCommandLineOfConfigFile(tsConfigPath, {
    declaration: true,
    noEmit: false,
    emitDeclarationOnly: true,
    outFile: undefined,
    outDir: unbundledOutDir
  }, {
    onUnRecoverableConfigFileDiagnostic: () => {},
    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,
    readDirectory: ts.sys.readDirectory,
    getCurrentDirectory: ts.sys.getCurrentDirectory,
    fileExists: ts.sys.fileExists,
    readFile: ts.sys.readFile
  });
  if (!parsedCommandLine) {
    throw new Error(`Can not get 'parsedCommandLine'.`);
  }
  const unbundledOutDirNormalized = utils_1.ps.resolve(engine, parsedCommandLine.options.outDir);
  console.debug(`Unbundled will write to: ${unbundledOutDirNormalized}`);
  await fs_extra_1.default.ensureDir(unbundledOutDirNormalized);
  if (REMOVE_OLD) {
    await fs_extra_1.default.emptyDir(unbundledOutDirNormalized);
  }
  console.log(`Generating...`);
  const featureUnits = statsQuery.getFeatureUnits().filter(m => m !== 'wait-for-ammo-instantiation');
  const editorExportModules = statsQuery.getEditorPublicModules();
  if (RECOMPILE) {
    let fileNames = parsedCommandLine.fileNames;
    if (withEditorExports) {
      fileNames = fileNames.concat(editorExportModules.map(e => statsQuery.getEditorPublicModuleFile(e)));
    }
    const host = ts.createCompilerHost(parsedCommandLine.options);
    host.resolveModuleNames = (moduleNames, importer) => {
      const resolvedModules = [];
      for (const moduleName of moduleNames) {
        const exportPath = moduleExportMap[moduleName];
        if (exportPath) {
          if (!importedModules.includes(moduleName)) {
            importedModules.push(moduleName);
          }
          resolvedModules.push({
            resolvedFileName: exportPath
          });
        } else {
          const resolvedRes = ts.resolveModuleName(moduleName, importer, parsedCommandLine.options, host);
          if (resolvedRes.resolvedModule) {
            resolvedModules.push({
              resolvedFileName: resolvedRes.resolvedModule.resolvedFileName
            });
          } else {
            // Cannot resolve module, treat it as external.
            resolvedModules.push(undefined);
          }
        }
      }
      return resolvedModules;
    };
    const program = ts.createProgram(fileNames, parsedCommandLine.options, host);
    const emitResult = program.emit(undefined,
    // targetSourceFile
    undefined,
    // writeFile
    undefined,
    // cancellationToken,
    true,
    // emitOnlyDtsFiles
    undefined);
    const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
    for (const diagnostic of allDiagnostics) {
      let printer;
      switch (diagnostic.category) {
        case ts.DiagnosticCategory.Error:
          printer = console.error;
          break;
        case ts.DiagnosticCategory.Warning:
          printer = console.warn;
          break;
        case ts.DiagnosticCategory.Message:
        case ts.DiagnosticCategory.Suggestion:
        default:
          printer = console.log;
          break;
      }
      if (!printer) {
        continue;
      }
      if (diagnostic.file && diagnostic.start !== undefined) {
        const {
          line,
          character
        } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
        const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, ts.sys.newLine);
        printer(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);
      } else {
        printer(`${ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n')}`);
      }
    }
  }
  const patchSpineCoreDtsSource = utils_1.ps.join(engine, 'cocos', 'spine', 'lib', 'spine-core.d.ts');
  const patchSpineCoreDtsTarget = utils_1.ps.join(unbundledOutDirNormalized, 'cocos', 'spine', 'lib', 'spine-core.d.ts');
  if (!(await fs_extra_1.default.pathExists(patchSpineCoreDtsSource))) {
    console.debug(`Does 'cocos/spine/lib/spine-core.d.ts' no longer existed? I have a patch for it.`);
  } else {
    console.debug(`It's ${new Date().toLocaleString()}, we're still doing the hack for spine-core.d.ts`);
    await fs_extra_1.default.ensureDir(utils_1.ps.dirname(patchSpineCoreDtsTarget));
    await fs_extra_1.default.copyFile(patchSpineCoreDtsSource, patchSpineCoreDtsTarget);
  }
  const rebasedModuleExportMap = {};
  for (const [moduleName, modulePath] of Object.entries(moduleExportMap)) {
    let rebasedPath = utils_1.ps.rebasePath(modulePath, engine, unbundledOutDirNormalized);
    if (!rebasedPath.endsWith('.d.ts')) {
      rebasedPath = utils_1.ps.replaceExtname(rebasedPath, '.ts', '.d.ts');
    }
    rebasedModuleExportMap[moduleName] = rebasedPath;
  }
  const giftInputs = [];
  const types = (_a = parsedCommandLine.options.types) === null || _a === void 0 ? void 0 : _a.map(typeFile => `${typeFile}.d.ts`);
  if (types) {
    for (let file of types) {
      const isBareSpecifier = !file.includes('/');
      if (isBareSpecifier) {
        file = require.resolve(`@types/${file.slice(0, -'.d.ts'.length)}`, {
          paths: [engine]
        });
      }
      if (!utils_1.ps.isAbsolute(file)) {
        file = utils_1.ps.join(utils_1.ps.dirname(tsConfigPath), file);
      }
      giftInputs.push(file);
    }
  }
  const listGiftInputs = async dir => {
    for (const file of await fs_extra_1.default.readdir(dir)) {
      const path = utils_1.ps.join(dir, file);
      // eslint-disable-next-line no-await-in-loop
      const stats = await fs_extra_1.default.stat(path);
      if (stats.isFile()) {
        giftInputs.push(path);
      } else if (stats.isDirectory()) {
        // eslint-disable-next-line no-await-in-loop
        await listGiftInputs(path);
      }
    }
  };
  await listGiftInputs(unbundledOutDirNormalized);
  const giftEntries = {};
  for (const [moduleName, modulePath] of Object.entries(rebasedModuleExportMap)) {
    if (importedModules.includes(moduleName)) {
      giftInputs.push(modulePath);
    }
  }
  const getModuleNameInTsOutFile = moduleFile => {
    const path = utils_1.ps.relative(statsQuery.path, moduleFile);
    const pathDts = path.replace(/\.ts$/, '.d.ts');
    return utils_1.ps.join(unbundledOutDirNormalized, pathDts);
  };
  if (withExports) {
    for (const exportEntry of featureUnits) {
      giftEntries[exportEntry] = getModuleNameInTsOutFile(statsQuery.getFeatureUnitFile(exportEntry));
    }
  }
  if (withEditorExports) {
    for (const editorExportModule of editorExportModules) {
      giftEntries[editorExportModule] = getModuleNameInTsOutFile(statsQuery.getEditorPublicModuleFile(editorExportModule));
    }
    for (const [moduleName, modulePath] of Object.entries(rebasedModuleExportMap)) {
      if (moduleName.endsWith('/editor') && importedModules.includes(moduleName)) {
        const editorModuleName = transformToEditorModuleName(moduleName);
        giftEntries[editorModuleName] = modulePath;
      }
    }
  }
  let ccDtsFile;
  if (withIndex && !withExports) {
    ccDtsFile = utils_1.ps.join(unbundledOutDirNormalized, 'virtual-cc.d.ts');
    giftEntries.cc = ccDtsFile;
    giftInputs.push(ccDtsFile);
    const code = `// Auto-generated\n${statsQuery.evaluateIndexModuleSource(featureUnits, featureUnit => getModuleNameInTsOutFile(statsQuery.getFeatureUnitFile(featureUnit)).replace(/\\/g, '/').replace(/\.d.ts$/, ''))}\n`;
    await fs_extra_1.default.writeFile(ccDtsFile, code, {
      encoding: 'utf8'
    });
  }
  console.log(`Bundling...`);
  try {
    const indexOutputPath = utils_1.ps.join(outDir, 'cc.d.ts');
    const giftResult = gift.bundle({
      input: giftInputs,
      rootDir: unbundledOutDirNormalized,
      name: 'cc',
      rootModule: 'index',
      entries: giftEntries,
      priority: [...(ccDtsFile ? [ccDtsFile] : []) // Things should be exported to 'cc' as far as possible.
      ],

      privateJsDocTag: 'engineInternal',
      groups: [{
        test: /^cc\/editor.*$/,
        path: utils_1.ps.join(outDir, 'cc.editor.d.ts')
      }, {
        test: /^cc\/.*$/,
        path: utils_1.ps.join(outDir, 'index.d.ts')
      }, {
        test: /^cc.*$/,
        path: indexOutputPath
      }],
      nonExportedSymbolDistribution: [{
        sourceModule: /cocos\/animation\/marionette/,
        targetModule: 'cc/editor/new-gen-anim'
      }, {
        sourceModule: /.*/,
        targetModule: 'cc'
      }],
      moduleMap: rebasedModuleExportMap
    });
    await Promise.all(giftResult.groups.map(async group => {
      await fs_extra_1.default.outputFile(group.path, group.code, {
        encoding: 'utf8'
      });
    }));
    if (withIndex && withExports) {
      await fs_extra_1.default.outputFile(indexOutputPath, buildIndexModule(featureUnits, statsQuery), {
        encoding: 'utf8'
      });
    }
  } catch (error) {
    console.error(error);
    return false;
  } finally {
    if (REMOVE_UNBUNDLED_CACHE) {
      await fs_extra_1.default.remove(unbundledOutDirNormalized);
    }
  }
  return true;
}
exports.build = build;
function buildIndexModule(featureUnits, statsQuery) {
  return `declare module "cc" {\n${statsQuery.evaluateIndexModuleSource(featureUnits).split('\n').map(line => `    ${line}`).join('\n')}\n}`;
}
/**
 * '@cocos/moduleName' -> 'cc/editor/moduleName'
 * '@cocos/moduleName/editor' -> 'cc/editor/moduleName'
 * 'moduleName' -> 'cc/editor/moduleName'
 * @param moduleName
 */
function transformToEditorModuleName(moduleName) {
  const split = moduleName.split('/');
  moduleName = split.length > 1 ? split[1] : split[0];
  return `cc/editor/${moduleName}`;
}