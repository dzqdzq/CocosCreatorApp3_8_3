"use strict";
// Fork of https://github.com/loganfsmyth/babel-plugin-proposal-decorators-legacy
// based on version 7.16.7
Object.defineProperty(exports, "__esModule", { value: true });
exports.genVisitor = void 0;
const core_1 = require("@babel/core");
const helpers_1 = require("./helpers");
function genVisitor(fieldDecorators, editorDecorators) {
    function isAllDecorateField(decorators) {
        return decorators.every(dec => {
            const exp = dec.expression;
            if (core_1.types.isCallExpression(exp)) {
                // @ts-ignore
                const name = exp.callee.name;
                return fieldDecorators.includes(name);
            }
            else {
                // @ts-ignore
                const name = dec.expression.name;
                return fieldDecorators.includes(name);
            }
        });
    }
    //#region build
    const buildClassDecorator = core_1.template.statement(`
  DECORATOR(CLASS_REF = INNER) || CLASS_REF;
  `);
    const buildClassPrototype = core_1.template(`
  CLASS_REF.prototype;
  `);
    const buildGetDescriptor = core_1.template(`
    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);
  `);
    const buildGetObjectInitializer = core_1.template(`
    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function(){
            return TEMP;
        }
    })
  `);
    //#endregion
    //#region apply
    const WARNING_CALLS = new WeakSet();
    const FIELD_NODES = new WeakSet();
    const FILED_WARNING_CALLS = new WeakSet();
    /**
    * If the decorator expressions are non-identifiers, hoist them to before the class so we can be sure
    * that they are evaluated in order.
    */
    function applyEnsureOrdering(path) {
        // TODO: This should probably also hoist computed properties.
        const decorators = (path.isClass()
            ? [
                path,
                ...path.get("body.body"),
            ]
            : path.get("properties")).reduce((acc, prop) => {
            const node = prop.node;
            if (prop.node.decorators) {
                const decorators = prop.node.decorators = editorDecorators ?
                    prop.node.decorators.filter((dec) => {
                        const exp = dec.expression;
                        // @ts-ignore
                        let name = core_1.types.isCallExpression(exp) ? exp.callee.name : dec.expression.name;
                        return !editorDecorators.includes(name);
                    }) :
                    prop.node.decorators;
                if (decorators.length === 0) {
                    // after we cull editor decorators, if there is no any other decorator, we should remove this `node.decorators`
                    prop.node.decorators = undefined;
                }
                if (isAllDecorateField(decorators) && core_1.types.isClassProperty(node)) {
                    FIELD_NODES.add(node);
                }
            }
            return acc.concat(prop.node.decorators || []);
        }, []);
        const identDecorators = decorators.filter(decorator => !core_1.types.isIdentifier(decorator.expression));
        if (identDecorators.length === 0)
            return;
        return core_1.types.sequenceExpression(identDecorators
            .map((decorator) => {
            const expression = decorator.expression;
            const id = (decorator.expression =
                path.scope.generateDeclaredUidIdentifier("dec"));
            return core_1.types.assignmentExpression("=", id, expression);
        })
            .concat([path.node]));
    }
    /**
    * Given a class expression with class-level decorators, create a new expression
    * with the proper decorated behavior.
    */
    function applyClassDecorators(classPath) {
        if (!hasClassDecorators(classPath.node))
            return;
        const decorators = classPath.node.decorators || [];
        classPath.node.decorators = null;
        const name = classPath.scope.generateDeclaredUidIdentifier("class");
        return decorators
            .map(dec => dec.expression)
            .reverse()
            .reduce(function (acc, decorator) {
            return buildClassDecorator({
                CLASS_REF: core_1.types.cloneNode(name),
                DECORATOR: core_1.types.cloneNode(decorator),
                INNER: acc,
            }).expression;
        }, classPath.node);
    }
    function hasClassDecorators(classNode) {
        return !!(classNode.decorators && classNode.decorators.length);
    }
    /**
    * Given a class expression with method-level decorators, create a new expression
    * with the proper decorated behavior.
    */
    function applyMethodDecorators(path, state) {
        if (!hasMethodDecorators(path.node.body.body))
            return;
        return applyTargetDecorators(path, state, 
        // @ts-expect-error ClassAccessorProperty is not supported in legacy decorator
        path.node.body.body);
    }
    function hasMethodDecorators(body) {
        return body.some(node => { var _a; 
        // @ts-expect-error decorators not in SpreadElement/StaticBlock
        return (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.length; });
    }
    /**
    * Given an object expression with property decorators, create a new expression
    * with the proper decorated behavior.
    */
    function applyObjectDecorators(path, state) {
        if (!hasMethodDecorators(path.node.properties))
            return;
        return applyTargetDecorators(path, state, path.node.properties.filter((prop) => prop.type !== "SpreadElement"));
    }
    /**
    * A helper to pull out property decorators into a sequence expression.
    */
    function applyTargetDecorators(path, state, decoratedProps) {
        const name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? "class" : "obj");
        const exprs = decoratedProps.reduce(function (acc, node) {
            let decorators = [];
            if (node.decorators != null) {
                decorators = node.decorators;
                node.decorators = null;
            }
            if (decorators.length === 0)
                return acc;
            if (
            // @ts-expect-error computed is not in ClassPrivateProperty
            node.computed) {
                throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");
            }
            const property = core_1.types.isLiteral(node.key)
                ? node.key
                : core_1.types.stringLiteral(
                // @ts-expect-error: should we handle ClassPrivateProperty?
                node.key.name);
            const target = path.isClass() && !node.static
                ? buildClassPrototype({
                    CLASS_REF: name,
                }).expression
                : name;
            if (core_1.types.isClassProperty(node, { static: false })) {
                if (FIELD_NODES.has(node)) {
                    const initializerIdentifier = path.scope.generateDeclaredUidIdentifier("initializer");
                    const initializer = node.value
                        ? core_1.types.functionExpression(null, [], core_1.types.blockStatement([core_1.types.returnStatement(node.value)]))
                        : core_1.types.nullLiteral();
                    node.value = core_1.types.callExpression(
                    // @ts-ignore
                    state.addHelper("initializerWarningHelper"), [initializerIdentifier, core_1.types.thisExpression()]);
                    FILED_WARNING_CALLS.add(node.value);
                    acc.push(
                    // @ts-ignore
                    core_1.types.assignmentExpression("=", core_1.types.cloneNode(initializerIdentifier), core_1.types.callExpression(helpers_1.addHelper(state, 'applyDecoratedInitializer'), [
                        core_1.types.cloneNode(target),
                        core_1.types.cloneNode(property),
                        core_1.types.arrayExpression(decorators.map(dec => core_1.types.cloneNode(dec.expression))),
                        initializer
                    ])));
                }
                else {
                    const descriptor = path.scope.generateDeclaredUidIdentifier("descriptor");
                    const initializer = node.value
                        ? core_1.types.functionExpression(null, [], core_1.types.blockStatement([core_1.types.returnStatement(node.value)]))
                        : core_1.types.nullLiteral();
                    node.value = core_1.types.callExpression(
                    // @ts-ignore
                    state.addHelper("initializerWarningHelper"), [descriptor, core_1.types.thisExpression()]);
                    WARNING_CALLS.add(node.value);
                    acc.push(
                    // @ts-ignore
                    core_1.types.assignmentExpression("=", core_1.types.cloneNode(descriptor), core_1.types.callExpression(
                    // @ts-ignore
                    state.addHelper("applyDecoratedDescriptor"), [
                        core_1.types.cloneNode(target),
                        core_1.types.cloneNode(property),
                        core_1.types.arrayExpression(decorators.map(dec => core_1.types.cloneNode(dec.expression))),
                        core_1.types.objectExpression([
                            core_1.types.objectProperty(core_1.types.identifier("configurable"), core_1.types.booleanLiteral(true)),
                            core_1.types.objectProperty(core_1.types.identifier("enumerable"), core_1.types.booleanLiteral(true)),
                            core_1.types.objectProperty(core_1.types.identifier("writable"), core_1.types.booleanLiteral(true)),
                            core_1.types.objectProperty(core_1.types.identifier("initializer"), initializer),
                        ]),
                    ])));
                }
            }
            else {
                acc.push(
                // @ts-ignore
                core_1.types.callExpression(state.addHelper("applyDecoratedDescriptor"), [
                    core_1.types.cloneNode(target),
                    core_1.types.cloneNode(property),
                    core_1.types.arrayExpression(decorators.map(dec => core_1.types.cloneNode(dec.expression))),
                    core_1.types.isObjectProperty(node) || core_1.types.isClassProperty(node, { static: true })
                        ? buildGetObjectInitializer({
                            TEMP: path.scope.generateDeclaredUidIdentifier("init"),
                            TARGET: core_1.types.cloneNode(target),
                            PROPERTY: core_1.types.cloneNode(property),
                        }).expression
                        : buildGetDescriptor({
                            TARGET: core_1.types.cloneNode(target),
                            PROPERTY: core_1.types.cloneNode(property),
                        }).expression,
                    core_1.types.cloneNode(target),
                ]));
            }
            return acc;
        }, []);
        return core_1.types.sequenceExpression([
            core_1.types.assignmentExpression("=", core_1.types.cloneNode(name), path.node),
            core_1.types.sequenceExpression(exprs),
            core_1.types.cloneNode(name),
        ]);
    }
    function decoratedClassToExpression({ node, scope }) {
        if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {
            return;
        }
        const ref = node.id
            ? core_1.types.cloneNode(node.id)
            : scope.generateUidIdentifier("class");
        return core_1.types.variableDeclaration("let", [
            core_1.types.variableDeclarator(ref, core_1.types.toExpression(node)),
        ]);
    }
    //#endregion
    //#region visitor
    const visitor = {
        ExportDefaultDeclaration(path) {
            const decl = path.get("declaration");
            if (!decl.isClassDeclaration())
                return;
            const replacement = decoratedClassToExpression(decl);
            if (replacement) {
                const [varDeclPath] = path.replaceWithMultiple([
                    replacement,
                    core_1.types.exportNamedDeclaration(null, [
                        core_1.types.exportSpecifier(
                        // @ts-expect-error todo(flow->ts) might be add more specific return type for decoratedClassToExpression
                        core_1.types.cloneNode(replacement.declarations[0].id), core_1.types.identifier("default")),
                    ]),
                ]);
                if (!decl.node.id) {
                    path.scope.registerDeclaration(varDeclPath);
                }
            }
        },
        ClassDeclaration(path) {
            const replacement = decoratedClassToExpression(path);
            if (replacement) {
                path.replaceWith(replacement);
            }
        },
        ClassExpression(path, state) {
            // Create a replacement for the class node if there is one. We do one pass to replace classes with
            // class decorators, and a second pass to process method decorators.
            const decoratedClass = applyEnsureOrdering(path) ||
                applyClassDecorators(path) ||
                applyMethodDecorators(path, state);
            if (decoratedClass)
                path.replaceWith(decoratedClass);
        },
        ObjectExpression(path, state) {
            const decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);
            if (decoratedObject)
                path.replaceWith(decoratedObject);
        },
        AssignmentExpression(path, state) {
            if (FILED_WARNING_CALLS.has(path.node.right)) {
                const thisExp = path.get("left.object").node;
                // @ts-ignore
                const propString = path.get("left.property").node.name || path.get("left.property").node.value;
                // @ts-ignore
                const initializeIdentifier = path.get("right.arguments")[0].node;
                path.replaceWith(core_1.types.assignmentExpression('=', core_1.types.memberExpression(core_1.types.cloneNode(thisExp), core_1.types.identifier(propString)), core_1.types.logicalExpression('&&', core_1.types.cloneNode(initializeIdentifier), core_1.types.callExpression(core_1.types.cloneNode(initializeIdentifier), []))));
            }
            else if (WARNING_CALLS.has(path.node.right)) {
                path.replaceWith(
                // @ts-ignore
                core_1.types.callExpression(state.addHelper("initializerDefineProperty"), [
                    // @ts-expect-error todo(flow->ts) typesafe NodePath.get
                    core_1.types.cloneNode(path.get("left.object").node),
                    core_1.types.stringLiteral(
                    // @ts-expect-error todo(flow->ts) typesafe NodePath.get
                    path.get("left.property").node.name ||
                        // @ts-expect-error todo(flow->ts) typesafe NodePath.get
                        path.get("left.property").node.value),
                    // @ts-expect-error todo(flow->ts)
                    core_1.types.cloneNode(path.get("right.arguments")[0].node),
                    // @ts-expect-error todo(flow->ts)
                    core_1.types.cloneNode(path.get("right.arguments")[1].node),
                ]));
            }
        },
        CallExpression(path, state) {
            if (path.node.arguments.length !== 3)
                return;
            // If the class properties plugin isn't enabled, this line will add an unused helper
            // to the code. It's not ideal, but it's ok since the configuration is not valid anyway.
            // @ts-expect-error todo(flow->ts) check that `callee` is Identifier
            if (path.node.callee.name !== state.addHelper("defineProperty").name) {
                return;
            }
            if (FILED_WARNING_CALLS.has(path.node.arguments[2])) {
                const thisExp = path.get("arguments")[0].node;
                // @ts-ignore
                const propString = path.get("arguments")[1].node.value;
                // @ts-ignore
                const initializeIdentifier = path.get("arguments.2.arguments")[0].node;
                path.replaceWith(core_1.types.assignmentExpression('=', core_1.types.memberExpression(core_1.types.cloneNode(thisExp), core_1.types.identifier(propString)), core_1.types.logicalExpression('&&', core_1.types.cloneNode(initializeIdentifier), core_1.types.callExpression(core_1.types.cloneNode(initializeIdentifier), []))));
            }
            else if (WARNING_CALLS.has(path.node.arguments[2])) {
                path.replaceWith(
                // @ts-ignore
                core_1.types.callExpression(state.addHelper("initializerDefineProperty"), [
                    core_1.types.cloneNode(path.get("arguments")[0].node),
                    core_1.types.cloneNode(path.get("arguments")[1].node),
                    // @ts-expect-error todo(flow->ts)
                    core_1.types.cloneNode(path.get("arguments.2.arguments")[0].node),
                    // @ts-expect-error todo(flow->ts)
                    core_1.types.cloneNode(path.get("arguments.2.arguments")[1].node),
                ]));
            }
        },
    };
    //#endregion
    return visitor;
}
exports.genVisitor = genVisitor;
//# sourceMappingURL=legacy-visitor.js.map