"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportMapBackTrackingError = exports.ImportMapImportMatchError = exports.ImportMapNullEntryError = exports.importMapResolve = void 0;
const asserts_1 = require("@cocos/creator-programming-common/lib/asserts");
const url_1 = require("@cocos/creator-programming-common/lib/url");
const i18n_1 = require("@cocos/creator-programming-common/lib/i18n");
/**
 * @param specifier
 * @param asURL
 * @param parentURL
 * @param importMap
 */
function importMapResolve(specifier, asURL, parentURL, importMap) {
    const normalizedSpecifier = asURL ? asURL.href : specifier;
    const parentURLString = parentURL.href;
    for (const [scopePrefix, scopeImports] of importMap.scopes) {
        if (scopePrefix === parentURLString || scopePrefix.endsWith('/') && parentURLString.startsWith(scopePrefix)) {
            const scopeImportsMatch = resolveImportsMatch(normalizedSpecifier, asURL, scopeImports);
            if (scopeImportsMatch) {
                return scopeImportsMatch;
            }
        }
    }
    const topLevelImportsMatch = resolveImportsMatch(normalizedSpecifier, asURL, importMap.imports);
    if (topLevelImportsMatch) {
        return topLevelImportsMatch;
    }
    else {
        return undefined;
    }
}
exports.importMapResolve = importMapResolve;
function resolveImportsMatch(normalizedSpecifier, asURL, specifierMap) {
    for (const [specifierKey, resolutionResult] of specifierMap) {
        if (specifierKey === normalizedSpecifier) {
            if (resolutionResult === null) {
                throw new ImportMapNullEntryError();
            }
            else {
                return resolutionResult;
            }
        }
        if (specifierKey.endsWith('/') &&
            normalizedSpecifier.startsWith(specifierKey) &&
            (asURL === null || isSpecialURL(asURL))) {
            if (resolutionResult === null) {
                throw new ImportMapNullEntryError();
            }
            const afterPrefix = normalizedSpecifier.substr(specifierKey.length);
            asserts_1.asserts(resolutionResult.href.endsWith('/'));
            const url = url_1.tryParseURL(afterPrefix, resolutionResult);
            if (!url) {
                throw new ImportMapImportMatchError();
            }
            if (!url.href.startsWith(resolutionResult.href)) {
                throw new ImportMapBackTrackingError(specifierKey);
            }
            return url;
        }
    }
    return null;
}
function isSpecialURL(url) {
    // https://url/utils.spec.whatwg.org/#is-special
    return [
        'ftp:',
        'file:',
        'http:',
        'https:',
        'ws:',
        'wss:',
        'db:',
    ].includes(url.protocol);
}
class ImportMapNullEntryError extends Error {
    constructor() { super(i18n_1.i18nTranslate('import_map_null_entry_error')); }
}
exports.ImportMapNullEntryError = ImportMapNullEntryError;
class ImportMapImportMatchError extends Error {
    constructor() { super(i18n_1.i18nTranslate('import_map_import_match_error')); }
}
exports.ImportMapImportMatchError = ImportMapImportMatchError;
class ImportMapBackTrackingError extends Error {
    constructor(prefix) { super(i18n_1.i18nTranslate('import_map_back_tracking_error', { prefix })); }
}
exports.ImportMapBackTrackingError = ImportMapBackTrackingError;
//# sourceMappingURL=import-map-resolve.js.map