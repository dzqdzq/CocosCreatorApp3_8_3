"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportMapParseError = exports.parseImportMap = void 0;
const url_1 = require("url");
const i18n_1 = require("@cocos/creator-programming-common/lib/i18n");
function parseImportMap(json, baseUrl) {
    if (typeof json !== 'object') {
        throw new ImportMapParseError(`The top-level value needs to be a JSON object.`);
    }
    const parsed = { imports: [], scopes: [] };
    let nValidKeys = 0;
    if (('imports' in json)) {
        ++nValidKeys;
        const imports = json.imports;
        if (typeof imports !== 'object') {
            throw new ImportMapParseError(`The "imports" top-level key needs to be a JSON object.`);
        }
        parsed.imports = sortAndNormalizeSpecifierMap(imports, baseUrl);
    }
    if (('scopes' in json)) {
        ++nValidKeys;
        const scopes = json.scopes;
        if (typeof scopes !== 'object') {
            throw new ImportMapParseError(`The "scopes" top-level key needs to be a JSON object.`);
        }
        parsed.scopes = sortAndNormalizeScopes(scopes, baseUrl);
    }
    for (const key of Object.keys(json)) {
        if (key !== 'imports' && key !== 'scopes') {
            console.warn(`An invalid top-level key ${key} was present in the import map.`);
        }
    }
    return parsed;
}
exports.parseImportMap = parseImportMap;
function sortAndNormalizeSpecifierMap(originalMap, baseUrl) {
    const normalized = [];
    for (const specifierKey in originalMap) {
        const normalizedSpecifierKey = normalizeSpecifierKey(specifierKey, baseUrl);
        if (normalizedSpecifierKey === null) {
            continue;
        }
        const value = originalMap[specifierKey];
        if (typeof value !== 'string') {
            console.warn(`The address need to be strings.`);
            normalized.push([normalizedSpecifierKey, null]);
            continue;
        }
        const addressUrl = parseUrlLikeImportSpecifier(value, baseUrl);
        if (addressUrl === null) {
            console.warn(`The address was invalid.`);
            normalized.push([normalizedSpecifierKey, null]);
            continue;
        }
        if (specifierKey.endsWith('/') && !serializeUrl(addressUrl).endsWith('/')) {
            console.warn(`an invalid address was given for the specifier key ${specifierKey}; ` +
                `since ${specifierKey} ended in a slash, the address needs to as well.`);
            normalized.push([normalizedSpecifierKey, null]);
            continue;
        }
        normalized.push([normalizedSpecifierKey, addressUrl]);
    }
    sortMap(normalized);
    return normalized;
}
function sortAndNormalizeScopes(originalMap, baseUrl) {
    const normalized = [];
    for (const scopePrefix in originalMap) {
        const potentialSpecifierMap = originalMap[scopePrefix];
        if (typeof potentialSpecifierMap !== 'object') {
            throw new ImportMapParseError(`The value of the scope with prefix ${scopePrefix} needs to be a JSON object.`);
        }
        const scopePrefixUrl = parseUrl(scopePrefix, baseUrl);
        if (!scopePrefixUrl) {
            console.warn(`The scope prefix URL ${scopePrefixUrl} was not parsable.`);
            continue;
        }
        const normalizedScopePrefix = serializeUrl(scopePrefixUrl);
        normalized.push([
            normalizedScopePrefix,
            sortAndNormalizeSpecifierMap(potentialSpecifierMap, baseUrl),
        ]);
    }
    sortMapReverse(normalized);
    return normalized;
}
function sortMap(map) {
    return map.sort(([a], [b]) => a > b ? 1 : (a < b ? -1 : 0));
}
function sortMapReverse(map) {
    return map.sort(([b], [a]) => a > b ? 1 : (a < b ? -1 : 0));
}
function normalizeSpecifierKey(key, baseUrl) {
    if (key.length === 0) {
        console.warn(`Specifier keys cannot be the empty string.`);
        return null;
    }
    const url = parseUrlLikeImportSpecifier(key, baseUrl);
    if (url) {
        return serializeUrl(url);
    }
    return key;
}
function parseUrlLikeImportSpecifier(specifier, baseUrl) {
    if (specifier.startsWith('/') ||
        specifier.startsWith('./') ||
        specifier.startsWith('../')) {
        return parseUrl(specifier, baseUrl);
    }
    return parseUrl(specifier);
}
function parseUrl(url, base) {
    try {
        return new url_1.URL(url, base);
    }
    catch (_a) {
        return null;
    }
}
function serializeUrl(url) {
    return url.href;
}
class ImportMapParseError extends Error {
    constructor(message) { super(i18n_1.i18nTranslate('import_map_parse_error')); }
}
exports.ImportMapParseError = ImportMapParseError;
//# sourceMappingURL=parse-import-map.js.map