"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mTimestampToString = exports.isEqualMTimestamp = exports.FetchFileError = exports.AccessDeniedError = exports.ModLo = exports.MemoryModule = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const wrapper_1 = require("./cjs/wrapper");
const url_1 = require("url");
const mod_lo_builtin_mods_1 = require("./utils/mod-lo-builtin-mods");
const asserts_1 = require("@cocos/creator-programming-common/lib/asserts");
const perf_hooks_1 = require("perf_hooks");
const url_2 = require("@cocos/creator-programming-common/lib/url");
const creator_programming_common_1 = require("@cocos/creator-programming-common");
const logger_1 = require("@cocos/creator-programming-common/lib/logger");
const esm_resolve_1 = require("./resolver/esm-resolve");
const resolve_error_1 = require("./resolver/resolve-error");
const parse_import_map_1 = require("@cocos/creator-programming-import-maps/lib/parse-import-map");
const cjs_resolve_1 = require("./resolver/cjs-resolve");
const specifier_1 = require("@cocos/creator-programming-common/lib/specifier");
const i18n_1 = require("@cocos/creator-programming-common/lib/i18n");
const babel_transformer_1 = require("./transformer/babel/babel-transformer");
// import { SwcTransformer } from './transformer/swc/swc-transformer';
const crypto_1 = __importDefault(require("crypto"));
const minimatch_1 = require("minimatch");
const esmDataURIPrefix = 'data:text/javascript,';
class MemoryModule {
    constructor(source) {
        this.source = source;
    }
    get source() {
        return this._source;
    }
    set source(value) {
        this._source = value;
        this._mTimestamp = perf_hooks_1.performance.now();
    }
    get mTimestamp() {
        return this._mTimestamp;
    }
}
exports.MemoryModule = MemoryModule;
/**
 * The uniform Module Loader.
 */
class ModLo {
    constructor({ transformer: transformerType = 'babel', targets, exportsConditions, loose = false, useDefineForClassFields = true, allowDeclareFields = true, guessCommonJsExports = false, _importMetaURLValid = true, _helperModule = '', cr, _compressUUID, transformExcludes: transformExcludes, logger, _internalTransform, checkObsolete = false, hot, importRestrictions, preserveSymlinks = false, }) {
        this._origin = new url_1.URL('unspecified-origin:/');
        this._assetPrefixes = [];
        this._uuidMap = new Map();
        this._externals = [];
        this._loadMappings = [];
        this._memoryModules = {};
        this._conditions = [];
        this._crFilter = null;
        this._helperURL = undefined;
        this._helperModuleMTimestamp = 0;
        this._transformExcludesModuleFilter = new ModuleFilter();
        this._preserveSymlinks = false;
        const transformer = (() => {
            // if (transformerType == 'babel') {
            return new babel_transformer_1.BabelTransformer({
                targets,
                loose,
                useDefineForClassFields,
                allowDeclareFields,
                _helperModule,
                cr,
                _internalTransform,
            });
            // } else {
            //     return new SwcTransformer({
            //         targets,
            //         loose,
            //         useDefineForClassFields,
            //         allowDeclareFields,
            //     });
            // }
        })();
        this._transformer = transformer;
        this._guessCjsExports = guessCommonJsExports;
        this._logger = logger !== null && logger !== void 0 ? logger : (0, logger_1.createLogger)({});
        this._checkObsolete = checkObsolete;
        this._compressUUID = _compressUUID;
        this._hot = hot !== null && hot !== void 0 ? hot : false;
        if (transformExcludes) {
            for (const rule of transformExcludes) {
                this._transformExcludesModuleFilter.add(rule);
            }
        }
        if (_helperModule) {
            this._helperURL = new url_1.URL(_helperModule);
            this._helperModuleMTimestamp = perf_hooks_1.performance.now();
        }
        this._importMetaURLValid = _importMetaURLValid;
        this._importRestrictions = importRestrictions;
        this._preserveSymlinks = preserveSymlinks;
        this.setExtraExportsConditions(exportsConditions !== null && exportsConditions !== void 0 ? exportsConditions : []);
        this.setLoadMappings({});
    }
    async getMTimestamp(url) {
        if (this._helperURL && url.href === this._helperURL.href) {
            return this._helperModuleMTimestamp;
        }
        const loadURL = this._getLoadURL(url);
        return await this._getMtime(loadURL);
    }
    async load(url) {
        if (this._helperURL && url.href === this._helperURL.href) {
            return await this._transformer.loadHelper(this._helperURL);
        }
        const loadURL = this._getLoadURL(url);
        const source = await this._loadSource(loadURL);
        const moduleType = await this._determinateModuleType(url);
        const disableTransform = moduleType === 'esm' || moduleType === 'commonjs'
            ? this._transformExcludesModuleFilter.test(url)
            : false;
        if (disableTransform) {
            this._logger.info(`Note: transforms are disabled for ${url.href}`);
        }
        let mod;
        if (moduleType === 'esm') {
            const cr = this._isAssetModule(url);
            const transformOptions = {
                cr,
                checkObsolete: this._checkObsolete,
            };
            const uuid = this._uuidMap.get(url.href);
            if (uuid !== undefined) {
                const baseName = (0, url_2.getBaseName)(url);
                const compressedUUID = this._compressUUID(uuid);
                transformOptions.annotate = {
                    baseName,
                    compressedUUID,
                    hot: this._hot,
                };
            }
            mod = await this._transformer.transform(url, source, undefined, transformOptions, disableTransform);
        }
        else if (moduleType === 'json') {
            mod = await this._transformer.transformJson(url, source, undefined);
        }
        else {
            (0, asserts_1.asserts)(moduleType === 'commonjs', 'Unknown module system.');
            const id = this._importMetaURLValid ? undefined : this._generateCommonJsModuleId(url, source);
            mod = await this._transformer.transformCommonJs(url, source, undefined, id, disableTransform);
        }
        return mod;
    }
    async resolve(specifier, from, fromType) {
        const parentURL = from !== null && from !== void 0 ? from : this._origin;
        if (!fromType) {
            if (!from) {
                fromType = 'esm';
            }
            else {
                fromType = await this._determinateModuleType(from);
            }
        }
        // JSON can shall not emit import request.
        (0, asserts_1.asserts)(fromType !== 'json');
        const resolved = await this._resolveUnchecked(specifier, parentURL, fromType);
        this._detectImportRestriction(resolved, from);
        if (!resolved.isExternal && !this._preserveSymlinks) {
            const symlinkFollowedURL = this._followSymlinks(resolved.url);
            if (symlinkFollowedURL !== resolved.url) {
                return {
                    isExternal: false,
                    url: symlinkFollowedURL,
                };
            }
        }
        return resolved;
    }
    /**
     * @param externals Can be bare specifiers or URLs.
     */
    setExternals(externals) {
        this._externals.push(...externals);
    }
    addMemoryModule(url, source) {
        const urlObject = normalizeURLArg(url);
        return this._memoryModules[urlObject.href] = new MemoryModule(source);
    }
    setUUID(url, uuid) {
        assertIsURL(url);
        this._uuidMap.set(url, uuid);
    }
    unsetUUID(url) {
        assertIsURL(url);
        this._uuidMap.delete(url);
    }
    setImportMap(importMap, url) {
        this._parsedImportMap = (0, parse_import_map_1.parseImportMap)(importMap, url);
    }
    /**
     * 将一些 URL 映射到另一些 URL。主要用于映射一些 URL 到文件系统上。
     * 注意：
     * - 这个和 import map 不同。它不会改变模块的 URL，只会在加载模块源码时转而去加载文件系统上的。
     * - 键和值要么都以 / 结尾，要么都不以 / 结尾。如果以 / 结尾表示整个目录映射。
     */
    setLoadMappings(loadMappings) {
        this._loadMappings.push(...normalizeLoadMappings(mod_lo_builtin_mods_1.modLoBuiltinLoadMappings));
        if (loadMappings) {
            this._loadMappings.push(...normalizeLoadMappings(loadMappings));
        }
        this._loadMappings.sort(([a], [b]) => a > b ? 1 : -1);
    }
    setExtraExportsConditions(exportConditions) {
        this._conditions = [...esm_resolve_1.defaultConditions, ...(exportConditions !== null && exportConditions !== void 0 ? exportConditions : [])];
    }
    /**
     * 设置属于 asset 的模块 URL 的前缀。
     * @param prefixes
     */
    setAssetPrefixes(prefixes) {
        if (this._preserveSymlinks) {
            this._assetPrefixes = prefixes.slice();
        }
        else {
            this._assetPrefixes = prefixes.map((prefix) => {
                const url = (0, url_2.tryParseURL)(prefix);
                if (!url) {
                    return prefix;
                }
                const original = this._followSymlinks(url);
                return original.href;
            });
        }
    }
    _matchPattern(path, pattern) {
        return (0, minimatch_1.minimatch)(path.replace(/\\/g, '/'), pattern.replace(/\\/g, '/'));
    }
    _detectImportRestriction(resolveResult, importer) {
        if (this._importRestrictions) {
            // get resolved id
            let resolvedId;
            if (resolveResult.isExternal) {
                resolvedId = resolveResult.specifierOrURL;
            }
            else if (resolveResult.url.href.startsWith('file://')) {
                resolvedId = (0, url_1.fileURLToPath)(resolveResult.url.href);
            }
            else {
                resolvedId = resolveResult.url.href;
            }
            for (const restriction of this._importRestrictions) {
                // If it's an entry chunk, it has no importer.
                let skipDetect = !importer;
                if (importer) {
                    const from = importer.href.startsWith('file://') ? (0, url_1.fileURLToPath)(importer.href) : importer.href;
                    for (const pattern of restriction.importerPatterns) {
                        if (!this._matchPattern(from, pattern)) {
                            skipDetect = true;
                            continue;
                        }
                    }
                }
                if (skipDetect) {
                    continue;
                }
                for (const pattern of restriction.banSourcePatterns) {
                    if (this._matchPattern(resolvedId, pattern)) {
                        throw new Error(`Cannot import '${resolvedId}'${importer ? ` from '${importer.href.startsWith('file://') ? (0, url_1.fileURLToPath)(importer.href) : importer.href}'` : ''}`);
                    }
                }
            }
        }
    }
    _followSymlinks(url) {
        if (!isFileURL(url)) {
            return url;
        }
        if ((0, creator_programming_common_1.isCjsInteropUrl)(url)) {
            return url;
        }
        const path = (0, url_1.fileURLToPath)(url);
        let realPath = '';
        try {
            realPath = fs_extra_1.default.realpathSync(path);
        }
        catch (err) {
            // If error is thrown(for example, since path does not exists).
            // We treat it as not symlinks.
            return url;
        }
        if (realPath === path) {
            return url;
        }
        const realUrl = (0, url_1.pathToFileURL)(realPath);
        return realUrl;
    }
    async _getMtime(url) {
        if (url.href in this._memoryModules) {
            return this._memoryModules[url.href].mTimestamp;
        }
        if (url.href.startsWith(esmDataURIPrefix)) {
            return 0;
        }
        const filePath = tryConvertAsPath(url);
        if (filePath) {
            let sourceMtime;
            try {
                sourceMtime = (await fs_extra_1.default.stat(filePath)).mtimeMs;
            }
            catch (err) {
                this._logger.debug(`Failed to stat file '${url}' when get mtime:` + err);
                return 0;
            }
            const uuid = this._uuidMap.get(url.href);
            if (uuid) {
                return {
                    mtime: sourceMtime,
                    uuid,
                };
            }
            else {
                return sourceMtime;
            }
        }
        else {
            // TODO: may be we should relax?
            this._logger.debug(`Failed to get mtime of ${url}: not file URL`);
            return 0;
        }
    }
    _getLoadURL(url) {
        if (url.pathname.endsWith('/')) {
            (0, asserts_1.asserts)(false, `Module URL shall not ends with /.`);
            return url;
        }
        const href = url.href;
        for (const [prefix, mapped] of this._loadMappings) {
            if (href === prefix) {
                return mapped;
            }
            else if (prefix.endsWith('/') && href.startsWith(prefix)) {
                (0, asserts_1.asserts)(mapped.pathname.endsWith('/'));
                return new url_1.URL(href.substr(prefix.length), mapped);
            }
        }
        return url;
    }
    async _loadSource(url) {
        if (url.href in this._memoryModules) {
            return this._memoryModules[url.href].source;
        }
        else if ((0, creator_programming_common_1.isCjsInteropUrl)(url)) {
            return getCjsInteropSource(url);
        }
        else if (isFileURL(url)) {
            const path = (0, url_1.fileURLToPath)(url);
            try {
                return await fs_extra_1.default.readFile(path, 'utf8');
            }
            catch (err) {
                throw new FetchFileError(path, err);
            }
        }
        else if (url.href.startsWith(esmDataURIPrefix)) {
            const encoded = url.href.slice(esmDataURIPrefix.length);
            return decodeURIComponent(encoded);
        }
        else {
            let detail;
            if (url.protocol === 'db:') {
                detail = {
                    type: 'unopened-db',
                    domain: url.hostname,
                };
            }
            else if (url.protocol === 'node:') {
                detail = {
                    type: 'unsupported-node-builtins',
                };
            }
            throw new AccessDeniedError(url.href, detail);
        }
    }
    async _resolveUnchecked(specifier, from, fromType) {
        if (this._isExternal(specifier)) {
            return {
                specifierOrURL: specifier,
                isExternal: true,
            };
        }
        if (fromType === 'esm') {
            const resolved = await this._doEsmResolve(specifier, from);
            if (!resolved.isExternal) {
                const { url } = resolved;
                if (!(0, creator_programming_common_1.isCjsInteropUrl)(from) && await this._determinateModuleType(url) === 'commonjs') {
                    this._logger.debug(`Create cjs interop url for '${url.href}'`);
                    const cjsInteropURL = createCjsInteropUrl(url);
                    return {
                        isExternal: false,
                        url: cjsInteropURL,
                    };
                }
            }
            return resolved;
        }
        return await this._doCjsResolve(specifier, from);
    }
    async _doEsmResolve(specifier, from) {
        var _a;
        const stdResolved = await (0, esm_resolve_1.esmResolve)(specifier, from, {
            importMap: this._parsedImportMap,
            conditions: this._conditions,
        });
        // 对于项目脚本直接的互相导入，在标准解析的基础上，我们允许 extension-less 式的解析。
        const shouldPerformExtensionLessResolution = this._allowExtensionLessResolution(from, stdResolved);
        const extensionLessResolved = shouldPerformExtensionLessResolution
            ? (_a = await this._tryExtensionLessResolve(stdResolved, ['.ts'])) !== null && _a !== void 0 ? _a : stdResolved
            : stdResolved;
        if (extensionLessResolved.protocol === 'file:') {
            const path = (0, url_1.fileURLToPath)(extensionLessResolved);
            const stat = await this._tryStat(path);
            if (stat.isDirectory()) {
                throw new resolve_error_1.UnsupportedDirectoryImportError();
            }
            else if (!stat.isFile()) {
                throw new resolve_error_1.ModuleNotFoundError(specifier, from);
            }
        }
        // Note: we do not have "post isExternal()"
        return {
            isExternal: false,
            url: extensionLessResolved,
        };
    }
    async _tryExtensionLessResolve(url, extensions) {
        if (await this._fileExists(url)) {
            return url;
        }
        const baseName = url.pathname.split('/').pop();
        if (!baseName || baseName === '') {
            return undefined;
        }
        for (const extension of extensions) {
            let guess;
            if (await this._fileExists(guess = new url_1.URL(`./${baseName}${extension}`, url))) {
                return guess;
            }
        }
        for (const extension of extensions) {
            let guess;
            if (await this._fileExists(guess = new url_1.URL(`./${baseName}/index${extension}`, url))) {
                return guess;
            }
        }
        return undefined;
    }
    async _doCjsResolve(specifier, from) {
        // 如果 CommonJS 模块引用了一个不是文件 URL 的 URL，那么直接算解析成功。
        // 因为这里我们要插入 `cjs-loader` 的引用。
        // TODO：或许除了 `cjs-loader` 之外其它的都应该走 legacy resolve？
        if (!(0, specifier_1.isRelativeSpecifier)(specifier)) {
            const url = (0, url_2.tryParseURL)(specifier);
            if (url && !(0, url_2.hasFileProtocol)(url)) {
                return {
                    isExternal: false,
                    url,
                };
            }
        }
        const resolved = await (0, cjs_resolve_1.cjsResolve)(specifier, from);
        if (resolved.protocol === 'node:') {
            throw new resolve_error_1.ModuleNotFoundError(specifier, from);
        }
        return {
            isExternal: false,
            url: resolved,
        };
    }
    _isExternal(specifierOrURL) {
        return this._externals.includes(specifierOrURL);
    }
    async _determinateModuleType(file) {
        // https://nodejs.org/api/packages.html#packages_determining_module_system
        switch (true) {
            case !isFileURL(file):
            case file.pathname.endsWith('.mjs'):
            case file.pathname.endsWith('.ts'):
            default:
                return 'esm';
            case file.pathname.endsWith('.json'):
                return 'json';
            case file.pathname.endsWith('.cjs'):
                return 'commonjs';
            case file.pathname.endsWith('.js'): {
                const packageJson = await (0, esm_resolve_1.readPackageScope)(file);
                if (packageJson.type === 'module') {
                    return 'esm';
                }
                else {
                    return 'commonjs';
                }
            }
        }
    }
    async _tryStat(path) {
        try {
            return await fs_extra_1.default.stat(path);
        }
        catch (_a) {
            return new fs_extra_1.default.Stats();
        }
    }
    async _fileExists(url) {
        return (await this._tryStat((0, url_1.fileURLToPath)(url))).isFile();
    }
    _allowExtensionLessResolution(parent, resolved) {
        if (!parent.pathname.endsWith('.ts')) {
            return false;
        }
        if (this._isAssetModule(parent) && this._isAssetModule(resolved)) {
            return true;
        }
        return false;
    }
    _isAssetModule(url) {
        const href = url.href;
        return this._assetPrefixes.some((assetPrefix) => href.startsWith(assetPrefix));
    }
    _generateCommonJsModuleId(url, source) {
        const hash = crypto_1.default.createHash('md5').update(source, 'utf-8').digest('hex');
        const segments = url.pathname.split('/');
        if (segments.length === 0) {
            return `${hash}`;
        }
        else {
            const last = segments[segments.length - 1];
            return `${hash}-${last}`;
        }
    }
}
exports.ModLo = ModLo;
function filterModule(url, rule) {
    return typeof rule === 'string' ? url === rule : rule.test(url);
}
class ModuleFilter {
    constructor() {
        this._rules = [];
    }
    add(rule) {
        this._rules.push(rule);
    }
    test(url) {
        const href = url.href;
        return this._rules.some((rule) => filterModule(href, rule));
    }
}
class AccessDeniedError extends Error {
    constructor(url, detail) {
        let detailString = '';
        if (detail) {
            if (detail.type === 'unsupported-node-builtins') {
                detailString = (0, i18n_1.i18nTranslate)('modLo_access_denied_error_unsupported_node_builtins');
            }
            else if (detail.type === 'unopened-db') {
                detailString = (0, i18n_1.i18nTranslate)('modLo_access_denied_error_db_not_mounted', { domain: detail.domain });
            }
        }
        if (!detailString) {
            detailString = (0, i18n_1.i18nTranslate)('modLo_access_denied_error_default_reason');
        }
        super((0, i18n_1.i18nTranslate)('modLo_access_denied_error', { url }) + detailString);
    }
}
exports.AccessDeniedError = AccessDeniedError;
class FetchFileError extends Error {
    constructor(file, err) {
        super((0, i18n_1.i18nTranslate)('modLo_fetch_file_error', { path: file, cause: err }));
    }
}
exports.FetchFileError = FetchFileError;
function isEqualMTimestamp(lhs, rhs) {
    if (typeof lhs !== 'object') {
        return lhs === rhs;
    }
    else if (typeof rhs !== 'object') {
        return false;
    }
    else {
        return lhs.mtime === rhs.mtime && lhs.uuid === rhs.uuid;
    }
}
exports.isEqualMTimestamp = isEqualMTimestamp;
function mTimestampToString(mTimestamp) {
    return typeof mTimestamp === 'object'
        ? `${new Date(mTimestamp.mtime)}@${mTimestamp.uuid}`
        : `${new Date(mTimestamp)}`;
}
exports.mTimestampToString = mTimestampToString;
function normalizeURLArg(url) {
    return typeof url === 'string' ? new url_1.URL(url) : url;
}
function assertIsURL(url) {
    (0, asserts_1.asserts)(new url_1.URL(url));
}
function isFileURL(url) {
    return url.protocol === 'file:';
}
function tryConvertAsPath(url) {
    if ((0, creator_programming_common_1.isCjsInteropUrl)(url)) {
        return tryConvertAsPath((0, creator_programming_common_1.getCjsInteropTarget)(url));
    }
    else if (isFileURL(url)) {
        return (0, url_1.fileURLToPath)(url);
    }
}
function createCjsInteropUrl(url) {
    try {
        const result = new url_1.URL(`?cjs`, url);
        const originalExtension = (0, url_2.replaceExtension)(result, '.mjs');
        if (originalExtension) {
            result.searchParams.append('original', originalExtension);
        }
        return result;
    }
    catch (err) {
        throw new resolve_error_1.CjsInteropError(url, err);
    }
}
function getCjsInteropSource(url) {
    const target = (0, creator_programming_common_1.getCjsInteropTarget)(url);
    return (0, wrapper_1.getCjsInteropModuleSource)(`./${target.pathname.split('/').pop()}`);
}
function normalizeLoadMappings(loadMappings) {
    const normalized = [];
    for (const [from, to] of Object.entries(loadMappings)) {
        if (!from.endsWith('/') && to.endsWith('/')) {
            throw new Error(`Bad load mapping: '${from}': '${to}'`);
        }
        const fromURL = new url_1.URL(from);
        const toURL = new url_1.URL(to);
        normalized.push([fromURL.href, toURL]);
    }
    return normalized;
}
//# sourceMappingURL=mod-lo.js.map