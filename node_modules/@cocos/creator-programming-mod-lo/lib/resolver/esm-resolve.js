"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readPackageScope = exports.defaultLegacyMainResolveExtensions = exports.defaultConditions = exports.esmResolve = void 0;
const url_1 = require("url");
const specifier_1 = require("@cocos/creator-programming-common/lib/specifier");
const url_2 = require("@cocos/creator-programming-common/lib/url");
const resolve_error_1 = require("./resolve-error");
const fs_extra_1 = __importDefault(require("fs-extra"));
const asserts_1 = require("@cocos/creator-programming-common/lib/asserts");
const import_map_resolve_1 = require("@cocos/creator-programming-import-maps/lib/import-map-resolve");
const node_builtins_1 = require("../utils/node-builtins");
/**
 * Reference:
 * https://nodejs.org/api/esm.html#esm_resolver_algorithm
 * Modification:
 * - Import map are considered.
 */
async function esmResolve(specifier, parentURL, options) {
    var _a;
    const { conditions = exports.defaultConditions, legacyMainResolveExtensions = exports.defaultLegacyMainResolveExtensions, importMap, } = options !== null && options !== void 0 ? options : {};
    const context = {
        conditions,
        legacyMainResolveExtensions,
    };
    let asURL;
    if ((0, specifier_1.isRelativeSpecifier)(specifier)) {
        asURL = new url_1.URL(specifier, parentURL);
    }
    else {
        asURL = (_a = (0, url_2.tryParseURL)(specifier)) !== null && _a !== void 0 ? _a : null;
    }
    if (importMap) {
        const importMapResolved = (0, import_map_resolve_1.importMapResolve)(specifier, asURL, parentURL, importMap);
        if (importMapResolved) {
            return importMapResolved;
        }
    }
    if (asURL) {
        return asURL;
    }
    if (specifier.startsWith('#')) {
        return await packageImportsResolve(specifier, parentURL, context);
    }
    return await packageResolve(specifier, parentURL, context);
}
exports.esmResolve = esmResolve;
exports.defaultConditions = ['import', 'cc'];
exports.defaultLegacyMainResolveExtensions = ['.js', '.json'];
async function packageImportsResolve(_specifier, _parentURL, _context) {
    throw new Error(`We currently do not support package 'imports' field.`);
}
async function packageResolve(specifier, parentURL, context) {
    const { packageName, isScoped } = parsePackageName(specifier);
    const packageSubpath = `.${specifier.substr(packageName.length)}`;
    // Package self resolve
    const selfURL = await packageSelfResolve(packageName, packageSubpath, parentURL, context);
    if (selfURL !== undefined) {
        return selfURL;
    }
    const onlyFilePackages = true;
    let packageJsonUrl = new url_1.URL(`./node_modules/${packageName}/package.json`, parentURL);
    while (true) {
        if (onlyFilePackages && !(0, url_2.hasFileProtocol)(packageJsonUrl)) {
            break;
        }
        const packageUrl = new url_1.URL('.', packageJsonUrl);
        if (!await dirExists(packageUrl)) {
            const lastPackageJsonPathname = packageJsonUrl.pathname;
            packageJsonUrl = new url_1.URL(`${isScoped ? '../../../../' : '../../../'}node_modules/${packageName}/package.json`, packageJsonUrl);
            if (packageJsonUrl.pathname === lastPackageJsonPathname) {
                break;
            }
            continue;
        }
        const packageJson = await readPackageJson(packageJsonUrl);
        if (!isNullOrUndefined(packageJson.exports)) {
            return await packageExportsResolve(packageJsonUrl, packageSubpath, packageJson.exports, context, parentURL);
        }
        else if (packageSubpath === '.') {
            return await legacyMainResolve(packageJsonUrl, packageJson, context);
        }
        else {
            const resolved = new url_1.URL(packageSubpath, packageJsonUrl);
            return resolved;
        }
    }
    if (packageSubpath === '.' && (0, node_builtins_1.isNodeJsBuiltinModule)(packageName)) {
        return new url_1.URL((0, node_builtins_1.toNodeProtocolUrl)(specifier));
    }
    throw new resolve_error_1.ModuleNotFoundError(specifier, parentURL);
}
function parsePackageName(specifier) {
    let packageName;
    let isScoped = false;
    if (specifier.length === 0) {
        throw new resolve_error_1.InvalidModuleSpecifierError(specifier);
    }
    const iFirstSlash = specifier.indexOf('/');
    if (!specifier.startsWith('@')) {
        packageName = iFirstSlash < 0
            ? specifier
            : specifier.substr(0, iFirstSlash);
    }
    else {
        if (iFirstSlash < 0) {
            throw new resolve_error_1.InvalidModuleSpecifierError(specifier);
        }
        else {
            isScoped = true;
            const iSecondSlash = specifier.indexOf('/', iFirstSlash + 1);
            packageName = iSecondSlash < 0 ? specifier : specifier.substr(0, iSecondSlash);
        }
    }
    let isValid = true;
    if (packageName.startsWith('.')) {
        isValid = false;
    }
    for (let i = 0; i < packageName.length; i++) {
        if (packageName[i] === '%' || packageName[i] === '\\') {
            isValid = false;
            break;
        }
    }
    if (!isValid) {
        throw new resolve_error_1.InvalidModuleSpecifierError(specifier);
    }
    return { packageName, isScoped };
}
async function packageSelfResolve(packageName, packageSubpath, parentURL, context) {
    const packageJson = await readPackageScope(parentURL);
    if (!packageJson.exists || isNullOrUndefined(packageJson.exports)) {
        return undefined;
    }
    if (packageName === packageJson.name) {
        return await packageExportsResolve(packageJson.url, packageSubpath, packageJson.exports, context, parentURL);
    }
    return undefined;
}
async function readPackageScope(url) {
    let packageJsonURL = new url_1.URL('./package.json', url);
    while (true) {
        if (packageJsonURL.pathname.endsWith('node_modules/package.json')) {
            break;
        }
        const packageJson = await readPackageJson(packageJsonURL);
        if (packageJson.exists) {
            return packageJson;
        }
        const lastPackageJsonPathname = packageJsonURL.pathname;
        packageJsonURL = new url_1.URL('../package.json', packageJsonURL);
        if (packageJsonURL.pathname === lastPackageJsonPathname) {
            break;
        }
    }
    return createNonExistingPackageJson(packageJsonURL);
}
exports.readPackageScope = readPackageScope;
function isNullOrUndefined(v) {
    return v === null || v === undefined;
}
function createNonExistingPackageJson(url) {
    return {
        url,
        name: undefined,
        type: 'none',
        main: undefined,
        imports: undefined,
        exports: undefined,
        exists: false,
    };
}
async function readPackageJson(url) {
    if (!(0, url_2.hasFileProtocol)(url)) {
        return createNonExistingPackageJson(url);
    }
    let source;
    try {
        const path = (0, url_1.fileURLToPath)(url);
        source = await fs_extra_1.default.readFile(path, 'utf8');
    }
    catch (_a) {
        return createNonExistingPackageJson(url);
    }
    let json;
    try {
        json = JSON.parse(source);
    }
    catch (err) {
        throw new resolve_error_1.InvalidPackageConfigurationError(url);
    }
    const { main, name, type, imports, exports } = json;
    const normalized = {
        url,
        name: typeof name === 'string' ? name : undefined,
        type: type === 'module' || type === 'commonjs' ? type : undefined,
        main: typeof main === 'string' ? main : undefined,
        imports: typeof imports !== 'object' || imports === null ? undefined : imports,
        exports,
        exists: true,
    };
    return normalized;
}
async function packageExportsResolve(packageJsonURL, subpath, exports, context, parentURL) {
    let prefixedWithDot;
    if (typeof exports === 'object' && exports !== null) {
        const keys = Object.keys(exports);
        if (keys.length !== 0) {
            prefixedWithDot = keys[0].startsWith('.');
            if (!keys.every((key) => key.startsWith('.') === prefixedWithDot)) {
                throw new resolve_error_1.InvalidPackageConfigurationError(packageJsonURL);
            }
        }
    }
    if (subpath === '.') {
        const mainExport = typeof exports === 'string' || Array.isArray(exports) || prefixedWithDot === false
            ? exports
            : prefixedWithDot === true ? exports['.'] : undefined;
        if (mainExport !== undefined) {
            const resolved = await packageTargetResolve(packageJsonURL, mainExport, '', false, false, context);
            if (!isNullOrUndefined(resolved)) {
                return resolved;
            }
        }
    }
    else if (prefixedWithDot === true) {
        const matchKey = subpath;
        const resolvedMatch = await packageImportsExportsResolve(matchKey, exports, packageJsonURL, false, context);
        if (!isNullOrUndefined(resolvedMatch.resolved)) {
            return resolvedMatch.resolved;
        }
    }
    throw new resolve_error_1.PackagePathNotExportedError(subpath, packageJsonURL);
}
async function packageImportsExportsResolve(matchKey, matchObj, packageURL, isImports, context) {
    if (!matchKey.endsWith('*') && Object.prototype.hasOwnProperty.call(matchObj, matchKey)) {
        const target = matchObj[matchKey];
        const resolved = await packageTargetResolve(packageURL, target, '', false, isImports, context);
        return {
            resolved,
            exact: true,
        };
    }
    const keys = Object.getOwnPropertyNames(matchObj).sort((a, b) => a.length - b.length);
    for (const expansionKey of keys) {
        if (!(expansionKey.endsWith('/') || expansionKey.endsWith('*'))) {
            continue;
        }
        if (expansionKey.endsWith('*') &&
            matchKey.startsWith(expansionKey) &&
            matchKey !== expansionKey) {
            const target = matchObj[expansionKey];
            const subpath = matchKey.substr(expansionKey.length - 1);
            const resolved = await packageTargetResolve(packageURL, target, subpath, true, isImports, context);
            return { resolved, exact: true };
        }
        if (matchKey.startsWith(expansionKey)) {
            const target = matchObj[expansionKey];
            const subpath = matchKey.substr(expansionKey.length);
            const resolved = await packageTargetResolve(packageURL, target, subpath, false, isImports, context);
            return { resolved, exact: false };
        }
    }
    return { resolved: null, exact: true };
}
async function packageTargetResolve(packageURL, target, subpath, pattern, internal, context) {
    if (typeof target === 'string') {
        return await resolvePackageTargetString(packageURL, target, subpath, pattern, internal, context);
    }
    if (Array.isArray(target)) {
        return await resolvePackageTargetArray(packageURL, target, subpath, pattern, internal, context);
    }
    if (typeof target === 'object' && target !== null) {
        return await resolvePackageTargetObject(packageURL, target, subpath, pattern, internal, context);
    }
    if (target === null) {
        return null;
    }
    throw new resolve_error_1.InvalidPackageTargetError(packageURL);
}
async function resolvePackageTargetString(packageJsonURL, target, subpath, pattern, internal, context) {
    if (!pattern && subpath.length !== 0 && !target.endsWith('/')) {
        throw new resolve_error_1.InvalidModuleSpecifierError(target);
    }
    if (!target.startsWith('./')) {
        if (internal && !target.startsWith('../') && !target.startsWith('/') && !(0, url_2.tryParseURL)(target)) {
            const exportTarget = pattern
                ? applyPattern(target, subpath)
                : target + subpath;
            return await packageResolve(exportTarget, packageJsonURL, context);
        }
        else {
            throw new resolve_error_1.InvalidPackageTargetError(packageJsonURL);
        }
    }
    // Note: `target` starts with './' now
    if (dotOrDotDotOrNodeModulesSegmentRegex.test(target.substr(2))) {
        throw new resolve_error_1.InvalidPackageTargetError(packageJsonURL);
    }
    const resolved = new url_1.URL(target, packageJsonURL);
    const packagePath = new url_1.URL('.', packageJsonURL);
    if (!resolved.pathname.startsWith(packagePath.pathname)) {
        throw new resolve_error_1.InvalidPackageTargetError(packageJsonURL);
    }
    if (subpath === '') {
        return resolved;
    }
    if (dotOrDotDotOrNodeModulesSegmentRegex.test(subpath)) {
        throw new resolve_error_1.InvalidPackageTargetError(packageJsonURL);
    }
    return pattern
        ? new url_1.URL(applyPattern(resolved.href, subpath))
        : new url_1.URL(subpath, resolved);
}
const pkgTargetPriority = {
    cc: 0,
    browser: 1,
    import: 2,
    default: 3,
};
(0, asserts_1.asserts)(Object.values(pkgTargetPriority).every(key => key <= pkgTargetPriority['default']), 'The priority of condition export should be less-equal to default.');
function sortPackageTargets(targets) {
    targets = targets.slice();
    targets.sort((a, b) => {
        var _a, _b;
        const defaultPriority = pkgTargetPriority['default'];
        const aPriority = (_a = pkgTargetPriority[a]) !== null && _a !== void 0 ? _a : defaultPriority + 1;
        const bPriority = (_b = pkgTargetPriority[b]) !== null && _b !== void 0 ? _b : defaultPriority + 1;
        return aPriority - bPriority;
    });
    return targets;
}
async function resolvePackageTargetObject(packageURL, target, subpath, pattern, internal, context) {
    let keys = Object.getOwnPropertyNames(target);
    if (keys.some(isArrayIndex)) {
        throw new resolve_error_1.InvalidPackageConfigurationError(packageURL);
    }
    keys = sortPackageTargets(keys);
    for (const key of keys) {
        if (key === 'default' || context.conditions.includes(key)) {
            const targetValue = target[key];
            const resolved = await packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, context);
            if (resolved === undefined) {
                continue;
            }
            else {
                return resolved;
            }
        }
    }
    return undefined;
}
async function resolvePackageTargetArray(packageURL, target, subpath, pattern, internal, context) {
    if (target.length === 0) {
        return null;
    }
    let lastErr;
    for (const targetValue of target) {
        try {
            const resolved = await packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, context);
            if (resolved === undefined) {
                continue;
            }
            else if (resolved === null) {
                lastErr = null;
                continue;
            }
            return resolved;
        }
        catch (err) {
            //  continuing the loop on any Invalid Package Target error.
            if (err instanceof resolve_error_1.InvalidPackageTargetError) {
                lastErr = err;
                continue;
            }
            else {
                throw err;
            }
        }
    }
    if (isNullOrUndefined(lastErr)) {
        return lastErr;
    }
    else {
        throw lastErr;
    }
}
function applyPattern(s, replacer) {
    return s.replace(/\*/g, replacer);
}
// Match path segment
const dotOrDotDotOrNodeModulesSegmentRegex = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/;
function isArrayIndex(s) {
    const keyNum = +s;
    if (`${keyNum}` !== s) {
        return false;
    }
    return keyNum >= 0 && keyNum < 4294967295;
}
async function legacyMainResolve(packageJsonUrl, packageJson, context) {
    let guess;
    if (packageJson.main !== undefined) {
        // Note: fs check redundances will be handled by Descriptor cache here.
        if (await fileExists(guess = new url_1.URL(`./${packageJson.main}`, packageJsonUrl))) {
            return guess;
        }
        for (const extension of context.legacyMainResolveExtensions) {
            if (await fileExists(guess = new url_1.URL(`./${packageJson.main}${extension}`, packageJsonUrl))) {
                return guess;
            }
        }
        for (const extension of context.legacyMainResolveExtensions) {
            if (await fileExists(guess = new url_1.URL(`./${packageJson.main}/index${extension}`, packageJsonUrl))) {
                return guess;
            }
        }
        // Fallthrough.
    }
    for (const extension of context.legacyMainResolveExtensions) {
        if (await fileExists(guess = new url_1.URL(`./index${extension}`, packageJsonUrl))) {
            return guess;
        }
    }
    // Not found.
    throw new resolve_error_1.ModuleNotFoundError('<main>', new url_1.URL('.', packageJsonUrl));
}
async function fileExists(url) {
    return (await tryStat(url)).isFile();
}
async function dirExists(url) {
    return (await tryStat(url)).isDirectory();
}
async function tryStat(url) {
    try {
        const path = (0, url_1.fileURLToPath)(url);
        return await fs_extra_1.default.stat(path);
    }
    catch (_a) {
        return new fs_extra_1.default.Stats();
    }
}
//# sourceMappingURL=esm-resolve.js.map