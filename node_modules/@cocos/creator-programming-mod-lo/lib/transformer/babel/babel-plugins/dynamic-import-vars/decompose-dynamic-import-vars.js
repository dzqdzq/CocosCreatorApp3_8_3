"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function decomposeDynamicImportVars(node) {
    const rawParts = decomposeExpression(node);
    const prettyParts = [];
    for (let iRaw = 0; iRaw < rawParts.length;) {
        const unit = rawParts[iRaw];
        let prettyUnit;
        if (unit === null) {
            prettyUnit = null;
            for (; iRaw < rawParts.length && rawParts[iRaw] === null; ++iRaw) {
                // Nop
            }
        }
        else {
            prettyUnit = '';
            for (; iRaw < rawParts.length && (typeof rawParts[iRaw] === 'string'); ++iRaw) {
                prettyUnit += rawParts[iRaw];
            }
        }
        prettyParts.push(prettyUnit);
    }
    return prettyParts;
}
exports.default = decomposeDynamicImportVars;
function decomposeExpression(node) {
    switch (node.type) {
        case 'StringLiteral': return decomposeStringLiteral(node);
        case 'TemplateLiteral': return decomposeTemplateLiteral(node);
        case 'BinaryExpression': return decomposeBinaryExpression(node);
    }
    return [null];
}
function decomposeStringLiteral(node) {
    return [node.value];
}
function decomposeTemplateLiteral(node) {
    const parts = [];
    for (let i = 0; i < node.quasis.length; ++i) {
        const quasi = node.quasis[i];
        const quasiValue = quasi.value.raw;
        if (quasiValue.length !== 0) {
            parts.push(quasiValue);
        }
        const expr = node.expressions[i];
        if (expr) {
            parts.push(...decomposeExpression(expr));
        }
    }
    return parts;
}
function decomposeBinaryExpression(node) {
    if (node.operator !== '+') {
        return [null];
    }
    return [...decomposeExpression(node.left), ...decomposeExpression(node.right)];
}
//# sourceMappingURL=decompose-dynamic-import-vars.js.map