"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BabelTransformer = void 0;
// @ts-expect-error
const plugin_syntax_top_level_await_1 = __importDefault(require("@babel/plugin-syntax-top-level-await"));
const creator_programming_babel_preset_cc_1 = __importDefault(require("@cocos/creator-programming-babel-preset-cc"));
const plugin_annotate_ccclass_1 = __importDefault(require("./babel-plugins/plugin-annotate-ccclass"));
const plugin_detect_circular_1 = __importDefault(require("./babel-plugins/plugin-detect-circular"));
const preset_env_1 = __importDefault(require("@babel/preset-env"));
const babel = __importStar(require("@babel/core"));
const asserts_1 = require("../../../../creator-programming-common/lib/asserts");
const detect_imports_1 = require("./babel-plugins/detect-imports");
// @ts-expect-error
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-expect-error
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const transform_json_1 = require("../transform-json");
const plugin_import_helper_1 = __importDefault(require("./babel-plugins/plugin-import-helper"));
const generator = __importStar(require("@babel/generator"));
const transform_common_js_fast_1 = require("../transform-common-js-fast");
const dynamic_import_vars_1 = __importDefault(require("./babel-plugins/dynamic-import-vars"));
const plugin_check_obsolete_1 = require("./babel-plugins/plugin-check-obsolete");
const syncBabelTransform = true;
class BabelTransformer {
    constructor({ targets, loose, useDefineForClassFields, allowDeclareFields, cr, dynamicImportVars, _internalTransform, _helperModule = '', }) {
        this._targets = targets;
        const assumptions = {};
        if (loose) {
            // https://babeljs.io/docs/en/babel-plugin-transform-classes#loose
            assumptions.constantSuper = true;
            assumptions.noClassCalls = true;
            assumptions.setClassMethods = true;
            assumptions.superIsCallableConstructor = true;
            // https://babeljs.io/docs/en/babel-plugin-transform-parameters#loose
            assumptions.ignoreFunctionLength = true;
            // // ??
            // assumptions.arrayLikeIsIterable = true;
            // // ??
            // assumptions.iterableIsArray = true;
            // https://babeljs.io/docs/en/babel-plugin-transform-template-literals#loose
            assumptions.ignoreToPrimitiveHint = true;
            assumptions.mutableTemplateObject = true;
            // https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator#loose
            assumptions.noDocumentAll = true;
            // // ??
            // assumptions.noIncompleteNsImportDetection = true;
            // https://babeljs.io/docs/en/babel-plugin-proposal-private-methods#loose
            assumptions.privateFieldsAsProperties = true;
            // // ??
            // assumptions.pureGetters = true;
            // https://babeljs.io/docs/en/babel-plugin-transform-computed-properties#loose
            assumptions.setComputedProperties = true;
            // https://babeljs.io/docs/en/babel-plugin-proposal-class-properties#loose
            // assumptions.setPublicClassFields = true;
            // https://babeljs.io/docs/en/babel-plugin-proposal-object-rest-spread#loose
            assumptions.setSpreadProperties = true;
            assumptions.objectRestNoSymbols = true;
            // https://babeljs.io/docs/en/babel-plugin-transform-for-of#loose
            assumptions.skipForOfIteratorClosing = true;
            // The following does not corresponding to the legacy loose.
            // assumptions.noNewArrows = true;
            // Since we do not use umd, amd or commonjs, we don't need these assumptions.
            // assumptions.constantReexports = false;
            // assumptions.enumerableModuleMeta = false;
        }
        if (!useDefineForClassFields) {
            assumptions.setPublicClassFields = true;
        }
        this._assumptions = assumptions;
        this._loose = loose;
        this._allowDeclareFields = allowDeclareFields;
        this._cr = cr;
        this._internalTransform = _internalTransform;
        if (dynamicImportVars) {
            this._dynamicImportVarsOptions = {
                resolve: {
                    forwardExt: 'resolved',
                },
            };
        }
        if (_helperModule) {
            this._babelPluginImportHelper = (0, plugin_import_helper_1.default)({ helperModule: _helperModule });
        }
    }
    /**
     * Transform an ESM module.
     */
    async transform(url, source, map, options, disableTransform) {
        const { plugins, presets } = this._getPluginsPresetsOfModule(options, disableTransform);
        return new BabelEsmMod(url, source, map ? normalizeSourceMapAsBabelInput(map) : undefined, undefined, 'module', this._assumptions, presets, plugins);
    }
    /**
     * Transform a JSON module into ESM representation.
     */
    async transformJson(url, source, inputSourceMap) {
        const jsonEsmSource = (0, transform_json_1.transformJson)(url, source);
        return new BabelJsonMod(url, jsonEsmSource, undefined, source, 'module', this._assumptions, [this._getEnvPreset()], []);
    }
    /**
     * Transform a CommonJS module into ESM representation.
     */
    async transformCommonJs(url, source, map, id, disableTransform) {
        const fastCommonJsMod = new transform_common_js_fast_1.FastCommonJsMod(source, id);
        if (disableTransform) {
            return fastCommonJsMod;
        }
        else {
            const { code: esmRepCode, map: esmRepMap } = fastCommonJsMod.module();
            const { plugins, presets } = this._getPluginsPresetsOfCommonJsModule();
            return new BabelCommonJsMod(url, esmRepCode, esmRepMap ? normalizeSourceMapAsBabelInput(esmRepMap) : undefined, source, 'module', this._assumptions, presets, plugins);
        }
    }
    async loadHelper(url) {
        // @ts-ignore
        const source = babel.buildExternalHelpers(null, 'module');
        return new BabelEsmMod(url, source, undefined, undefined, 'module', this._assumptions, [], []);
    }
    /**
     * Throws if babel transform failed.
     */
    _throwBabelReturnNull() {
        throw new Error(`Failed to transform.`);
    }
    _getPluginsPresetsOfModule(options, disableTransform) {
        const plugins = [];
        const presets = [];
        if (disableTransform) {
            return { plugins, presets };
        }
        presets.push(this._getEnvPreset());
        if (options.checkObsolete) {
            plugins.push(plugin_check_obsolete_1.pluginCheckObsolete);
        }
        plugins.push(plugin_syntax_top_level_await_1.default);
        presets.push([creator_programming_babel_preset_cc_1.default, {
                allowDeclareFields: this._allowDeclareFields,
            }]);
        if (options) {
            if (this._dynamicImportVarsOptions) {
                plugins.push([
                    dynamic_import_vars_1.default, this._dynamicImportVarsOptions,
                ]);
            }
            if (options.annotate) {
                plugins.push([
                    plugin_annotate_ccclass_1.default,
                    options.annotate,
                ]);
            }
            if (options.cr && this._cr) {
                plugins.push([plugin_detect_circular_1.default, this._cr]);
            }
        }
        if (this._babelPluginImportHelper) {
            plugins.push(this._babelPluginImportHelper);
        }
        return {
            plugins,
            presets,
        };
    }
    _getPluginsPresetsOfCommonJsModule() {
        const plugins = [];
        const presets = [];
        presets.push(this._getEnvPreset());
        return {
            plugins,
            presets,
        };
    }
    _getEnvPreset() {
        var _a, _b;
        const babelPresetEnvOptions = {
            modules: false,
            targets: this._targets,
            loose: this._loose,
            // We need explicitly specified targets.
            // Ignore it to avoid the engine's parent dirs contain unexpected config.
            ignoreBrowserslistConfig: true,
            include: [
                'proposal-class-properties',
                ...((_b = (_a = this._internalTransform) === null || _a === void 0 ? void 0 : _a.includes) !== null && _b !== void 0 ? _b : []),
            ],
        };
        if (this._internalTransform) {
            babelPresetEnvOptions.exclude = this._internalTransform.excludes;
        }
        return [preset_env_1.default, babelPresetEnvOptions];
    }
}
exports.BabelTransformer = BabelTransformer;
class BabelModBase {
    constructor(url, source, map, originalSource, sourceType, assumptions, presets, plugins) {
        this._url = url;
        this._source = source;
        this._map = map;
        this._originalSource = originalSource !== null && originalSource !== void 0 ? originalSource : source;
        this._sourceType = sourceType;
        this._presets = presets;
        this._plugins = plugins;
        this._assumptions = assumptions;
    }
    async module() {
        return await this._transform(this._plugins, this._presets);
    }
    async systemjs(resolver) {
        let specifiers = [];
        const systemJsPlugins = [
            [plugin_transform_modules_systemjs_1.default],
            // Dynamic import() transformation must be enabled using the
            // @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
            // no longer transform import() without using that plugin.
            [plugin_proposal_dynamic_import_1.default],
        ];
        if (resolver) {
            systemJsPlugins.unshift([(0, detect_imports_1.createBabelPluginDetectAndRewriteImports)({
                    specifiers,
                    rewrite: resolver,
                })]);
        }
        const source = await this._transformMultiplePasses([
            { plugins: this._plugins, presets: this._presets, },
            { plugins: systemJsPlugins },
        ]);
        return {
            source,
            moduleSpecifiers: specifiers,
        };
    }
    async _transform(plugins, presets) {
        const { _url: url, _source: source, _sourceType: sourceType, _map: inputSourceMap, } = this;
        const babelResult = await (syncBabelTransform
            ? babel.transformSync
            : babel.transformAsync)(source, Object.assign(Object.assign({ filename: url.href, code: true, ast: false, sourceType,
            inputSourceMap }, this._getGenerateOptions()), { assumptions: this._assumptions, configFile: false, presets,
            plugins }));
        (0, asserts_1.assertsNonNullable)(babelResult);
        (0, asserts_1.assertsNonNullable)(babelResult.code);
        return {
            code: babelResult.code,
            map: babelResult.map
        };
    }
    async _transformMultiplePasses(passes) {
        (0, asserts_1.asserts)(passes.length > 0);
        const { _url: url, _source: source, _sourceType: sourceType, _map: inputSourceMap, } = this;
        const firstPass = passes[0];
        const firstPassResult = await (syncBabelTransform
            ? babel.transformSync
            : babel.transformAsync)(source, Object.assign({ code: false, ast: true, sourceType, filename: url.href, assumptions: this._assumptions }, firstPass));
        (0, asserts_1.assertsNonNullable)(firstPassResult);
        (0, asserts_1.assertsNonNullable)(firstPassResult.ast);
        let ast = firstPassResult.ast;
        for (let iPass = 1; iPass < passes.length; ++iPass) {
            const pass = passes[iPass];
            const passResult = await (syncBabelTransform
                ? babel.transformFromAstSync
                : babel.transformFromAstAsync)(ast, source, Object.assign({ code: false, ast: true, cloneInputAst: true, filename: url.href }, pass));
            (0, asserts_1.assertsNonNullable)(passResult);
            (0, asserts_1.assertsNonNullable)(passResult.ast);
            ast = passResult.ast;
        }
        const { code, map } = generator.default(ast, Object.assign({}, this._getGenerateOptions()), source);
        return {
            code,
            map: (map !== null && map !== void 0 ? map : undefined)
        };
    }
    _getGenerateOptions() {
        const { _url: url, } = this;
        return {
            filename: url.href,
            sourceMaps: true,
            sourceFileName: url.href,
        };
    }
}
class BabelEsmMod extends BabelModBase {
    constructor() {
        super(...arguments);
        this.type = 'esm';
    }
    source() {
        return super.module();
    }
    module() {
        return this.source();
    }
}
class BabelJsonMod extends BabelModBase {
    constructor() {
        super(...arguments);
        this.type = 'json';
    }
    content() {
        return super._originalSource;
    }
}
class BabelCommonJsMod extends BabelModBase {
    constructor() {
        super(...arguments);
        this.type = 'commonjs';
    }
    source() {
        return {
            code: super._originalSource,
            map: undefined,
        };
    }
}
function normalizeSourceMapAsBabelInput(sourceMap) {
    return typeof sourceMap === 'string'
        ? JSON.parse(sourceMap)
        : sourceMap !== null && sourceMap !== void 0 ? sourceMap : undefined;
}
const parserPlugins = [
    'asyncGenerators',
    'bigInt',
    'classPrivateMethods',
    'classPrivateProperties',
    'classProperties',
    // 'classStaticBlock',
    'decimal',
    // 'decorators',
    'decorators-legacy',
    // 'doExpressions',
    'dynamicImport',
    // 'estree',
    'exportDefaultFrom',
    // 'exportNamespaceFrom', // deprecated
    // 'flow',
    // 'flowComments',
    // 'functionBind',
    'functionSent',
    'importMeta',
    // 'jsx',
    'logicalAssignment',
    // 'importAssertions',
    'moduleStringNames',
    'nullishCoalescingOperator',
    'numericSeparator',
    'objectRestSpread',
    'optionalCatchBinding',
    'optionalChaining',
    // 'partialApplication',
    // 'pipelineOperator',
    'placeholders',
    // 'privateIn',
    // 'throwExpressions',
    'topLevelAwait',
    // 'typescript',
    // 'v8intrinsic',
    // ['decorators', {
    //     decoratorsBeforeExport: true,
    // }],
    // ['pipelineOperator', {
    //     proposal: 'minimal',
    // }],
    // ['flow', {
    //     all: true,
    // }],
];
//# sourceMappingURL=babel-transformer.js.map