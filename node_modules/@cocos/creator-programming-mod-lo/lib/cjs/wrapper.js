"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCjsInteropModuleSource = exports.wrapCjs = exports.cjsWrapperImports = void 0;
const dedent_1 = __importDefault(require("dedent"));
const mod_lo_builtin_mods_1 = require("../utils/mod-lo-builtin-mods");
const babel = __importStar(require("@babel/core"));
const share_1 = require("./share");
const collect_requires_1 = require("../transformer/babel/babel-plugins/collect-requires");
exports.cjsWrapperImports = [mod_lo_builtin_mods_1.modLoBuiltinModCommonJsURL];
function wrapCjs(exports, reexports) {
    return (context) => {
        return {
            visitor: {
                Program: {
                    exit: (path) => {
                        const requires = [];
                        context.traverse(path.node, (0, collect_requires_1.collectRequiresVisitor)(requires));
                        wrap(context, path, requires, exports, reexports);
                    },
                }
            },
        };
    };
}
exports.wrapCjs = wrapCjs;
function wrap({ types }, path, requires, exports, reexports) {
    const originalProgram = path.node;
    const reqIds = requires.map((req) => path.scope.generateUid('req'));
    const filteredExports = exports.filter((exportName) => !share_1.reservedIds.includes(exportName));
    let cjsExportVarId = path.scope.generateUid('cjsExports');
    let declExportVars = [];
    let updateExportVars = [];
    let exportStatements = [];
    if (filteredExports.length !== 0) {
        const exportVars = filteredExports.map((exportName) => {
            return [exportName, path.scope.generateUid(exportName)];
        });
        declExportVars = exportVars.map(([, localName]) => types.variableDeclaration('let', [types.variableDeclarator(types.identifier(localName))]));
        updateExportVars = exportVars.map(([exportName, localName]) => {
            return types.expressionStatement(types.assignmentExpression('=', types.identifier(localName), types.memberExpression(types.memberExpression(types.identifier('module'), types.identifier('exports')), types.identifier(exportName))));
        });
        exportStatements = [types.exportNamedDeclaration(undefined, exportVars.map(([exportName, localName]) => types.exportSpecifier(types.identifier(localName), types.identifier(exportName))))];
    }
    const program = template({
        cjsExportVar: types.identifier(cjsExportVarId),
        declCjsExportVar: types.variableDeclaration('let', [types.variableDeclarator(types.identifier(cjsExportVarId))]),
        declExportVars,
        updateExportVars,
        loaderVar: path.scope.generateUidIdentifier('loader'),
        requireVar: path.scope.generateUidIdentifier('require'),
        deps: requires.map((req, index) => types.importDeclaration([
            types.importSpecifier(types.identifier(reqIds[index]), types.identifier(share_1.cjsMetaUrlExportName)),
        ], types.stringLiteral(req))),
        resolveMap: types.objectExpression(requires.map((req, index) => types.objectProperty(types.stringLiteral(req), types.identifier(reqIds[index])))),
        cjsLoader: types.stringLiteral(mod_lo_builtin_mods_1.modLoBuiltinModCommonJsURL),
        code: originalProgram.body,
        exports: exportStatements,
        cjsMetaUrlExportName: types.identifier(share_1.cjsMetaUrlExportName),
    });
    path.node.directives = [];
    path.node.body = [];
    path.pushContainer('directives', program.directives);
    path.pushContainer('body', program.body);
}
const template = babel.template.program((0, dedent_1.default) `
    %%deps%%
    import %%loaderVar%% from %%cjsLoader%%;
    %%declCjsExportVar%%
    %%declExportVars%%
    %%loaderVar%%.define(import.meta.url, function (exports, %%requireVar%%, module, __filename, __dirname) {
        let require = %%loaderVar%%.createRequireWithReqMap(%%resolveMap%%, %%requireVar%%);
        (function () {
            %%code%%
        })();
        %%cjsExportVar%% = module.exports;
        %%updateExportVars%%
    });
    export { %%cjsExportVar%% as default }
    %%exports%%
    export const %%cjsMetaUrlExportName%% = import.meta.url;
`);
async function getCjsInteropModuleSource(requestTarget) {
    return (0, dedent_1.default) `
        // I am the facade module who provides access to the CommonJS module '${requestTarget}'~
        import { ${share_1.cjsMetaUrlExportName} as req } from '${requestTarget}';
        import loader from '${mod_lo_builtin_mods_1.modLoBuiltinModCommonJsURL}';
        if (!req) {
            loader.throwInvalidWrapper('${requestTarget}', import.meta.url);
        }
        loader.require(req);
        export * from '${requestTarget}';
        import { default as d } from '${requestTarget}'
        export { d as default };
    `;
}
exports.getCjsInteropModuleSource = getCjsInteropModuleSource;
//# sourceMappingURL=wrapper.js.map