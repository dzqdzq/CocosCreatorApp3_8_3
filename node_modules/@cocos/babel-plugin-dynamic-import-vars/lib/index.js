"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decompose_dynamic_import_vars_1 = __importDefault(require("./decompose-dynamic-import-vars"));
const default_resolve_1 = __importDefault(require("./default-resolve"));
function default_1({ types }) {
    // Ensures that we won't loop infinitely.
    const myImports = new Set();
    const createImport = () => {
        const importNode = types.import();
        myImports.add(importNode);
        return importNode;
    };
    return {
        visitor: {
            CallExpression: (path, state) => {
                var _a;
                const fileName = state.filename;
                if (!fileName) {
                    return;
                }
                const node = path.node;
                if (node.callee.type !== 'Import' ||
                    node.arguments.length !== 1 ||
                    !types.isExpression(node.arguments[0]) ||
                    types.isStringLiteral(node.arguments[0])) {
                    return;
                }
                if (myImports.has(node.callee)) {
                    return;
                }
                const originalSpecifier = node.arguments[0];
                const specifierParts = decompose_dynamic_import_vars_1.default(originalSpecifier);
                if (specifierParts.length === 0) {
                    return;
                }
                const options = (_a = state.opts) !== null && _a !== void 0 ? _a : {};
                let resolve;
                if (typeof options.resolve === 'function') {
                    resolve = options.resolve;
                }
                else {
                    resolve = default_resolve_1.default(options.resolve);
                }
                const candidates = resolve(specifierParts, fileName);
                if (!candidates || candidates.length === 0) {
                    return;
                }
                const specifierArg = () => types.identifier('path');
                const candidateSwitchCases = candidates.map((candidate) => {
                    let test;
                    let specifier;
                    if (Array.isArray(candidate)) {
                        test = candidate[0];
                        specifier = candidate[1];
                    }
                    else {
                        test = candidate;
                        specifier = candidate;
                    }
                    return types.switchCase(types.stringLiteral(test), [types.returnStatement(types.callExpression(createImport(), [types.stringLiteral(specifier)]))]);
                });
                const lambda = types.parenthesizedExpression(types.arrowFunctionExpression([specifierArg()], types.blockStatement([types.switchStatement(specifierArg(), candidateSwitchCases.concat([types.switchCase(null, [types.returnStatement(types.callExpression(createImport(), [specifierArg()]))])]))])));
                path.replaceWith(types.callExpression(lambda, [originalSpecifier]));
            },
        },
    };
}
exports.default = default_1;
//# sourceMappingURL=index.js.map