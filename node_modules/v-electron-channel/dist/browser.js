'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.query = exports.clear = exports.unregister = exports.register = void 0;
var electron_1 = require("electron");
var pkg = require('../package.json');
var ipcFlag = "".concat(pkg.name, "@").concat(pkg.version);
var map = {};
/**
* 注册一个通道
* @param channel
*/
function register(channel) {
    map[channel] = map[channel] || [];
    map[channel].push(-1);
}
exports.register = register;
/**
 * 删除一个通道
 * @param channel
 */
function unregister(channel) {
    var array = map[channel];
    if (!array) {
        return;
    }
    var index = array.indexOf(-1);
    if (index >= 0) {
        array.splice(index, 1);
    }
    if (array.length === 0) {
        delete map[channel];
    }
    // 同步给所有渲染进程
    var wins = electron_1.BrowserWindow.getAllWindows();
    wins.forEach(function (win) {
        if (win.isDestroyed()) {
            return;
        }
        win.webContents.send("".concat(ipcFlag, ":delete"), name, -1);
    });
}
exports.unregister = unregister;
/**
 * 清楚这个通道的注册数据
 * @param channel
 */
function clear(channel) {
    delete map[channel];
    // 同步给所有渲染进程
    var wins = electron_1.BrowserWindow.getAllWindows();
    wins.forEach(function (win) {
        if (win.isDestroyed()) {
            return;
        }
        win.webContents.send("".concat(ipcFlag, ":clear"), name);
    });
}
exports.clear = clear;
/**
 * 查询通道对应的 webContext id
 * @param channel
 */
function query(channel) {
    return map[channel] || null;
}
exports.query = query;
var listenerMap = {};
var winBindSet = new Set();
var senderBindSet = new Set();
electron_1.ipcMain.on("".concat(ipcFlag, ":register"), function (event, channel) {
    var id = event.sender.id;
    map[channel] = map[channel] || [];
    map[channel].push(id);
    if (listenerMap[id]) {
        return;
    }
    listenerMap[id] = listenerMap[id] || [];
    listenerMap[id].push(channel);
    if (!senderBindSet.has(event.sender)) {
        senderBindSet.add(event.sender);
        event.sender.once('destroyed', function () {
            senderBindSet.delete(event.sender);
            var array = listenerMap[id];
            array.forEach(function (name) {
                electron_1.ipcMain.emit("".concat(ipcFlag, ":unregister"), event, name);
                if (map[name]) {
                    for (var i = 0; i < map[name].length; i++) {
                        if (map[name][i] === id) {
                            map[name].splice(i--, 1);
                        }
                    }
                }
            });
            array.length = 0;
        });
    }
    var win = electron_1.BrowserWindow.fromWebContents(event.sender);
    if (win && !winBindSet.has(win)) {
        winBindSet.add(win);
        win.once('closed', function () {
            winBindSet.delete(win);
            var array = listenerMap[id];
            array.forEach(function (name) {
                electron_1.ipcMain.emit("".concat(ipcFlag, ":unregister"), event, name);
                if (map[name]) {
                    for (var i = 0; i < map[name].length; i++) {
                        if (map[name][i] === id) {
                            map[name].splice(i--, 1);
                        }
                    }
                }
            });
            array.length = 0;
        });
    }
});
electron_1.ipcMain.on("".concat(ipcFlag, ":unregister"), function (event, channel) {
    var array = map[channel];
    if (!array) {
        return;
    }
    var index = array.indexOf(event.sender.id);
    if (index >= 0) {
        array.splice(index, 1);
    }
    if (array.length === 0) {
        delete map[channel];
    }
    // 同步给所有渲染进程
    var wins = electron_1.BrowserWindow.getAllWindows();
    wins.forEach(function (win) {
        if (win.isDestroyed()) {
            return;
        }
        win.webContents.send("".concat(ipcFlag, ":delete"), channel, event.sender.id);
    });
});
electron_1.ipcMain.on("".concat(ipcFlag, ":clear"), function (event, channel) {
    delete map[channel];
});
electron_1.ipcMain.on("".concat(ipcFlag, ":query"), function (event, channel) {
    event.returnValue = query(channel);
});
