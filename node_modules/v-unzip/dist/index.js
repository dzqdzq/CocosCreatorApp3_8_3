'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
/**
 * 将一个 zip 解压到指定的位置
 * @param source
 * @param dist
 */
function unzip(source, dist, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (process.platform === 'win32') {
            yield unzipOfWin32(source, dist);
        }
        else if (process.platform === 'darwin') {
            yield unzipOfDarwin(source, dist);
        }
        else {
            return Promise.reject('Unsupported platform');
        }
        if (options) {
            if (options.recursive) {
                recursive(dist, options.recursive);
            }
        }
    });
}
exports.unzip = unzip;
/**
 * 检查是否支持当前平台
 * @param platform
 */
function checkSupportPlatform(platform) {
    return ['win32', 'darwin'].indexOf(platform) !== -1;
}
exports.checkSupportPlatform = checkSupportPlatform;
function unzipOfWin32(source, dist) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = path_1.dirname(dist);
        yield fs_extra_1.ensureDir(dir);
        return new Promise((resolve, reject) => {
            let exe = path_1.join(__dirname, '../bin/unzip.exe');
            if (fs_extra_1.existsSync(exe.replace('.asar', '.asar.unpacked'))) {
                exe = exe.replace('.asar', '.asar.unpacked');
            }
            const child = child_process_1.spawn(exe, [
                '-q',
                '-o',
                source,
                '-d',
                dist,
            ]);
            let errText = '';
            child.stderr && child.stderr.on('data', (data) => {
                errText += data;
            });
            let text = '';
            child.stdout && child.stdout.on('data', (data) => {
                text += data;
            });
            child.on('close', (code) => {
                if (text) {
                    console.log(text);
                }
                if (errText) {
                    console.warn(errText);
                }
                // code == 0 测试通过，其余的为文件有问题
                if (code !== 0) {
                    return reject('The decompression has failed');
                }
                resolve();
            });
        });
    });
}
function unzipOfDarwin(source, dist) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = path_1.dirname(dist);
        yield fs_extra_1.ensureDir(dir);
        return new Promise((resolve, reject) => {
            const child = child_process_1.spawn('unzip', [
                '-q',
                '-o',
                source,
                '-d',
                dist,
            ]);
            let errText = '';
            child.stderr && child.stderr.on('data', (data) => {
                errText += data;
            });
            let text = '';
            child.stdout && child.stdout.on('data', (data) => {
                text += data;
            });
            child.on('close', (code) => {
                if (text) {
                    console.log(text);
                }
                if (errText) {
                    console.warn(errText);
                }
                // code == 0 测试通过，其余的为文件有问题
                if (code !== 0) {
                    return reject('The decompression has failed');
                }
                resolve();
            });
        });
    });
}
/**
 * 递归文件夹
 * @param dir
 * @param handle
 */
function recursive(dir, handle) {
    function step(file) {
        handle(file);
        if (!fs_extra_1.existsSync(file)) {
            return;
        }
        const stat = fs_extra_1.statSync(file);
        if (stat.isDirectory()) {
            const dirs = fs_extra_1.readdirSync(file);
            dirs.forEach((name) => {
                const child = path_1.join(file, name);
                step(child);
            });
        }
    }
    step(dir);
}
