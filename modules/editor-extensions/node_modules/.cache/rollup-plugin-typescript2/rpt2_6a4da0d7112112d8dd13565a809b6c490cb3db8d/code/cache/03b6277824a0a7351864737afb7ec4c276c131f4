{"code":"'use strict';\r\nimport fs from 'fs';\r\nimport ps from 'path';\r\nconst io = require('socket.io');\r\nimport { LFX_Buffer, LFX_File, LFX_LightProbeInfo, LFX_MeshLightMapInfo, LFX_TerrainLightMapInfo, LFX_World } from './LFX_Types';\r\nimport EventEmitter from 'events';\r\n//const LFX_FILE_VERSION = 0x2000;\r\n//const LFX_FILE_VERSION = 0x2002; // 3.7.2 2\r\n//const LFX_FILE_VERSION = 0x2003; // 3.7.2 3\r\nconst LFX_FILE_VERSION = 0x3730; // 3.7.3 0\r\nconst LFX_FILE_TERRAIN = 0x01;\r\nconst LFX_FILE_MESH = 0x02;\r\nconst LFX_FILE_LIGHT = 0x03;\r\nconst LFX_FILE_LIGHT_PROBE = 0x04;\r\nconst LFX_FILE_EOF = 0x00;\r\n// tslint:disable-next-line: class-name\r\nexport class LFX_Baker extends EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this.World = new LFX_World();\r\n        this.Started = false;\r\n        this.Finished = false;\r\n        this.Error = false;\r\n        //\r\n        this._server = null;\r\n        this._client = null;\r\n        this._path = null;\r\n        this._lfxpath = null;\r\n    }\r\n    get lfxpath() {\r\n        return this._lfxpath || ps.resolve('tools/lightmap-tools');\r\n    }\r\n    set lfxpath(path) {\r\n        this._lfxpath = path;\r\n    }\r\n    get closed() {\r\n        return this._server == null;\r\n    }\r\n    get connected() {\r\n        return this._client != null;\r\n    }\r\n    get client() {\r\n        return this._client;\r\n    }\r\n    // 启动socket.io, 0为随机分配端口\r\n    Launch(port = 0) {\r\n        this.Started = false;\r\n        this.Finished = false;\r\n        this.Error = false;\r\n        this._server = io.listen(port);\r\n        this._server.on('connection', (socket) => {\r\n            socket.on('Login', (data) => {\r\n                this._client = socket;\r\n                this.emit('login', this._client);\r\n            });\r\n            socket.on('Log', (data) => {\r\n                this.emit('log', data);\r\n            });\r\n            socket.on('Progress', (data) => {\r\n                this.emit('progress', data);\r\n            });\r\n            socket.on('Finished', (data) => {\r\n                this.Finished = true;\r\n                this.emit('fineshed', data);\r\n            });\r\n        });\r\n        return port;\r\n    }\r\n    // 关闭\r\n    Close() {\r\n        if (this._server != null) {\r\n            this._server.close();\r\n        }\r\n        this._server = null;\r\n        this._client = null;\r\n    }\r\n    // 上传\r\n    Upload(asset_path) {\r\n        this._path = asset_path;\r\n        const buff = new LFX_Buffer();\r\n        let triangleCount = 0;\r\n        // console.log(asset_path, '================');\r\n        // if(fs.existsSync(asset_path)) {\r\n        //     Utils.removeDir(asset_path);\r\n        // }\r\n        // fs.mkdirSync(asset_path);\r\n        const immediatePath = asset_path + '/tmp';\r\n        if (!fs.existsSync(immediatePath)) {\r\n            fs.mkdirSync(immediatePath);\r\n        }\r\n        // const outputPath = asset_path + '/output';\r\n        // if (!fs.existsSync(outputPath)) {\r\n        //     // 删除输出文件\r\n        //     const files = fs.readdirSync(outputPath);\r\n        //     files.forEach((file, index) => {\r\n        //         const curPath = outputPath + '/' + file;\r\n        //         if (!fs.statSync(curPath).isDirectory()) {\r\n        //             fs.unlinkSync(curPath);\r\n        //         }\r\n        //     });\r\n        // }\r\n        // Head\r\n        buff.WriteInt32(LFX_FILE_VERSION);\r\n        buff.WriteString(this.World.Name);\r\n        // Setting\r\n        const ambient = [0.0, 0.0, 0.0];\r\n        buff.WriteFloatArray(ambient);\r\n        buff.WriteFloatArray(this.World.Settings.SkyRadiance);\r\n        buff.WriteInt32(this.World.Settings.MSAA);\r\n        buff.WriteInt32(this.World.Settings.Size);\r\n        buff.WriteFloat(this.World.Settings.Gamma);\r\n        buff.WriteInt8(this.World.Settings.Highp ? 1 : 0);\r\n        buff.WriteFloat(this.World.Settings.GIScale);\r\n        buff.WriteInt32(this.World.Settings.GISamples);\r\n        buff.WriteInt32(this.World.Settings.GIPathLength);\r\n        buff.WriteFloat(this.World.Settings.GIProbeScale);\r\n        buff.WriteInt32(this.World.Settings.GIProbeSamples);\r\n        buff.WriteInt32(this.World.Settings.GIProbePathLength);\r\n        buff.WriteInt32(this.World.Settings.AOLevel);\r\n        buff.WriteFloat(this.World.Settings.AOStrength);\r\n        buff.WriteFloat(this.World.Settings.AORadius);\r\n        buff.WriteFloat(this.World.Settings.AOColor[0] / 255.0);\r\n        buff.WriteFloat(this.World.Settings.AOColor[1] / 255.0);\r\n        buff.WriteFloat(this.World.Settings.AOColor[2] / 255.0);\r\n        buff.WriteInt32(this.World.Settings.Threads);\r\n        buff.WriteInt8(this.World.Settings.Filter ? 1 : 0);\r\n        buff.WriteInt8(this.World.Settings.BakeLightMap ? 1 : 0);\r\n        buff.WriteInt8(this.World.Settings.BakeLightProbe ? 1 : 0);\r\n        // Terrains\r\n        for (const terrain of this.World.Terrains) {\r\n            buff.WriteInt32(LFX_FILE_TERRAIN);\r\n            buff.WriteFloatArray(terrain.Position);\r\n            buff.WriteFloat(terrain.TileSize);\r\n            buff.WriteIntArray(terrain.BlockCount);\r\n            buff.WriteInt32(terrain.LightMapSize);\r\n            buff.WriteHeightField(terrain.HeightField);\r\n        }\r\n        // Meshes\r\n        for (const mesh of this.World.Meshes) {\r\n            buff.WriteInt32(LFX_FILE_MESH);\r\n            buff.WriteInt8(mesh.CastShadow ? 1 : 0);\r\n            buff.WriteInt8(mesh.ReceiveShadow ? 1 : 0);\r\n            buff.WriteInt32(mesh.LightMapSize);\r\n            buff.WriteInt32(mesh.VertexBuffer.length);\r\n            buff.WriteInt32(mesh.TriangleBuffer.length);\r\n            buff.WriteInt32(mesh.MaterialBuffer.length);\r\n            triangleCount += mesh.TriangleBuffer.length;\r\n            for (const vtx of mesh.VertexBuffer) {\r\n                buff.WriteFloatArray(vtx.Position);\r\n                buff.WriteFloatArray(vtx.Normal);\r\n                buff.WriteFloatArray(vtx.UV);\r\n                buff.WriteFloatArray(vtx.LUV);\r\n            }\r\n            for (const tri of mesh.TriangleBuffer) {\r\n                buff.WriteIntArray(tri.Index);\r\n                buff.WriteInt32(tri.MaterialId);\r\n            }\r\n            for (const mtl of mesh.MaterialBuffer) {\r\n                buff.WriteFloat(mtl.AlphaCulloff);\r\n                buff.WriteFloat(mtl.Metallic);\r\n                buff.WriteFloat(mtl.Roughness);\r\n                buff.WriteFloatArray(mtl.Diffuse);\r\n                buff.WriteFloatArray(mtl.Emissive);\r\n                buff.WriteString(mtl.Texture);\r\n                buff.WriteString(mtl.PBRMap);\r\n                buff.WriteString(mtl.EmissiveMap);\r\n            }\r\n        }\r\n        // Lights\r\n        for (const light of this.World.Lights) {\r\n            buff.WriteInt32(LFX_FILE_LIGHT);\r\n            buff.WriteInt32(light.Type);\r\n            buff.WriteFloatArray(light.Position);\r\n            buff.WriteFloatArray(light.Direction);\r\n            buff.WriteFloatArray(light.Color);\r\n            buff.WriteFloat(light.Size);\r\n            buff.WriteFloat(light.Range);\r\n            buff.WriteFloat(light.AttenFallOff);\r\n            buff.WriteFloat(light.SpotInner);\r\n            buff.WriteFloat(light.SpotOuter);\r\n            buff.WriteFloat(light.SpotFallOff);\r\n            buff.WriteFloat(light.DirectScale);\r\n            buff.WriteFloat(light.IndirectScale);\r\n            buff.WriteInt8(light.GIEnable ? 1 : 0);\r\n            buff.WriteInt8(light.CastShadow ? 1 : 0);\r\n            buff.WriteFloat(light.ShadowMask);\r\n        }\r\n        // LightProbes\r\n        for (const probe of this.World.LightProbes) {\r\n            buff.WriteInt32(LFX_FILE_LIGHT_PROBE);\r\n            buff.WriteFloatArray(probe.Position);\r\n            buff.WriteFloatArray(probe.Normal);\r\n        }\r\n        // EOF\r\n        buff.WriteInt32(LFX_FILE_EOF);\r\n        // Save\r\n        fs.writeFileSync(immediatePath + '/lfx.in', buff.Buffer);\r\n        // Copy Textures\r\n        for (const tex of this.World.Textures) {\r\n            const data = fs.readFileSync(asset_path + '/' + tex);\r\n            const target = tex.replace('/', '$');\r\n            fs.writeFileSync(immediatePath + '/' + target, data);\r\n        }\r\n        // 参与烘焙物体的三角形总面数 埋点\r\n        Editor.Metrics.trackEvent({\r\n            sendToNewCocosAnalyticsOnly: true,\r\n            category: 'bakingSystem',\r\n            value: {\r\n                A100001: triangleCount,\r\n            },\r\n        });\r\n    }\r\n    //\r\n    Download() {\r\n        const file = new LFX_File();\r\n        const filename = this._path + '/output/lfx.out';\r\n        const buff = fs.readFileSync(filename);\r\n        if (buff != null) {\r\n            const stream = new LFX_Buffer();\r\n            stream.Assign(buff);\r\n            file.Verison = stream.ReadInt();\r\n            //console.log('Read lfx out fle, version ' +  file.Verison);\r\n            do {\r\n                const cid = stream.ReadInt();\r\n                if (cid === LFX_FILE_EOF) {\r\n                    break;\r\n                }\r\n                if (cid === LFX_FILE_TERRAIN) {\r\n                    const id = stream.ReadInt();\r\n                    const count = stream.ReadInt();\r\n                    //console.log('Read ' + count + ' terrain lightmap infos');\r\n                    for (let i = 0; i < count; ++i) {\r\n                        const info = new LFX_TerrainLightMapInfo();\r\n                        info.Id = id;\r\n                        info.BlockId = stream.ReadInt();\r\n                        info.Index = stream.ReadInt();\r\n                        info.Offset[0] = stream.ReadFloat();\r\n                        info.Offset[1] = stream.ReadFloat();\r\n                        info.Scale[0] = stream.ReadFloat();\r\n                        info.Scale[1] = stream.ReadFloat();\r\n                        file.TerrainInfos.push(info);\r\n                    }\r\n                }\r\n                else if (cid === LFX_FILE_MESH) {\r\n                    const count = stream.ReadInt();\r\n                    //console.log('Read ' + count + ' mesh lightmap infos');\r\n                    for (let i = 0; i < count; ++i) {\r\n                        const info = new LFX_MeshLightMapInfo();\r\n                        info.Id = stream.ReadInt();\r\n                        info.Index = stream.ReadInt();\r\n                        info.Offset[0] = stream.ReadFloat();\r\n                        info.Offset[1] = stream.ReadFloat();\r\n                        info.Scale[0] = stream.ReadFloat();\r\n                        info.Scale[1] = stream.ReadFloat();\r\n                        file.MeshInfos.push(info);\r\n                    }\r\n                }\r\n                else if (cid === LFX_FILE_LIGHT_PROBE) {\r\n                    const count = stream.ReadInt();\r\n                    //console.log('Read ' + count + ' light probe infos');\r\n                    for (let i = 0; i < count; ++i) {\r\n                        const info = new LFX_LightProbeInfo();\r\n                        stream.ReadFloatArray(info.Position);\r\n                        stream.ReadFloatArray(info.Normal);\r\n                        info.Coefficients.length = stream.ReadInt();\r\n                        stream.ReadFloatArray(info.Coefficients);\r\n                        file.LightProbeInfos.push(info);\r\n                    }\r\n                }\r\n                else {\r\n                    // error\r\n                    console.log('LightFX unknown chunk ' + cid);\r\n                }\r\n            } while (1); // eslint-disable-line\r\n        }\r\n        return file;\r\n    }\r\n    // 开始烘培\r\n    Start() {\r\n        this._client && this._client.emit('Start');\r\n        this.Started = true;\r\n    }\r\n    // 停止烘培\r\n    Stop() {\r\n        this._client && this._client.emit('Stop');\r\n    }\r\n}\r\n","references":["/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/path/path.js","/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/socket.io/lib/index.js","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/extensions/lightmap/source/lightmap/backer/LFX_Types.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/@types/events/index.d.ts"]}
