{"code":"'use strict';\r\nimport { join } from 'path';\r\nimport { renderer, director, gfx, Scene, Vec3, assetManager, DirectionalLight, Light, MeshRenderer, SphereLight, SpotLight, Texture2D, Terrain, Vertex, MobilityMode, } from 'cc';\r\nimport exec from 'child_process';\r\nimport fs, { existsSync } from 'fs';\r\nimport { LFX_Baker } from './LFX_Baker';\r\nimport { LFX_Light, LFX_LightProbe, LFX_Material, LFX_Mesh, LFX_Terrain, LFX_Triangle, LFX_Vertex, LFX_World } from './LFX_Types';\r\nimport { NodeOperationType } from '../../event-enum';\r\nconst nodeMgr = cce.Node;\r\nimport { formatBytes } from '../../panel/operation/image';\r\nimport * as portFinder from './Port';\r\nimport fe from 'fs-extra';\r\nimport { Profile } from '../../profile';\r\n/**\r\n * @en Clamps a value between a minimum float and maximum float value.<br/>\r\n * @zh 返回最小浮点数和最大浮点数之间的一个数值。可以使用 clamp 函数将不断变化的数值限制在范围内。\r\n * @param val\r\n * @param min\r\n * @param max\r\n */\r\nexport function clamp(val, min, max) {\r\n    if (min > max) {\r\n        const temp = min;\r\n        min = max;\r\n        max = temp;\r\n    }\r\n    return val < min ? min : val > max ? max : val;\r\n}\r\nlet fileInfoMap;\r\nasync function readImageList(path, isSub = false, callback) {\r\n    isSub || (fileInfoMap = {});\r\n    const files = fs.readdirSync(path);\r\n    await Editor.Message.request('asset-db', 'refresh-asset', path);\r\n    await Promise.all(files.map(async (itm) => {\r\n        const res = join(path, itm);\r\n        const stat = fs.statSync(res);\r\n        if (stat.isDirectory()) {\r\n            // 递归读取文件\r\n            await readImageList(res, true);\r\n        }\r\n        else {\r\n            if (itm.endsWith('.png')) {\r\n                const url = await Editor.Message.request('asset-db', 'query-url', res);\r\n                let uuid = null;\r\n                if (url) {\r\n                    uuid = await Editor.Message.request('asset-db', 'query-uuid', url);\r\n                }\r\n                const metaPath = res + '.meta';\r\n                if (existsSync(metaPath)) {\r\n                    try {\r\n                        const json = fe.readJSONSync(metaPath);\r\n                        json.userData || (json.userData = {});\r\n                        const userData = json.userData;\r\n                        userData.fixAlphaTransparencyArtifacts = false;\r\n                        userData.type = 'texture';\r\n                        fe.writeJsonSync(metaPath, json, { encoding: 'utf8', spaces: 2 });\r\n                        await Editor.Message.request('asset-db', 'refresh-asset', res);\r\n                    }\r\n                    catch (error) {\r\n                        console.error('change meta failed', res);\r\n                        console.error(error);\r\n                    }\r\n                }\r\n                // 定义一个对象存放图片的路径和名字\r\n                const obj = {\r\n                    path,\r\n                    filename: itm,\r\n                    size: formatBytes(stat.size),\r\n                    uuid,\r\n                };\r\n                fileInfoMap[obj.filename] = obj;\r\n                // @6c48a 为texture类型\r\n                await new Promise((resolve, reject) => {\r\n                    assetManager.loadAny(obj.uuid + '@6c48a', (err, texture) => {\r\n                        if (err) {\r\n                            reject(err);\r\n                        }\r\n                        else {\r\n                            obj.texture = texture;\r\n                            resolve();\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    }));\r\n    callback && callback(fileInfoMap);\r\n    return fileInfoMap;\r\n}\r\n// tslint:disable-next-line: class-name\r\nexport class LFX_App {\r\n    constructor() {\r\n        this.Baker = new LFX_Baker();\r\n        this.Scene = null;\r\n        this.Models = [];\r\n        this.Lights = [];\r\n        this.Terrains = [];\r\n        this.MainLight = null;\r\n        this.MainCamera = null;\r\n        this._numLights = 0;\r\n        this._numObjects = 0;\r\n        this._numTriangles = 0;\r\n        this._currentTicks = 0;\r\n        this._lastTicks = 0;\r\n        this._uploadPath = '';\r\n        this._process = null;\r\n        this._timer = null;\r\n    }\r\n    // 重置节点lightmap\r\n    static Reset(node) {\r\n        const HideInHierarchy = 1 << 10;\r\n        const scene = node.scene;\r\n        if (scene !== null) {\r\n            scene.globals.bakedWithStationaryMainLight = false;\r\n            scene.globals.bakedWithHighpLightmap = false;\r\n        }\r\n        const terrain = node.getComponent(Terrain);\r\n        if (terrain != null && terrain.enabled) {\r\n            for (let i = 0; i < terrain.getBlocks().length; ++i) {\r\n                terrain._updateLightmap(i, null, 0, 0, 0, 0);\r\n            }\r\n        }\r\n        const models = node.getComponents(MeshRenderer);\r\n        for (const model of models) {\r\n            model._updateLightmap(null, 0, 0, 0, 0);\r\n            if (model.node) {\r\n                const compIndex = model.node.components.indexOf(model);\r\n                nodeMgr.emit('change', model.node, { type: NodeOperationType.SET_PROPERTY, propPath: `__comps__.${compIndex}.bakeSettings` });\r\n            }\r\n        }\r\n        const lights = node.getComponents(Light);\r\n        for (const light of lights) {\r\n            light.baked = false;\r\n        }\r\n        for (const child of node.children) {\r\n            if (!child.active) {\r\n                continue;\r\n            }\r\n            if (child._objFlags & HideInHierarchy) {\r\n                continue;\r\n            }\r\n            this.Reset(child);\r\n        }\r\n    }\r\n    // 禁用/启用lightmap\r\n    static Disable(node, disable) {\r\n        if (node.scene === null) {\r\n            return;\r\n        }\r\n        node.scene.globals.disableLightmap = disable;\r\n        // Notify all shader macros changed\r\n        //director.root?.onGlobalPipelineStateChanged();\r\n        const HideInHierarchy = 1 << 10;\r\n        const terrain = node.getComponent(Terrain);\r\n        if (terrain != null && terrain.enabled) {\r\n            for (let y = 0; y < terrain.info.blockCount[1]; ++y) {\r\n                for (let x = 0; x < terrain.info.blockCount[0]; ++x) {\r\n                    const blockId = y * terrain.info.blockCount[0] + x;\r\n                    const lmapInfo = terrain._getLightmapInfo(x, y);\r\n                    if (lmapInfo !== null && lmapInfo.texture !== null) {\r\n                        terrain._updateLightmap(blockId, lmapInfo.texture, lmapInfo.UOff, lmapInfo.VOff, lmapInfo.UScale, lmapInfo.VScale);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const models = node.getComponents(MeshRenderer);\r\n        for (const model of models) {\r\n            const lmapInfo = model.bakeSettings;\r\n            if (lmapInfo.texture !== null) {\r\n                model._updateLightmap(lmapInfo.texture, lmapInfo.uvParam.x, lmapInfo.uvParam.y, lmapInfo.uvParam.z, lmapInfo.uvParam.w);\r\n            }\r\n        }\r\n        for (const child of node.children) {\r\n            if (!child.active) {\r\n                continue;\r\n            }\r\n            if (child._objFlags & HideInHierarchy) {\r\n                continue;\r\n            }\r\n            this.Disable(child, disable);\r\n        }\r\n    }\r\n    static DirtyBaked(node) {\r\n        const HideInHierarchy = 1 << 10;\r\n        if (node.mobility == MobilityMode.Static) {\r\n            const lights = node.getComponents(Light);\r\n            for (const light of lights) {\r\n                light.baked = true;\r\n            }\r\n        }\r\n        for (const child of node.children) {\r\n            if (!child.active) {\r\n                continue;\r\n            }\r\n            if (child._objFlags & HideInHierarchy) {\r\n                continue;\r\n            }\r\n            this.DirtyBaked(child);\r\n        }\r\n    }\r\n    Init(data = {}) {\r\n        this.Baker.World = new LFX_World();\r\n        this.Scene = null;\r\n        this.Models = [];\r\n        this.Lights = [];\r\n        this.Terrains = [];\r\n        this.MainLight = null;\r\n        this.MainCamera = null;\r\n        this._currentTicks = 0;\r\n        this._lastTicks = 0;\r\n        // 场景名字\r\n        this.Baker.World.Name = data.name || 'Test';\r\n        // 服务器地址\r\n        // this.Baker.World.Settings.Server = data.server || 'localhost:9002';\r\n        // 环境光照\r\n        // this.Baker.World.Settings.Ambient = data.ambient || [0.0, 0.0, 0.0];\r\n        // 天空辐照度(用于全局光照)\r\n        this.Baker.World.Settings.SkyRadiance = data.skyRadiance || [0.5, 0.5, 0.5];\r\n        // 高精度模式\r\n        this.Baker.World.Settings.Highp = data.highp ? true : false;\r\n        // 多重采样: 值(1, 2, 4, 8)\r\n        this.Baker.World.Settings.MSAA = data.msaa || 4;\r\n        // 烘培贴图大小: 值(128, 256, 512, 1024, 2048)\r\n        this.Baker.World.Settings.Size = data.size || 1024;\r\n        // Gamma值\r\n        this.Baker.World.Settings.Gamma = 2.2;\r\n        // 全局光照缩放\r\n        this.Baker.World.Settings.GIScale = data.giScale || 0;\r\n        // 全局光照采样数\r\n        // 全局光照光线最大跟踪次数\r\n        this.Baker.World.Settings.GIPathLength = data.giPathLength || 4;\r\n        // AO等级\r\n        this.Baker.World.Settings.AOLevel = data.aoLevel || 0;\r\n        // AO颜色\r\n        this.Baker.World.Settings.AOColor = data.aoColor || [127.5, 127.5, 127.5];\r\n        // AO半径\r\n        this.Baker.World.Settings.AORadius = data.aoRadius || 1.0;\r\n        // AO强度\r\n        this.Baker.World.Settings.AOStrength = data.aoStrength || 1.0;\r\n        // 线程数量\r\n        this.Baker.World.Settings.Threads = data.threads || 1;\r\n        // 过滤开关\r\n        this.Baker.World.Settings.Filter = (data.filter !== undefined ? data.filter : false);\r\n        this._uploadPath = data.path || '';\r\n    }\r\n    Index2Str(index) {\r\n        let str = '';\r\n        if (index < 1000) {\r\n            str = str + '0';\r\n        }\r\n        if (index < 100) {\r\n            str = str + '0';\r\n        }\r\n        if (index < 10) {\r\n            str = str + '0';\r\n        }\r\n        str = str + index;\r\n        return str;\r\n    }\r\n    Cancel() {\r\n        if (this._timer) {\r\n            clearInterval(this._timer);\r\n            this.Baker.Stop();\r\n            this.Baker.Close();\r\n            this._timer = null;\r\n            this.Baker.emit('cancel', true);\r\n            if (this._process !== null) {\r\n                this._process.kill('SIGKILL');\r\n                this._process = null;\r\n            }\r\n        }\r\n    }\r\n    async Bake(node) {\r\n        this.Baker.World.Settings.BakeLightMap = true;\r\n        this.Baker.World.Settings.BakeLightProbe = true;\r\n        await this._bakeImp(node);\r\n    }\r\n    async BakeLightMap(node) {\r\n        this.Baker.World.Settings.BakeLightMap = true;\r\n        this.Baker.World.Settings.BakeLightProbe = false;\r\n        await this._bakeImp(node);\r\n    }\r\n    async BakeLightProbe(node) {\r\n        this.Baker.World.Settings.BakeLightMap = false;\r\n        this.Baker.World.Settings.BakeLightProbe = true;\r\n        await this._bakeImp(node);\r\n    }\r\n    async _bakeImp(node) {\r\n        if (this._process) {\r\n            console.warn('Baker has already starting');\r\n            return;\r\n        }\r\n        this.Scene = node;\r\n        this._numLights = 0;\r\n        this._numObjects = 0;\r\n        this._numTriangles = 0;\r\n        this._export(node);\r\n        this._exportLightProbes(node.scene);\r\n        const scene = this.Scene?.scene;\r\n        if (this.Baker.World.Settings.BakeLightProbe && scene && scene.globals && scene.globals.lightProbeInfo) {\r\n            this.Baker.World.Settings.GIProbeScale = scene.globals.lightProbeInfo.giScale;\r\n            this.Baker.World.Settings.GIProbeSamples = scene.globals.lightProbeInfo.giSamples;\r\n            this.Baker.World.Settings.GIProbePathLength = scene.globals.lightProbeInfo.bounces;\r\n        }\r\n        for (const mesh of this.Baker.World.Meshes) {\r\n            for (const mtl of mesh.MaterialBuffer) {\r\n                if (mtl.Texture.length === 0) {\r\n                    continue;\r\n                }\r\n                const uuid = mtl.Texture;\r\n                if (uuid.search('@') === -1) {\r\n                    const filename = await Editor.Message.request('asset-db', 'query-path', uuid);\r\n                    if (filename !== null) {\r\n                        mtl.Texture = filename;\r\n                    }\r\n                    else {\r\n                        mtl.Texture = '';\r\n                    }\r\n                }\r\n                else {\r\n                    mtl.Texture = join(Editor.Project.path, 'library', uuid.substr(0, 2), uuid);\r\n                }\r\n                if (mtl.Texture.length === 0) {\r\n                    console.warn('query-path texture ' + uuid + ' failed');\r\n                }\r\n            }\r\n        }\r\n        if (director.root.pipeline.pipelineSceneData.isHDR) {\r\n            const e = renderer.scene.Camera.standardExposureValue;\r\n            for (const light of this.Baker.World.Lights) {\r\n                light.Color[0] *= light.Illuminance * e;\r\n                light.Color[1] *= light.Illuminance * e;\r\n                light.Color[2] *= light.Illuminance * e;\r\n            }\r\n        }\r\n        else {\r\n            for (const light of this.Baker.World.Lights) {\r\n                light.Color[0] *= light.Illuminance;\r\n                light.Color[1] *= light.Illuminance;\r\n                light.Color[2] *= light.Illuminance;\r\n            }\r\n        }\r\n        this.Baker.Upload(this._uploadPath);\r\n        this._run();\r\n    }\r\n    async _export(node) {\r\n        this._exportImp(node);\r\n    }\r\n    _exportImp(node) {\r\n        if (node.mobility === MobilityMode.Movable) {\r\n            return;\r\n        }\r\n        if (!(node instanceof Scene)) {\r\n            this._exportNode(node);\r\n        }\r\n        const HideInHierarchy = 1 << 10;\r\n        for (const child of node.children) {\r\n            if (!child.active) {\r\n                continue;\r\n            }\r\n            if (child._objFlags & HideInHierarchy) {\r\n                continue;\r\n            }\r\n            this._exportImp(child);\r\n        }\r\n    }\r\n    _exportNode(node) {\r\n        const terrain = node.getComponent(Terrain);\r\n        if (terrain != null && terrain.enabled) {\r\n            this._exportTerrain(terrain);\r\n        }\r\n        const models = node.getComponents(MeshRenderer);\r\n        for (const model of models) {\r\n            if (model.enabled) {\r\n                this._exportModel(model);\r\n            }\r\n        }\r\n        const lights = node.getComponents(Light);\r\n        for (const light of lights) {\r\n            if (light.enabled) {\r\n                this._exportLight(light);\r\n            }\r\n        }\r\n        /*\r\n        const cameras = node.getComponents(Camera);\r\n        for (const camera of cameras) {\r\n            if (camera.enabled) {\r\n                this._exportCamera(camera);\r\n            }\r\n        }\r\n        */\r\n    }\r\n    _exportTerrain(terrain) {\r\n        const fxterrain = new LFX_Terrain();\r\n        fxterrain.Position[0] = terrain.node.getWorldPosition().x;\r\n        fxterrain.Position[1] = terrain.node.getWorldPosition().y;\r\n        fxterrain.Position[2] = terrain.node.getWorldPosition().z;\r\n        fxterrain.TileSize = terrain.info.tileSize;\r\n        fxterrain.BlockCount[0] = terrain.info.blockCount[0];\r\n        fxterrain.BlockCount[1] = terrain.info.blockCount[1];\r\n        fxterrain.LightMapSize = terrain.info.lightMapSize;\r\n        // @ts-ignore\r\n        fxterrain.HeightField = terrain.getHeightField();\r\n        this.Baker.World.Terrains.push(fxterrain);\r\n        this.Terrains.push(terrain);\r\n        this._numObjects++;\r\n        this._numTriangles += fxterrain.BlockCount[0] * fxterrain.BlockCount[1] * 2048;\r\n    }\r\n    async _exportModel(model) {\r\n        const mesh = model.mesh;\r\n        if (mesh == null) {\r\n            return false;\r\n        }\r\n        if (this.Baker.World.Settings.BakeLightMap) {\r\n            if (!model.bakeSettings.bakeable && !model.bakeSettings.castShadow) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (this.Baker.World.Settings.BakeLightProbe) {\r\n            if (!model.bakeSettings.bakeToLightProbe) {\r\n                return false;\r\n            }\r\n        }\r\n        const fxmesh = new LFX_Mesh();\r\n        if (this.Baker.World.Settings.BakeLightMap) {\r\n            fxmesh.CastShadow = model.bakeSettings.castShadow;\r\n            fxmesh.ReceiveShadow = model.bakeSettings.receiveShadow;\r\n            if (model.bakeSettings.bakeable) {\r\n                fxmesh.LightMapSize = model.bakeSettings.lightmapSize;\r\n            }\r\n        }\r\n        else if (this.Baker.World.Settings.BakeLightProbe) {\r\n            fxmesh.CastShadow = model.bakeSettings.bakeToLightProbe;\r\n        }\r\n        let missLightmapUV = false;\r\n        let errorLightmapUV = false;\r\n        let startVertex = 0;\r\n        const worldTM = model.node.getWorldMatrix();\r\n        for (let iPrimitive = 0; iPrimitive < mesh.struct.primitives.length; ++iPrimitive) {\r\n            const positions = mesh.readAttribute(iPrimitive, gfx.AttributeName.ATTR_POSITION);\r\n            const normals = mesh.readAttribute(iPrimitive, gfx.AttributeName.ATTR_NORMAL);\r\n            const uvs = mesh.readAttribute(iPrimitive, gfx.AttributeName.ATTR_TEX_COORD);\r\n            const luvs = mesh.readAttribute(iPrimitive, gfx.AttributeName.ATTR_TEX_COORD1);\r\n            const indices = mesh.readIndices(iPrimitive);\r\n            // 检查是否有效\r\n            if (!positions || !normals || !indices) {\r\n                return false;\r\n            }\r\n            if (positions.length !== normals.length) {\r\n                return false;\r\n            }\r\n            if (uvs != null && positions.length / 3 !== uvs.length / 2) {\r\n                return false;\r\n            }\r\n            if (luvs != null && positions.length / 3 !== luvs.length / 2) {\r\n                return false;\r\n            }\r\n            // 没有lightmap uv\r\n            if (luvs == null) {\r\n                if (fxmesh.LightMapSize > 0) {\r\n                    missLightmapUV = true;\r\n                }\r\n                fxmesh.ReceiveShadow = false;\r\n            }\r\n            // 顶点数据\r\n            for (let v = 0; v < positions.length / 3; ++v) {\r\n                const P = new Vec3();\r\n                P.x = positions[v * 3 + 0];\r\n                P.y = positions[v * 3 + 1];\r\n                P.z = positions[v * 3 + 2];\r\n                Vec3.transformMat4(P, P, worldTM);\r\n                const N = new Vec3();\r\n                N.x = normals[v * 3 + 0];\r\n                N.y = normals[v * 3 + 1];\r\n                N.z = normals[v * 3 + 2];\r\n                Vec3.transformMat4Normal(N, N, worldTM);\r\n                N.normalize();\r\n                const vertex = new LFX_Vertex();\r\n                vertex.Position[0] = P.x;\r\n                vertex.Position[1] = P.y;\r\n                vertex.Position[2] = P.z;\r\n                vertex.Normal[0] = N.x;\r\n                vertex.Normal[1] = N.y;\r\n                vertex.Normal[2] = N.z;\r\n                if (uvs != null) {\r\n                    vertex.UV[0] = uvs[v * 2 + 0];\r\n                    vertex.UV[1] = uvs[v * 2 + 1];\r\n                }\r\n                if (luvs != null && fxmesh.LightMapSize > 0) {\r\n                    vertex.LUV[0] = luvs[v * 2 + 0];\r\n                    vertex.LUV[1] = luvs[v * 2 + 1];\r\n                    if (vertex.LUV[0] < 0 || vertex.LUV[0] > 1 ||\r\n                        vertex.LUV[1] < 0 || vertex.LUV[1] > 1) {\r\n                        errorLightmapUV = true;\r\n                    }\r\n                }\r\n                fxmesh.VertexBuffer.push(vertex);\r\n            }\r\n            // 索引数据\r\n            for (let i = 0; i < indices.length / 3; ++i) {\r\n                const tri = new LFX_Triangle();\r\n                if (positions.length < 256) {\r\n                    tri.Index[0] = indices[i * 3 + 0] + startVertex;\r\n                    tri.Index[1] = indices[i * 3 + 1] + startVertex;\r\n                    tri.Index[2] = indices[i * 3 + 2] + startVertex;\r\n                }\r\n                else if (positions.length < 65536) {\r\n                    tri.Index[0] = indices[i * 3 + 0] + startVertex;\r\n                    tri.Index[1] = indices[i * 3 + 1] + startVertex;\r\n                    tri.Index[2] = indices[i * 3 + 2] + startVertex;\r\n                }\r\n                else {\r\n                    tri.Index[0] = indices[i * 3 + 0] + startVertex;\r\n                    tri.Index[1] = indices[i * 3 + 1] + startVertex;\r\n                    tri.Index[2] = indices[i * 3 + 2] + startVertex;\r\n                }\r\n                if (model.materials.length > 0) {\r\n                    tri.MaterialId = clamp(iPrimitive, 0, model.materials.length - 1);\r\n                }\r\n                else {\r\n                    tri.MaterialId = 0;\r\n                }\r\n                fxmesh.TriangleBuffer.push(tri);\r\n            }\r\n            startVertex = fxmesh.VertexBuffer.length;\r\n        }\r\n        // Materials\r\n        if (model.materials.length > 0) {\r\n            const PixelFormat = Texture2D.PixelFormat;\r\n            for (let m = 0; m < model.materials.length; ++m) {\r\n                const fxmtl = new LFX_Material();\r\n                fxmtl.Diffuse[0] = 1;\r\n                fxmtl.Diffuse[1] = 1;\r\n                fxmtl.Diffuse[2] = 1;\r\n                fxmtl.Emissive[0] = 0;\r\n                fxmtl.Emissive[1] = 0;\r\n                fxmtl.Emissive[2] = 0;\r\n                const mmtl = model.materials[m];\r\n                if (mmtl !== null) {\r\n                    const mainColor = mmtl.getProperty('mainColor', 0);\r\n                    if (mainColor) {\r\n                        fxmtl.Diffuse[0] = mainColor.x;\r\n                        fxmtl.Diffuse[1] = mainColor.y;\r\n                        fxmtl.Diffuse[2] = mainColor.z;\r\n                    }\r\n                    if (mmtl.passes[0].blendState.targets[0].blend) {\r\n                        // Blend is enabled\r\n                        fxmtl.AlphaCulloff = 0.5;\r\n                    }\r\n                    else {\r\n                        // Alpha test\r\n                        const alphaThreshold = mmtl.getProperty('alphaThreshold', 0);\r\n                        if (alphaThreshold) {\r\n                            fxmtl.AlphaCulloff = alphaThreshold;\r\n                        }\r\n                        else {\r\n                            fxmtl.AlphaCulloff = 0.5;\r\n                        }\r\n                    }\r\n                    const roughness = mmtl.getProperty('roughness', 0);\r\n                    if (roughness) {\r\n                        fxmtl.Roughness = roughness;\r\n                    }\r\n                    else {\r\n                        fxmtl.Roughness = 0.8;\r\n                    }\r\n                    const metallic = mmtl.getProperty('metallic', 0);\r\n                    if (metallic) {\r\n                        fxmtl.Metallic = metallic;\r\n                    }\r\n                    else {\r\n                        fxmtl.Metallic = 0.6;\r\n                    }\r\n                    const albedoScale = mmtl.getProperty('albedoScale', 0);\r\n                    if (albedoScale) {\r\n                        if (albedoScale instanceof Vec3) {\r\n                            fxmtl.Diffuse[0] *= albedoScale.x;\r\n                            fxmtl.Diffuse[1] *= albedoScale.y;\r\n                            fxmtl.Diffuse[2] *= albedoScale.z;\r\n                        }\r\n                        else {\r\n                            fxmtl.Diffuse[0] *= albedoScale;\r\n                            fxmtl.Diffuse[1] *= albedoScale;\r\n                            fxmtl.Diffuse[2] *= albedoScale;\r\n                        }\r\n                    }\r\n                    let tex = mmtl.getProperty('mainTexture', 0);\r\n                    if (tex == null) {\r\n                        tex = mmtl.getProperty('albedoMap', 0);\r\n                    }\r\n                    const isValidTextureFormat = (tex) => {\r\n                        const format = tex.getPixelFormat();\r\n                        return format == PixelFormat.RGBA8888 || format === PixelFormat.RGB888;\r\n                    };\r\n                    if (tex !== null && isValidTextureFormat(tex)) {\r\n                        const asset = tex.mipmaps[0];\r\n                        if (asset !== null) {\r\n                            if (asset._uuid.search('@') !== -1) {\r\n                                fxmtl.Texture = asset._uuid + asset._native;\r\n                            }\r\n                            else {\r\n                                fxmtl.Texture = asset._uuid;\r\n                            }\r\n                        }\r\n                    }\r\n                    tex = mmtl.getProperty('pbrMap', 0);\r\n                    if (tex !== null && isValidTextureFormat(tex)) {\r\n                        const asset = tex.mipmaps[0];\r\n                        if (asset !== null) {\r\n                            if (asset._uuid.search('@') !== -1) {\r\n                                fxmtl.PBRMap = asset._uuid + asset._native;\r\n                            }\r\n                            else {\r\n                                fxmtl.PBRMap = asset._uuid;\r\n                            }\r\n                        }\r\n                    }\r\n                    // export emissive material parameters\r\n                    const emissiveColor = mmtl.getProperty('emissive', 0);\r\n                    if (emissiveColor) {\r\n                        fxmtl.Emissive[0] = emissiveColor.x;\r\n                        fxmtl.Emissive[1] = emissiveColor.y;\r\n                        fxmtl.Emissive[2] = emissiveColor.z;\r\n                        const emissiveScale = mmtl.getProperty('emissiveScale', 0);\r\n                        if (emissiveScale) {\r\n                            if (emissiveScale instanceof Vec3) {\r\n                                fxmtl.Emissive[0] *= emissiveScale.x;\r\n                                fxmtl.Emissive[1] *= emissiveScale.y;\r\n                                fxmtl.Emissive[2] *= emissiveScale.z;\r\n                            }\r\n                            else {\r\n                                fxmtl.Emissive[0] *= emissiveScale;\r\n                                fxmtl.Emissive[1] *= emissiveScale;\r\n                                fxmtl.Emissive[2] *= emissiveScale;\r\n                            }\r\n                        }\r\n                    }\r\n                    tex = mmtl.getProperty('emissiveMap', 0);\r\n                    if (tex !== null && isValidTextureFormat(tex)) {\r\n                        const asset = tex.mipmaps[0];\r\n                        if (asset !== null) {\r\n                            if (asset._uuid.search('@') !== -1) {\r\n                                fxmtl.EmissiveMap = asset._uuid + asset._native;\r\n                            }\r\n                            else {\r\n                                fxmtl.EmissiveMap = asset._uuid;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                fxmesh.MaterialBuffer.push(fxmtl);\r\n            }\r\n        }\r\n        else {\r\n            const fxmtl = new LFX_Material();\r\n            fxmtl.Diffuse[0] = 1;\r\n            fxmtl.Diffuse[1] = 1;\r\n            fxmtl.Diffuse[2] = 1;\r\n            fxmesh.MaterialBuffer.push(fxmtl);\r\n        }\r\n        if (missLightmapUV) {\r\n            if (this.Baker.World.Settings.BakeLightMap) {\r\n                const filename = await Editor.Message.request('asset-db', 'query-path', mesh._uuid);\r\n                if (filename) {\r\n                    console.error('Error: missing lightmap uv, ' + filename);\r\n                }\r\n                else {\r\n                    console.error('Error: missing lightmap uv, ' + mesh._uuid);\r\n                }\r\n            }\r\n        }\r\n        else if (errorLightmapUV) {\r\n            if (this.Baker.World.Settings.BakeLightMap) {\r\n                const filename = await Editor.Message.request('asset-db', 'query-path', mesh._uuid);\r\n                if (filename) {\r\n                    console.error('Error: error lightmap uv, ' + filename);\r\n                }\r\n                else {\r\n                    console.error('Error: error lightmap uv, ' + mesh._uuid);\r\n                }\r\n            }\r\n            fxmesh.LightMapSize = 0;\r\n        }\r\n        this.Baker.World.Meshes.push(fxmesh);\r\n        this.Models.push(model);\r\n        this._numObjects++;\r\n        if (fxmesh.LightMapSize > 0) {\r\n            this._numTriangles += fxmesh.TriangleBuffer.length;\r\n        }\r\n    }\r\n    _exportLight(light) {\r\n        const fxlight = new LFX_Light();\r\n        fxlight.Type = LFX_Light.DIRECTION;\r\n        fxlight.GIEnable = true;\r\n        fxlight.CastShadow = light.staticSettings.castShadow;\r\n        fxlight.Position[0] = light.node.getWorldPosition().x;\r\n        fxlight.Position[1] = light.node.getWorldPosition().y;\r\n        fxlight.Position[2] = light.node.getWorldPosition().z;\r\n        const dir = new Vec3(0, 0, -1);\r\n        Vec3.transformQuat(dir, dir, light.node.getWorldRotation());\r\n        fxlight.Direction[0] = dir.x;\r\n        fxlight.Direction[1] = dir.y;\r\n        fxlight.Direction[2] = dir.z;\r\n        fxlight.Color[0] = light.color.x;\r\n        fxlight.Color[1] = light.color.y;\r\n        fxlight.Color[2] = light.color.z;\r\n        const _lightMeterScale = 10000.0;\r\n        if (light instanceof DirectionalLight) {\r\n            const l = light;\r\n            fxlight.Type = LFX_Light.DIRECTION;\r\n            fxlight.Illuminance = l.illuminance;\r\n            fxlight.ShadowMask = 1.0 - l.shadowSaturation;\r\n            if (this.MainLight === null) {\r\n                this.MainLight = light;\r\n            }\r\n        }\r\n        else if (light instanceof SphereLight) {\r\n            const l = light;\r\n            fxlight.Type = LFX_Light.POINT;\r\n            fxlight.Size = l.size;\r\n            fxlight.Range = l.range;\r\n            fxlight.AttenFallOff = 1;\r\n            fxlight.Illuminance = l.luminance;\r\n            if (director.root.pipeline.pipelineSceneData.isHDR) {\r\n                fxlight.Illuminance *= _lightMeterScale;\r\n            }\r\n        }\r\n        else if (light instanceof SpotLight) {\r\n            const l = light;\r\n            fxlight.Type = LFX_Light.SPOT;\r\n            fxlight.Size = l.size;\r\n            fxlight.Range = l.range;\r\n            fxlight.AttenFallOff = 1;\r\n            fxlight.SpotInner = Math.cos(l.spotAngle / 4 * (Math.PI / 180.0));\r\n            fxlight.SpotOuter = Math.cos(l.spotAngle / 2 * (Math.PI / 180.0));\r\n            fxlight.SpotFallOff = 1;\r\n            fxlight.Illuminance = l.luminance;\r\n            if (director.root.pipeline.pipelineSceneData.isHDR) {\r\n                fxlight.Illuminance *= _lightMeterScale;\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        if (light.node.mobility === MobilityMode.Static) {\r\n            fxlight.DirectScale = 1;\r\n            fxlight.IndirectScale = 1;\r\n        }\r\n        else {\r\n            fxlight.DirectScale = 0;\r\n            fxlight.IndirectScale = 1;\r\n        }\r\n        this.Baker.World.Lights.push(fxlight);\r\n        this.Lights.push(light);\r\n        this._numLights++;\r\n    }\r\n    _exportCamera(camera) {\r\n        if (this.MainCamera === null) {\r\n            this.MainCamera = camera;\r\n        }\r\n        else if (camera.node.name === 'MainCamera') {\r\n            this.MainCamera = camera;\r\n        }\r\n    }\r\n    _exportLightProbes(scene) {\r\n        if (scene.globals.lightProbeInfo.data === null) {\r\n            return;\r\n        }\r\n        for (const probe of scene.globals.lightProbeInfo.data.probes) {\r\n            const lfxLightProbe = new LFX_LightProbe;\r\n            lfxLightProbe.Position[0] = probe.position.x;\r\n            lfxLightProbe.Position[1] = probe.position.y;\r\n            lfxLightProbe.Position[2] = probe.position.z;\r\n            lfxLightProbe.Normal[0] = probe.normal.x;\r\n            lfxLightProbe.Normal[1] = probe.normal.y;\r\n            lfxLightProbe.Normal[2] = probe.normal.z;\r\n            this.Baker.World.LightProbes.push(lfxLightProbe);\r\n        }\r\n    }\r\n    _run() {\r\n        const lfx_debug = false;\r\n        let lfx_launching = false;\r\n        let lfx_port = 3000;\r\n        // 获取端口\r\n        if (!lfx_debug) {\r\n            lfx_port = 0;\r\n            portFinder.getPort((err, port) => {\r\n                if (!err) {\r\n                    lfx_port = port;\r\n                }\r\n                else {\r\n                    lfx_port = -1;\r\n                    console.log('Configure port failed');\r\n                }\r\n            });\r\n        }\r\n        console.log('Start baker server ' + lfx_port);\r\n        // 定时器模拟更新\r\n        this._timer = setInterval(() => {\r\n            if (!lfx_launching) {\r\n                if (lfx_port > 0) {\r\n                    this.Baker.Launch(lfx_port);\r\n                    // 启动烘焙程序 (调试模式从c++启动)\r\n                    if (!lfx_debug) {\r\n                        const LFX_URL = 'http://127.0.0.1:' + lfx_port;\r\n                        const LFX_SERVER = this.Baker.lfxpath + '/LightFX';\r\n                        console.log('Launching ' + LFX_SERVER);\r\n                        this._process = exec.execFile(LFX_SERVER, [LFX_URL], { cwd: this._uploadPath }, (err, stdout, stderr) => {\r\n                            // TODO 确认为什么要用 kill 退出进程，kill 退出会报 err\r\n                            if (err && err.signal !== 'SIGKILL') {\r\n                                this.Baker.Error = true;\r\n                                console.error(err);\r\n                                console.error('Baker app aborted with an exception');\r\n                                this.Baker.Stop();\r\n                                clearInterval(this._timer);\r\n                                this.Baker.Close();\r\n                                this._timer = null;\r\n                                this.Baker.emit('end', true);\r\n                                this._process.kill('SIGKILL');\r\n                            }\r\n                        });\r\n                        if (!this._process) {\r\n                            console.log('Launching baker failed.');\r\n                            clearInterval(this._timer);\r\n                        }\r\n                    }\r\n                    lfx_launching = true;\r\n                }\r\n                else if (lfx_port < 0) {\r\n                    // error\r\n                    clearInterval(this._timer);\r\n                }\r\n                return;\r\n            }\r\n            if (this.Baker.closed) {\r\n                clearInterval(this._timer);\r\n                return;\r\n            }\r\n            if (!this.Baker.Started) {\r\n                // 开始烘培\r\n                if (this.Baker.connected) {\r\n                    this.Baker.Start();\r\n                    this.Baker.client.on('Tick', (data) => {\r\n                        this._lastTicks = this._currentTicks;\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                // 结束了\r\n                if (this.Baker.Finished) {\r\n                    console.log('End');\r\n                    let file = null;\r\n                    try {\r\n                        file = this.Baker.Download();\r\n                    }\r\n                    catch (error) {\r\n                        console.error('LightFX get result file failed.');\r\n                        file = null;\r\n                    }\r\n                    const bakeStats = 'Bake scene stats:\\n' +\r\n                        '\\tobjects ' + this._numObjects + '\\n' +\r\n                        '\\tlights ' + this._numLights + '\\n' +\r\n                        '\\ttriangles ' + this._numTriangles + '\\n';\r\n                    this.Baker.emit('log', bakeStats);\r\n                    if (file !== null) {\r\n                        // 模型的Lightmap信息\r\n                        for (let i = 0; i < file.MeshInfos.length; ++i) {\r\n                            // 对应output/LFX_Mesh_xxxx.png\r\n                            const info = file.MeshInfos[i];\r\n                            const logInfo = 'Mesh ' +\r\n                                info.Id +\r\n                                ':' +\r\n                                ' Index(' +\r\n                                info.Index +\r\n                                ') ' +\r\n                                ' Offset(' +\r\n                                info.Offset[0] +\r\n                                ', ' +\r\n                                info.Offset[1] +\r\n                                ') ' +\r\n                                ' Scale(' +\r\n                                info.Scale[0] +\r\n                                ', ' +\r\n                                info.Scale[1] +\r\n                                ')';\r\n                            this.Baker.emit('log', logInfo);\r\n                        }\r\n                        // LightProbe信息\r\n                        for (let i = 0; i < file.LightProbeInfos.length; ++i) {\r\n                            const info = file.LightProbeInfos[i];\r\n                            const logInfo = 'LightProbe ' + i + ':' +\r\n                                ' pos(' +\r\n                                info.Position[0] + ', ' +\r\n                                info.Position[1] + ', ' +\r\n                                info.Position[2] + ')' +\r\n                                ' coef(' +\r\n                                info.Coefficients[0] + ', ' +\r\n                                info.Coefficients[1] + ', ' +\r\n                                info.Coefficients[2] + ', ...)';\r\n                            this.Baker.emit('log', logInfo);\r\n                        }\r\n                    }\r\n                    this.Baker.Stop();\r\n                    clearInterval(this._timer);\r\n                    this.Baker.Close();\r\n                    this._timer = null;\r\n                    this.Baker.emit('end', true);\r\n                    if (this._process !== null) {\r\n                        this._process.kill('SIGKILL');\r\n                        this._process = null;\r\n                    }\r\n                    if (this.Baker.World.Settings.BakeLightMap) {\r\n                        const scene = this.Scene?.scene;\r\n                        if (this.Scene != null) {\r\n                            LFX_App.DirtyBaked(this.Scene);\r\n                        }\r\n                        for (const t of this.Terrains) {\r\n                            if (t.lightMapSize > 0) {\r\n                                t._resetLightmap(true);\r\n                            }\r\n                        }\r\n                        if (scene && this.MainLight && this.MainLight.node &&\r\n                            this.MainLight.node.mobility == MobilityMode.Stationary) {\r\n                            scene.globals.bakedWithStationaryMainLight = true;\r\n                        }\r\n                        if (scene) {\r\n                            scene.globals.bakedWithHighpLightmap = this.Baker.World.Settings.Highp;\r\n                        }\r\n                    }\r\n                    if (file !== null && this.Baker.World.Settings.BakeLightProbe) {\r\n                        const scene = this.Scene?.scene;\r\n                        // 导出LightProbe信息\r\n                        const overloadLightProbeInfo = true;\r\n                        if (!scene || !scene.globals\r\n                            || !scene.globals.lightProbeInfo\r\n                            || !scene.globals.lightProbeInfo.data\r\n                            || !scene.globals.lightProbeInfo.data.probes) {\r\n                            console.warn('No light probes were found in the scene and cannot be baked.');\r\n                        }\r\n                        else if (overloadLightProbeInfo && scene.globals.lightProbeInfo.data.probes.length !== file.LightProbeInfos.length) {\r\n                            scene.globals.lightProbeInfo.data.probes.length = file.LightProbeInfos.length;\r\n                            for (let i = 0; i < scene.globals.lightProbeInfo.data.probes.length; ++i) {\r\n                                const info = file.LightProbeInfos[i];\r\n                                const pos = new Vec3(info.Position[0], info.Position[1], info.Position[2]);\r\n                                const normal = new Vec3(info.Normal[0], info.Normal[1], info.Normal[2]);\r\n                                scene.globals.lightProbeInfo.data.probes[i] = new Vertex(pos);\r\n                                const probe = scene.globals.lightProbeInfo.data.probes[i];\r\n                                if (info && probe) {\r\n                                    probe.normal = normal;\r\n                                    probe.coefficients.length = info.Coefficients.length / 3;\r\n                                    for (let j = 0; j < probe.coefficients.length; ++j) {\r\n                                        probe.coefficients[j] = new Vec3();\r\n                                        probe.coefficients[j].x = info.Coefficients[j * 3 + 0];\r\n                                        probe.coefficients[j].y = info.Coefficients[j * 3 + 1];\r\n                                        probe.coefficients[j].z = info.Coefficients[j * 3 + 2];\r\n                                    }\r\n                                    cce.Engine.repaintInEditMode();\r\n                                    cce.SceneFacadeManager.recordNode(scene);\r\n                                    cce.SceneFacadeManager.snapshot();\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (file.LightProbeInfos.length === scene.globals.lightProbeInfo.data?.probes.length) {\r\n                                if (this.Baker.World.Settings.BakeLightProbe && scene.globals.lightProbeInfo.data) {\r\n                                    for (let i = 0; i < scene.globals.lightProbeInfo.data.probes.length; ++i) {\r\n                                        const info = file.LightProbeInfos[i];\r\n                                        const probe = scene.globals.lightProbeInfo.data.probes[i];\r\n                                        if (info && probe) {\r\n                                            probe.coefficients.length = info.Coefficients.length / 3;\r\n                                            for (let j = 0; j < probe.coefficients.length; ++j) {\r\n                                                probe.coefficients[j] = new Vec3();\r\n                                                probe.coefficients[j].x = info.Coefficients[j * 3 + 0];\r\n                                                probe.coefficients[j].y = info.Coefficients[j * 3 + 1];\r\n                                                probe.coefficients[j].z = info.Coefficients[j * 3 + 2];\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    cce.Engine.repaintInEditMode();\r\n                                    cce.SceneFacadeManager.recordNode(scene);\r\n                                    cce.SceneFacadeManager.snapshot();\r\n                                }\r\n                            }\r\n                            else {\r\n                                console.error('Light probe bake result mismatch with scene.');\r\n                            }\r\n                        }\r\n                    }\r\n                    if (file !== null && this.Baker.World.Settings.BakeLightMap) {\r\n                        readImageList(join(this._uploadPath, 'output'), false, (objs) => {\r\n                            // 地形的Lightmap信息\r\n                            for (const info of file.TerrainInfos) {\r\n                                // 对应output/LFX_Terrain_xxxx.png\r\n                                const terrain = this.Terrains[info.Id];\r\n                                const filename = 'LFX_Terrain_' + this.Index2Str(info.Index) + '.png';\r\n                                const obj = objs[filename];\r\n                                if (!obj) {\r\n                                    continue;\r\n                                }\r\n                                const tex = obj.texture;\r\n                                if (tex) {\r\n                                    terrain._updateLightmap(info.BlockId, tex, info.Offset[0], info.Offset[1], info.Scale[0], info.Scale[1]);\r\n                                }\r\n                                else {\r\n                                    terrain._updateLightmap(info.BlockId, null, info.Offset[0], info.Offset[1], info.Scale[0], info.Scale[1]);\r\n                                }\r\n                                // 记录到 undo\r\n                                Editor.Message.broadcast('scene:change-node', terrain.node.uuid);\r\n                            }\r\n                            // 模型的lightmap\r\n                            for (const info of file.MeshInfos) {\r\n                                // 对应output/LFX_Mesh_xxxx.png\r\n                                const model = this.Models[info.Id];\r\n                                const filename = 'LFX_Mesh_' + this.Index2Str(info.Index) + '.png';\r\n                                const obj = objs[filename];\r\n                                if (!obj) {\r\n                                    continue;\r\n                                }\r\n                                const tex = obj.texture;\r\n                                if (tex) {\r\n                                    model._updateLightmap(tex, info.Offset[0], info.Offset[1], info.Scale[0], info.Scale[1]);\r\n                                    // @ts-ignore\r\n                                    model.node._dirtyFlags = 1;\r\n                                }\r\n                                else {\r\n                                    model._updateLightmap(null, info.Offset[0], info.Offset[1], info.Scale[0], info.Scale[1]);\r\n                                }\r\n                                if (model.node) {\r\n                                    const compIndex = model.node.components.indexOf(model);\r\n                                    nodeMgr.emit('change', model.node, { type: NodeOperationType.SET_PROPERTY, propPath: `__comps__.${compIndex}.bakeSettings` });\r\n                                }\r\n                            }\r\n                            Profile.setLatestLightmapResults(this.Scene.uuid, Object.values(objs).map(item => item.uuid).filter(Boolean));\r\n                            Profile.setLatestLightmapResultsDir(this.Scene.uuid, this._uploadPath);\r\n                            cce.Engine.repaintInEditMode();\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            this._currentTicks += 100;\r\n        }, 100);\r\n    }\r\n}\r\nexport default LFX_App;\r\n","references":["/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/path/path.js","/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/cc/cc.d.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/extensions/lightmap/source/lightmap/backer/LFX_Baker.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/extensions/lightmap/source/lightmap/backer/LFX_Types.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/extensions/lightmap/source/event-enum.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/extensions/lightmap/source/panel/operation/image.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/extensions/lightmap/source/lightmap/backer/Port.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/@types/fs-extra/index.d.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/@types/userDatas.d.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/extensions/lightmap/source/profile/index.ts"]}
