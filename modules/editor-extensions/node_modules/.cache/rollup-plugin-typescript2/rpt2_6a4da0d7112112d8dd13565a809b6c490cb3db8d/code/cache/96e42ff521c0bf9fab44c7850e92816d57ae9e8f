{"code":"'use strict';\r\nimport fs from 'fs';\r\nimport { join } from 'path';\r\nimport Vue from 'vue';\r\nimport { Profile } from '../../profile';\r\nVue.config.productionTip = false;\r\nVue.config.devtools = false;\r\nimport readImageList, { getImageInfo } from '../operation/image';\r\nconst Chroma = require('chroma-js');\r\nexport var Modes;\r\n(function (Modes) {\r\n    Modes[Modes[\"SCENE\"] = 0] = \"SCENE\";\r\n    Modes[Modes[\"BAKED\"] = 1] = \"BAKED\";\r\n})(Modes || (Modes = {}));\r\nexport default Vue.extend({\r\n    name: 'App',\r\n    data() {\r\n        return {\r\n            mode: Modes.SCENE,\r\n            progress: 0,\r\n            logInfos: [],\r\n            picInfos: [],\r\n            selectInfo: null,\r\n            // 是否点击了生成按钮\r\n            isGenerate: false,\r\n            msaa: 4,\r\n            path: '',\r\n            size: 1024,\r\n            highp: false,\r\n            giScale: 1.0,\r\n            giSamples: 25,\r\n            giPathLength: 2,\r\n            aoLevel: 1,\r\n            aoStrength: 1.0,\r\n            aoRadius: 1.0,\r\n            aoColor: [136, 136, 136, 255],\r\n            tab: 0,\r\n            r: true,\r\n            g: true,\r\n            b: true,\r\n            a: false,\r\n            sceneUUID: '',\r\n            filter: true,\r\n        };\r\n    },\r\n    computed: {\r\n        channel() {\r\n            const result = (this.r ? 'r' : '') + (this.g ? 'g' : '') + (this.b ? 'b' : '') + (this.a ? 'a' : '');\r\n            return result || undefined;\r\n        },\r\n    },\r\n    async mounted() {\r\n        const state = await Editor.Message.request('lightmap', 'unstaging');\r\n        if (state.isStart && !state.isEnd) {\r\n            this.isGenerate = true;\r\n            this.progress = state.progress;\r\n        }\r\n        this.setLogs(state.logInfos);\r\n    },\r\n    methods: {\r\n        async onSceneReady(uuid) {\r\n            this.sceneUUID = uuid;\r\n            const uuids = await Profile.getLatestLightmapResults(uuid);\r\n            this.picInfos = (await Promise.all(uuids.map(item => getImageInfo(item)))).filter(Boolean);\r\n            this.$set(this.logInfos, 'length', 0);\r\n            this.onItemClick(0);\r\n        },\r\n        changeColor(eve) {\r\n            this.aoColor = eve.target.value;\r\n            this.saveEdit();\r\n        },\r\n        saveEdit() {\r\n            Editor.Profile.setConfig('lightmap', 'lightmap', {\r\n                msaa: this.msaa,\r\n                size: this.size,\r\n                highp: this.highp,\r\n                giScale: this.giScale,\r\n                giSamples: this.giSamples,\r\n                giPathLength: this.giPathLength,\r\n                aoLevel: this.aoLevel,\r\n                aoStrength: this.aoStrength,\r\n                aoRadius: this.aoRadius,\r\n                aoColor: this.aoColor,\r\n                filter: this.filter,\r\n            });\r\n            // 默认显示第一张图信息\r\n            this.onItemClick(0);\r\n        },\r\n        /**\r\n         * 翻译\r\n         * @param key\r\n         */\r\n        t(key) {\r\n            const name = `lightmap.${key}`;\r\n            return Editor.I18n.t(name);\r\n        },\r\n        clickTab(tab, value) {\r\n            this[tab] = value;\r\n            if (tab === 'a') {\r\n                if (value) {\r\n                    this.r = this.g = this.b = false;\r\n                }\r\n            }\r\n            else {\r\n                if (value) {\r\n                    this.a = false;\r\n                }\r\n            }\r\n        },\r\n        changeMode(val) {\r\n            this.mode = val;\r\n        },\r\n        async onClear() {\r\n            const state = await Editor.Message.request('lightmap', 'unstaging');\r\n            this.sceneUUID = await Editor.Message.request('scene', 'query-current-scene');\r\n            const path = state.currPath || await Profile.getLatestLightmapResultDir(this.sceneUUID);\r\n            // 保证路径存在并且没有在烘焙状态下\r\n            if (path && !this.isGenerate) {\r\n                const somethingDeleted = delDir(path);\r\n                await Profile.setLatestLightmapResults(this.sceneUUID, []);\r\n                this.selectInfo = null;\r\n                // 同时清空所有输出\r\n                this.picInfos = [];\r\n                this.logInfos = [];\r\n                if (somethingDeleted) {\r\n                    await Editor.Message.request('scene', 'execute-scene-script', {\r\n                        name: 'lightmap',\r\n                        method: 'clear',\r\n                        args: [],\r\n                    });\r\n                    await Editor.Message.request('lightmap', 'clear');\r\n                    await Editor.Message.request('asset-db', 'refresh-asset', 'db://assets');\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * 取消烘焙\r\n         */\r\n        async onCancel() {\r\n            this.isGenerate = false;\r\n            this.logInfos = [];\r\n            await Editor.Message.request('scene', 'execute-scene-script', {\r\n                name: 'lightmap',\r\n                method: 'cancel',\r\n                args: [],\r\n            });\r\n        },\r\n        /**\r\n         * 烘焙结束事件\r\n         */\r\n        async onBakerEnd() {\r\n            this.isGenerate = false;\r\n            const state = await Editor.Message.request('lightmap', 'unstaging');\r\n            this.picInfos = await readImageList(join(state.currPath, 'output'));\r\n            this.saveEdit();\r\n        },\r\n        /**\r\n         * 添加输出\r\n         */\r\n        pushLog(log) {\r\n            this.logInfos.push(log);\r\n        },\r\n        setLogs(logs) {\r\n            this.logInfos = [];\r\n            for (let i = 0; i < logs.length; i++) {\r\n                this.logInfos.push(logs[i]);\r\n            }\r\n        },\r\n        onItemClick(index) {\r\n            if (!this.picInfos[index]) {\r\n                this.selectInfo = null;\r\n                return;\r\n            }\r\n            this.selectInfo = {};\r\n            for (const key in this.picInfos[index]) {\r\n                if (key !== 'path' && key !== 'uuid') {\r\n                    this.selectInfo[key] = this.picInfos[index][key];\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * 提交烘焙\r\n         */\r\n        async onConfirm() {\r\n            this.r = this.g = this.b = true;\r\n            this.progress = 0;\r\n            this.logInfos = [];\r\n            let lastSelectedPath;\r\n            const latestLightmapResultDir = await Profile.getLatestLightmapResultDir(this.sceneUUID);\r\n            if (latestLightmapResultDir) {\r\n                lastSelectedPath = join(latestLightmapResultDir, '../');\r\n            }\r\n            const selectResult = await Editor.Dialog.select({\r\n                type: 'directory',\r\n                title: this.t('title'),\r\n                path: lastSelectedPath || join(Editor.Project.path, 'assets'),\r\n                multi: false,\r\n                filters: [{ name: 'Lightmap', extensions: ['png'] }],\r\n            });\r\n            let filePath = selectResult.filePaths ? selectResult.filePaths[0] : [];\r\n            if (Array.isArray(filePath)) {\r\n                filePath = filePath[0];\r\n            }\r\n            if (!filePath) {\r\n                return false;\r\n            }\r\n            filePath = `${filePath}/LightFX`;\r\n            this.path = filePath;\r\n            // 延迟生成逻辑，让编辑器先触发窗口焦点导致的db刷新操作，避免meta里的uuid更新，导致prefab渲染异常\r\n            await new Promise(resolve => {\r\n                setTimeout(resolve, 500);\r\n            });\r\n            await Editor.Message.request('lightmap', 'savePicPath', filePath);\r\n            if (fs.existsSync(filePath)) {\r\n                delDir(filePath);\r\n                await Editor.Message.request('asset-db', 'refresh-asset', filePath);\r\n            }\r\n            this.logInfos.push(this.t('start') + '\\n');\r\n            this.isGenerate = true;\r\n            try {\r\n                await Editor.Message.request('scene', 'execute-scene-script', {\r\n                    name: 'lightmap',\r\n                    method: 'apply',\r\n                    args: [this.$data, Editor.App.path],\r\n                });\r\n            }\r\n            catch (error) {\r\n                console.error(error);\r\n                await this.onCancel();\r\n                this.logInfos.push(this.t('fail') + '\\n');\r\n            }\r\n            // lightmap generate按钮点击次数 埋点\r\n            Editor.Metrics.trackEvent({\r\n                sendToNewCocosAnalyticsOnly: true,\r\n                category: 'bakingSystem',\r\n                value: {\r\n                    A100003: 1,\r\n                },\r\n            });\r\n        },\r\n    },\r\n});\r\n/**\r\n *\r\n * @param path\r\n * @param delSelf\r\n * @returns 是否有内容被删除了\r\n */\r\nexport function delDir(path, delSelf = false) {\r\n    let files = [];\r\n    let someThingDeleted = false;\r\n    if (fs.existsSync(path)) {\r\n        files = fs.readdirSync(path);\r\n        files.forEach((file, index) => {\r\n            const curPath = path + '/' + file;\r\n            // 跳过meta文件，避免改变uuid，导致资源的引用出错\r\n            if (file.endsWith('.meta')) {\r\n                return;\r\n            }\r\n            if (fs.statSync(curPath).isDirectory()) {\r\n                // 递归删除文件夹\r\n                const result = delDir(curPath, true);\r\n                someThingDeleted || (someThingDeleted = result);\r\n            }\r\n            else {\r\n                // 删除文件\r\n                fs.unlinkSync(curPath);\r\n                someThingDeleted = true;\r\n            }\r\n        });\r\n    }\r\n    return someThingDeleted;\r\n}\r\n","references":["/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/path/path.js","/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/vue/types/index.d.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/extensions/lightmap/source/profile/index.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/modules/editor-extensions/extensions/lightmap/source/panel/operation/image.ts","/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/chroma-js/chroma.js"]}
