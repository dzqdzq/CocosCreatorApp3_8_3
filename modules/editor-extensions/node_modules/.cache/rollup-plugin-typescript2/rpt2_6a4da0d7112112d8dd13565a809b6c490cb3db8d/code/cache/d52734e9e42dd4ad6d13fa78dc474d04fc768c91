{"code":"'use strict';\r\nconst fs = require('fs'), os = require('os'), net = require('net'), path = require('path'), _async = require('async'), debug = require('debug'), mkdirp = require('mkdirp').mkdirp;\r\nconst debugTestPort = debug('portfinder:testPort'), debugGetPort = debug('portfinder:getPort'), debugDefaultHosts = debug('portfinder:defaultHosts');\r\nconst internals = {};\r\ninternals.testPort = function (options, callback) {\r\n    if (!callback) {\r\n        callback = options;\r\n        options = {};\r\n    }\r\n    options.server =\r\n        options.server ||\r\n            net.createServer(function () {\r\n                //\r\n                // Create an empty listener for the port testing server.\r\n                //\r\n            });\r\n    debugTestPort('entered testPort(): trying', options.host, 'port', options.port);\r\n    function onListen() {\r\n        debugTestPort('done w/ testPort(): OK', options.host, 'port', options.port);\r\n        options.server.removeListener('error', onError);\r\n        options.server.close();\r\n        callback(null, options.port);\r\n    }\r\n    function onError(err) {\r\n        debugTestPort('done w/ testPort(): failed', options.host, 'w/ port', options.port, 'with error', err.code);\r\n        options.server.removeListener('listening', onListen);\r\n        if (!(err.code == 'EADDRINUSE' || err.code == 'EACCES')) {\r\n            return callback(err);\r\n        }\r\n        const port = nextPort(options.port);\r\n        if (port > highestPort) {\r\n            return callback(new Error('No open ports available'));\r\n        }\r\n        internals.testPort({\r\n            port,\r\n            host: options.host,\r\n            server: options.server,\r\n        }, callback);\r\n    }\r\n    options.server.once('error', onError);\r\n    options.server.once('listening', onListen);\r\n    if (options.host) {\r\n        options.server.listen(options.port, options.host);\r\n    }\r\n    else {\r\n        /*\r\n      Judgement of service without host\r\n      example:\r\n        express().listen(options.port)\r\n    */\r\n        options.server.listen(options.port);\r\n    }\r\n};\r\n//\r\n// ### @basePort {Number}\r\n// The lowest port to begin any port search from\r\n//\r\nexport const basePort = 8000;\r\n//\r\n// ### @highestPort {Number}\r\n// Largest port number is an unsigned short 2**16 -1=65335\r\n//\r\nexport const highestPort = 65535;\r\n//\r\n// ### @basePath {string}\r\n// Default path to begin any socket search from\r\n//\r\nexport const basePath = '/tmp/portfinder';\r\n//\r\n// ### function getPort (options, callback)\r\n// #### @options {Object} Settings to use when finding the necessary port\r\n// #### @callback {function} Continuation to respond to when complete.\r\n// Responds with a unbound port on the current machine.\r\n//\r\nexport function getPort(options, callback) {\r\n    if (!callback) {\r\n        callback = options;\r\n        options = {};\r\n    }\r\n    options.port = Number(options.port) || Number(basePort);\r\n    options.host = options.host || null;\r\n    options.stopPort = Number(options.stopPort) || Number(highestPort);\r\n    if (!options.startPort) {\r\n        options.startPort = Number(options.port);\r\n        if (options.startPort < 0) {\r\n            throw Error('Provided options.startPort(' + options.startPort + ') is less than 0, which are cannot be bound.');\r\n        }\r\n        if (options.stopPort < options.startPort) {\r\n            throw Error('Provided options.stopPort(' + options.stopPort + 'is less than options.startPort (' + options.startPort + ')');\r\n        }\r\n    }\r\n    if (options.host) {\r\n        let hasUserGivenHost;\r\n        for (let i = 0; i < _defaultHosts.length; i++) {\r\n            if (_defaultHosts[i] === options.host) {\r\n                hasUserGivenHost = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!hasUserGivenHost) {\r\n            _defaultHosts.push(options.host);\r\n        }\r\n    }\r\n    const openPorts = [];\r\n    let currentHost;\r\n    return _async.eachSeries(_defaultHosts, function (host, next) {\r\n        debugGetPort('in eachSeries() iteration callback: host is', host);\r\n        return internals.testPort({ host: host, port: options.port }, function (err, port) {\r\n            if (err) {\r\n                debugGetPort('in eachSeries() iteration callback testPort() callback', 'with an err:', err.code);\r\n                currentHost = host;\r\n                return next(err);\r\n            }\r\n            else {\r\n                debugGetPort('in eachSeries() iteration callback testPort() callback', 'with a success for port', port);\r\n                openPorts.push(port);\r\n                return next();\r\n            }\r\n        });\r\n    }, function (err) {\r\n        if (err) {\r\n            debugGetPort('in eachSeries() result callback: err is', err);\r\n            // If we get EADDRNOTAVAIL it means the host is not bindable, so remove it\r\n            // from exports._defaultHosts and start over. For ubuntu, we use EINVAL for the same\r\n            if (err.code === 'EADDRNOTAVAIL' || err.code === 'EINVAL') {\r\n                if (options.host === currentHost) {\r\n                    // if bad address matches host given by user, tell them\r\n                    // NOTE: We may need to one day handle `my-non-existent-host.local` if users\r\n                    // report frustration with passing in hostnames that DONT map to bindable\r\n                    // hosts, without showing them a good error.\r\n                    const msg = 'Provided host ' + options.host + ' could NOT be bound. Please provide a different host address or hostname';\r\n                    return callback(Error(msg));\r\n                }\r\n                else {\r\n                    const idx = _defaultHosts.indexOf(currentHost);\r\n                    _defaultHosts.splice(idx, 1);\r\n                    return getPort(options, callback);\r\n                }\r\n            }\r\n            else {\r\n                // error is not accounted for, file ticket, handle special case\r\n                return callback(err);\r\n            }\r\n        }\r\n        // sort so we can compare first host to last host\r\n        openPorts.sort(function (a, b) {\r\n            return a - b;\r\n        });\r\n        debugGetPort('in eachSeries() result callback: openPorts is', openPorts);\r\n        if (openPorts[0] === openPorts[openPorts.length - 1]) {\r\n            // if first === last, we found an open port\r\n            if (openPorts[0] <= options.stopPort) {\r\n                return callback(null, openPorts[0]);\r\n            }\r\n            else {\r\n                const msg = 'No open ports found in between ' + options.startPort + ' and ' + options.stopPort;\r\n                return callback(Error(msg));\r\n            }\r\n        }\r\n        else {\r\n            // otherwise, try again, using sorted port, aka, highest open for >= 1 host\r\n            return getPort({ port: openPorts.pop(), host: options.host, startPort: options.startPort, stopPort: options.stopPort }, callback);\r\n        }\r\n    });\r\n}\r\n//\r\n// ### function getPortPromise (options)\r\n// #### @options {Object} Settings to use when finding the necessary port\r\n// Responds a promise to an unbound port on the current machine.\r\n//\r\nexport function getPortPromise(options) {\r\n    if (typeof Promise !== 'function') {\r\n        throw Error('Native promise support is not available in this version of node.' +\r\n            'Please install a polyfill and assign Promise to global.Promise before calling this method');\r\n    }\r\n    if (!options) {\r\n        options = {};\r\n    }\r\n    return new Promise(function (resolve, reject) {\r\n        getPort(options, function (err, port) {\r\n            if (err) {\r\n                return reject(err);\r\n            }\r\n            resolve(port);\r\n        });\r\n    });\r\n}\r\n//\r\n// ### function getPorts (count, options, callback)\r\n// #### @count {Number} The number of ports to find\r\n// #### @options {Object} Settings to use when finding the necessary port\r\n// #### @callback {function} Continuation to respond to when complete.\r\n// Responds with an array of unbound ports on the current machine.\r\n//\r\nexport function getPorts(count, options, callback) {\r\n    if (!callback) {\r\n        callback = options;\r\n        options = {};\r\n    }\r\n    let lastPort = null;\r\n    _async.timesSeries(count, function (index, asyncCallback) {\r\n        if (lastPort) {\r\n            options.port = nextPort(lastPort);\r\n        }\r\n        getPort(options, function (err, port) {\r\n            if (err) {\r\n                asyncCallback(err);\r\n            }\r\n            else {\r\n                lastPort = port;\r\n                asyncCallback(null, port);\r\n            }\r\n        });\r\n    }, callback);\r\n}\r\n//\r\n// ### function getSocket (options, callback)\r\n// #### @options {Object} Settings to use when finding the necessary port\r\n// #### @callback {function} Continuation to respond to when complete.\r\n// Responds with a unbound socket using the specified directory and base\r\n// name on the current machine.\r\n//\r\nexport function getSocket(options, callback) {\r\n    if (!callback) {\r\n        callback = options;\r\n        options = {};\r\n    }\r\n    options.mod = options.mod || parseInt('755', 8);\r\n    options.path = options.path || basePath + '.sock';\r\n    //\r\n    // Tests the specified socket\r\n    //\r\n    function testSocket() {\r\n        fs.stat(options.path, function (err) {\r\n            //\r\n            // If file we're checking doesn't exist (thus, stating it emits ENOENT),\r\n            // we should be OK with listening on this socket.\r\n            //\r\n            if (err) {\r\n                if (err.code == 'ENOENT') {\r\n                    callback(null, options.path);\r\n                }\r\n                else {\r\n                    callback(err);\r\n                }\r\n            }\r\n            else {\r\n                //\r\n                // This file exists, so it isn't possible to listen on it. Lets try\r\n                // next socket.\r\n                //\r\n                options.path = nextSocket(options.path);\r\n                getSocket(options, callback);\r\n            }\r\n        });\r\n    }\r\n    //\r\n    // Create the target `dir` then test connection\r\n    // against the socket.\r\n    //\r\n    function createAndTestSocket(dir) {\r\n        mkdirp(dir, options.mod, function (err) {\r\n            if (err) {\r\n                return callback(err);\r\n            }\r\n            options.exists = true;\r\n            testSocket();\r\n        });\r\n    }\r\n    //\r\n    // Check if the parent directory of the target\r\n    // socket path exists. If it does, test connection\r\n    // against the socket. Otherwise, create the directory\r\n    // then test connection.\r\n    //\r\n    function checkAndTestSocket() {\r\n        const dir = path.dirname(options.path);\r\n        fs.stat(dir, function (err, stats) {\r\n            if (err || !stats.isDirectory()) {\r\n                return createAndTestSocket(dir);\r\n            }\r\n            options.exists = true;\r\n            testSocket();\r\n        });\r\n    }\r\n    //\r\n    // If it has been explicitly stated that the\r\n    // target `options.path` already exists, then\r\n    // simply test the socket.\r\n    //\r\n    return options.exists ? testSocket() : checkAndTestSocket();\r\n}\r\n//\r\n// ### function nextPort (port)\r\n// #### @port {Number} Port to increment from.\r\n// Gets the next port in sequence from the\r\n// specified `port`.\r\n//\r\nexport function nextPort(port) {\r\n    return port + 1;\r\n}\r\n//\r\n// ### function nextSocket (socketPath)\r\n// #### @socketPath {string} Path to increment from\r\n// Gets the next socket path in sequence from the\r\n// specified `socketPath`.\r\n//\r\nexport function nextSocket(socketPath) {\r\n    const dir = path.dirname(socketPath);\r\n    const name = path.basename(socketPath, '.sock');\r\n    const match = name.match(/^([a-zA-z]+)(\\d*)$/i);\r\n    let index = parseInt(match[2]);\r\n    const base = match[1];\r\n    if (isNaN(index)) {\r\n        index = 0;\r\n    }\r\n    index += 1;\r\n    return path.join(dir, base + index + '.sock');\r\n}\r\n/**\r\n * @desc List of internal hostnames provided by your machine. A user\r\n *       provided hostname may also be provided when calling portfinder.getPort,\r\n *       which would then be added to the default hosts we lookup and return here.\r\n *\r\n * @return {array}\r\n *\r\n * Long Form Explantion:\r\n *\r\n *    - Input: (os.networkInterfaces() w/ MacOS 10.11.5+ and running a VM)\r\n *\r\n *        { lo0:\r\n *         [ { address: '::1',\r\n *             netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',\r\n *             family: 'IPv6',\r\n *             mac: '00:00:00:00:00:00',\r\n *             scopeid: 0,\r\n *             internal: true },\r\n *           { address: '127.0.0.1',\r\n *             netmask: '255.0.0.0',\r\n *             family: 'IPv4',\r\n *             mac: '00:00:00:00:00:00',\r\n *             internal: true },\r\n *           { address: 'fe80::1',\r\n *             netmask: 'ffff:ffff:ffff:ffff::',\r\n *             family: 'IPv6',\r\n *             mac: '00:00:00:00:00:00',\r\n *             scopeid: 1,\r\n *             internal: true } ],\r\n *        en0:\r\n *         [ { address: 'fe80::a299:9bff:fe17:766d',\r\n *             netmask: 'ffff:ffff:ffff:ffff::',\r\n *             family: 'IPv6',\r\n *             mac: 'a0:99:9b:17:76:6d',\r\n *             scopeid: 4,\r\n *             internal: false },\r\n *           { address: '10.0.1.22',\r\n *             netmask: '255.255.255.0',\r\n *             family: 'IPv4',\r\n *             mac: 'a0:99:9b:17:76:6d',\r\n *             internal: false } ],\r\n *        awdl0:\r\n *         [ { address: 'fe80::48a8:37ff:fe34:aaef',\r\n *             netmask: 'ffff:ffff:ffff:ffff::',\r\n *             family: 'IPv6',\r\n *             mac: '4a:a8:37:34:aa:ef',\r\n *             scopeid: 8,\r\n *             internal: false } ],\r\n *        vnic0:\r\n *         [ { address: '10.211.55.2',\r\n *             netmask: '255.255.255.0',\r\n *             family: 'IPv4',\r\n *             mac: '00:1c:42:00:00:08',\r\n *             internal: false } ],\r\n *        vnic1:\r\n *         [ { address: '10.37.129.2',\r\n *             netmask: '255.255.255.0',\r\n *             family: 'IPv4',\r\n *             mac: '00:1c:42:00:00:09',\r\n *             internal: false } ] }\r\n *\r\n *    - Output:\r\n *\r\n *         [\r\n *          '0.0.0.0',\r\n *          '::1',\r\n *          '127.0.0.1',\r\n *          'fe80::1',\r\n *          '10.0.1.22',\r\n *          'fe80::48a8:37ff:fe34:aaef',\r\n *          '10.211.55.2',\r\n *          '10.37.129.2'\r\n *         ]\r\n *\r\n *     Note we export this so we can use it in our tests, otherwise this API is private\r\n */\r\nexport const _defaultHosts = (function () {\r\n    let interfaces = {};\r\n    try {\r\n        interfaces = os.networkInterfaces();\r\n    }\r\n    catch (e) {\r\n        // As of October 2016, Windows Subsystem for Linux (WSL) does not support\r\n        // the os.networkInterfaces() call and throws instead. For this platform,\r\n        // assume 0.0.0.0 as the only address\r\n        //\r\n        // - https://github.com/Microsoft/BashOnWindows/issues/468\r\n        //\r\n        // - Workaround is a mix of good work from the community:\r\n        //   - https://github.com/http-party/node-portfinder/commit/8d7e30a648ff5034186551fa8a6652669dec2f2f\r\n        //   - https://github.com/yarnpkg/yarn/pull/772/files\r\n        // @ts-ignore\r\n        if (e && e.syscall === 'uv_interface_addresses') {\r\n            // swallow error because we're just going to use defaults\r\n            // documented @ https://github.com/nodejs/node/blob/4b65a65e75f48ff447cabd5500ce115fb5ad4c57/doc/api/net.md#L231\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    const interfaceNames = Object.keys(interfaces), hiddenButImportantHost = '0.0.0.0', // !important - dont remove, hence the naming :)\r\n    results = [hiddenButImportantHost];\r\n    for (let i = 0; i < interfaceNames.length; i++) {\r\n        const _interface = interfaces[interfaceNames[i]];\r\n        for (let j = 0; j < _interface.length; j++) {\r\n            const curr = _interface[j];\r\n            results.push(curr.address);\r\n        }\r\n    }\r\n    // add null value, For createServer function, do not use host.\r\n    results.push(null);\r\n    debugDefaultHosts('exports._defaultHosts is: %o', results);\r\n    return results;\r\n})();\r\n","references":["/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/path/path.js","/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/async/dist/async.js","/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/debug/src/index.js","/Users/mac/Documents/editor_3d/v3.8.3/app/node_modules/mkdirp/index.js"]}
