const ENCODER = require('./meshopt_encoder.wasm.js');

const encoder = {
    api: {},
    exports: {},
    inited: false,
};

const init = async () => {
    if (encoder.inited) {
        return Promise.resolve();
    } else {
        return ENCODER().then((module) => {
            encoder.exports = module;
            const exports = encoder.exports;
            Object.assign(encoder.api, {
                malloc: exports.cwrap('malloc', 'number', ['number']),
                free: exports.cwrap('free', 'null', ['number']),
                // optimize
                meshopt_optimizeVertexCache: exports.cwrap('meshopt_optimizeVertexCache', 'null', ['number', 'number', 'number', 'number']),
                meshopt_optimizeVertexFetch: exports.cwrap('meshopt_optimizeVertexFetch', 'null', ['number', 'number', 'number', 'number', 'number', 'number']),
                meshopt_optimizeOverDraw: exports.cwrap('meshopt_optimizeOverdraw', 'null', ['number', 'number', 'number', 'number', 'number', 'number', 'number']),
                meshopt_optimizeVertexFetchRemap: exports.cwrap('meshopt_optimizeVertexFetchRemap', 'number', ['number', 'number', 'number', 'number']),
                meshopt_remapIndexBuffer: exports.cwrap('meshopt_remapIndexBuffer', 'null', ['number', 'number', 'number', 'number']),
                meshopt_remapVertexBuffer: exports.cwrap('meshopt_remapVertexBuffer', 'null', ['number', 'number', 'number', 'number', 'number']),
                // encode
                meshopt_encodeIndexBufferBound: exports.cwrap('meshopt_encodeIndexBufferBound', 'number', ['number', 'number']),
                meshopt_encodeIndexBuffer: exports.cwrap('meshopt_encodeIndexBuffer', 'number', ['number', 'number', 'number', 'number']),
                meshopt_encodeVertexBufferBound: exports.cwrap('meshopt_encodeVertexBufferBound', 'number', ['number', 'number']),
                meshopt_encodeVertexBuffer: exports.cwrap('meshopt_encodeVertexBuffer', 'number', ['number', 'number', 'number', 'number', 'number']),
                // no decodes
                // simplify
                meshopt_simplify: exports.cwrap('meshopt_simplify', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']),
                meshopt_simplifyWithAttributes: exports.cwrap('meshopt_simplifyWithAttributes', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']),
                meshopt_simplifySloppy: exports.cwrap('meshopt_simplifySloppy', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']),
                meshopt_simplifyPoints: exports.cwrap('meshopt_simplifyPoints', 'number', ['number', 'number', 'number', 'number', 'number']),
                // meshlet
                meshopt_buildMeshletsBound: exports.cwrap('meshopt_buildMeshletsBound', 'number', ['number', 'number', 'number']),
                meshopt_buildMeshletsScan: exports.cwrap('meshopt_buildMeshletsScan', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']),
                meshopt_buildMeshlets: exports.cwrap('meshopt_buildMeshlets', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']),
                meshopt_computeMeshletBounds: exports.cwrap('meshopt_computeMeshletBounds', 'number', ['number', 'number', 'number', 'number', 'number', 'number']),
                meshopt_quantizeMesh: exports.cwrap('meshopt_quantizeMesh', 'null', ['number', 'number', 'number', 'number', 'number', 'number', 'number']),
            });
        });
    }
};

function bytes(view) {
    return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
}

function createHeapArray(buffer) {
    const malloc = encoder.api.malloc;
    const dataPtr = malloc(buffer.byteLength);
    updateMemoryViews();
    const heap = encoder.exports.HEAPU8;
    const dataHeap = new Uint8Array(heap.buffer, dataPtr, buffer.byteLength);
    dataHeap.set(bytes(buffer));
    return { heap: dataHeap, byteOffset: dataPtr, byteLength: buffer.byteLength };
}

function updateMemoryViews() {
    const b = encoder.exports.asm.memory.buffer;
    encoder.exports.HEAP8 = new Int8Array(b);
    encoder.exports.HEAP16 = new Int16Array(b);
    encoder.exports.HEAP32 = new Int32Array(b);
    encoder.exports.HEAPU8 = new Uint8Array(b);
    encoder.exports.HEAPU16 = new Uint16Array(b);
    encoder.exports.HEAPU32 = new Uint32Array(b);
    encoder.exports.HEAPF32 = new Float32Array(b);
    encoder.exports.HEAPF64 = new Float64Array(b);
}

function renewHeapArray(heapArray) {
    const heap = encoder.exports.HEAPU8;
    const dataHeap = new Uint8Array(heap.buffer, heapArray.byteOffset, heapArray.byteLength);
    heapArray.heap = dataHeap;
    return heapArray;
}

function allocHeapArrayBuffer(byteLength) {
    const malloc = encoder.api.malloc;
    const dataPtr = malloc(byteLength);
    updateMemoryViews();
    const heap = encoder.exports.HEAPU8;
    const dataHeap = new Uint8Array(heap.buffer, dataPtr, byteLength);
    return { heap: dataHeap, byteOffset: dataPtr, byteLength };
}

function freeHeapArrayBuffer(heapArray) {
    encoder.api.free(heapArray.byteOffset);
}

function syncHeapArrayBuffer(buffer, heapArray) {
    updateMemoryViews();
    renewHeapArray(heapArray);
    const source = new Uint8Array(heapArray.heap.buffer, heapArray.byteOffset, buffer.byteLength);
    bytes(buffer).set(source);
}

function optimizeVertexCache(destBuffer, indexBuffer, indexCount, vertexCount) {
    const { meshopt_optimizeVertexCache } = encoder.api;
    let indexHeap = createHeapArray(indexBuffer);

    meshopt_optimizeVertexCache(indexHeap.byteOffset, indexHeap.byteOffset, indexCount, vertexCount);
    // TODO fix bugs, according to https://github.com/emscripten-core/emscripten/issues/6747#issuecomment-400265822

    syncHeapArrayBuffer(destBuffer, indexHeap);

    freeHeapArrayBuffer(indexHeap);
}

function optimizeVertexFetch(destBuffer, indexBuffer, indexCount, vertexBuffer, vertexCount, vertexSize) {
    const { meshopt_optimizeVertexFetch } = encoder.api;

    let indexHeap = createHeapArray(indexBuffer);
    let vertexHeap = createHeapArray(vertexBuffer);

    const result = meshopt_optimizeVertexFetch(vertexHeap.byteOffset, indexHeap.byteOffset, indexCount, vertexHeap.byteOffset, vertexCount, vertexSize);

    syncHeapArrayBuffer(destBuffer, vertexHeap);
    syncHeapArrayBuffer(indexBuffer, indexHeap);

    freeHeapArrayBuffer(vertexHeap);
    freeHeapArrayBuffer(indexHeap);

    return result;
}

function optimizeOverdraw(destBuffer, indexBuffer, indexCount, vertexBuffer, vertexCount, vertexSize, threshold) {
    const { meshopt_optimizeOverDraw } = encoder.api;

    let indexHeap = createHeapArray(indexBuffer);
    let vertexHeap = createHeapArray(vertexBuffer);

    meshopt_optimizeOverDraw(indexHeap.byteOffset, indexHeap.byteOffset, indexCount, vertexHeap.byteOffset, vertexCount, vertexSize, threshold);

    syncHeapArrayBuffer(destBuffer, indexHeap);

    freeHeapArrayBuffer(vertexHeap);
    freeHeapArrayBuffer(indexHeap);

    return destBuffer;
}

function encodeIndexBufferBound(index_count, vertex_count) {
    const { meshopt_encodeIndexBufferBound } = encoder.api;
    return meshopt_encodeIndexBufferBound(index_count, vertex_count);
}

function encodeIndexBuffer(destBuffer, bufferSize, indexBuffer, index_count) {
    const { meshopt_encodeIndexBuffer } = encoder.api;

    const indexHeap = createHeapArray(indexBuffer);
    let destHeap = createHeapArray(destBuffer);

    const result = meshopt_encodeIndexBuffer(destHeap.byteOffset, bufferSize, indexHeap.byteOffset, index_count);

    syncHeapArrayBuffer(destBuffer, destHeap);

    freeHeapArrayBuffer(destHeap);
    freeHeapArrayBuffer(indexHeap);

    return result;
}

function encodeVertexBufferBound(vertexCount, vertexSize) {
    const { meshopt_encodeVertexBufferBound } = encoder.api;
    return meshopt_encodeVertexBufferBound(vertexCount, vertexSize);
}

function encodeVertexBuffer(destBuffer, bufferSize, vertexBuffer, vertexCount, vertexSize) {
    const { meshopt_encodeVertexBuffer } = encoder.api;

    const vertexHeap = createHeapArray(vertexBuffer);
    let destHeap = createHeapArray(destBuffer);

    const result = meshopt_encodeVertexBuffer(destHeap.byteOffset, bufferSize, vertexHeap.byteOffset, vertexCount, vertexSize);

    syncHeapArrayBuffer(destBuffer, destHeap);

    freeHeapArrayBuffer(destHeap);
    freeHeapArrayBuffer(vertexHeap);

    return result;
}

function simplify(destBuffer, indexBuffer, indexCount, vertexBuffer, vertexCount, vertexSize, targetIndexCount, targetError, options, result_error) {
    const { meshopt_simplify } = encoder.api;

    const indexHeap = createHeapArray(indexBuffer);
    const vertexHeap = createHeapArray(vertexBuffer);
    let destHeap = createHeapArray(destBuffer);

    const result = meshopt_simplify(destHeap.byteOffset, indexHeap.byteOffset, indexCount, vertexHeap.byteOffset, vertexCount, vertexSize, targetIndexCount, targetError, options, result_error);

    syncHeapArrayBuffer(destBuffer, destHeap);

    freeHeapArrayBuffer(destHeap);
    freeHeapArrayBuffer(vertexHeap);
    freeHeapArrayBuffer(indexHeap);

    return result;
}

function simplifyWithAttributes() { }

function simplifySloppy() { }

// can be used for physics convex mesh collider
function simplifyPoints(destBuffer, vertexBuffer, vertexCount, vertexSize, targetCount) {
    const { meshopt_simplifyPoints } = encoder.api;
    const vertexHeap = createHeapArray(vertexBuffer);
    let destHeap = createHeapArray(destBuffer);

    const result = meshopt_simplifyPoints(destHeap.byteOffset, vertexHeap.byteOffset, vertexCount, vertexSize, targetCount);

    syncHeapArrayBuffer(destBuffer, destHeap);

    freeHeapArrayBuffer(destHeap);
    freeHeapArrayBuffer(vertexHeap);

    return result;
}

function buildMeshLetsBound(index_count, max_vertices, max_triangles) {
    const { meshopt_buildMeshletsBound } = encoder.api;
    return meshopt_buildMeshletsBound(index_count, max_vertices, max_triangles);
}

function buildMeshLetsScan(meshlets, meshlet_vertices, meshlet_triangles, indices,
    index_count, vertex_count, max_vertices, max_triangles) {
    const { meshopt_buildMeshletsScan } = encoder.api;

    let meshletHeap = createHeapArray(meshlets);
    let meshletVerticesHeap = createHeapArray(meshlet_vertices);
    let meshletTriangleHeap = createHeapArray(meshlet_triangles);

    const indexHeap = createHeapArray(indices);

    const result = meshopt_buildMeshletsScan(
        meshletHeap.byteOffset,
        meshletVerticesHeap.byteOffset,
        meshletTriangleHeap.byteOffset,
        indexHeap.byteOffset, index_count,
        vertex_count,
        max_vertices,
        max_triangles);

    syncHeapArrayBuffer(meshlets, meshletHeap);
    syncHeapArrayBuffer(meshlet_vertices, meshletVerticesHeap);
    syncHeapArrayBuffer(meshlet_triangles, meshletTriangleHeap);

    freeHeapArrayBuffer(meshletHeap);
    freeHeapArrayBuffer(meshletVerticesHeap);
    freeHeapArrayBuffer(meshletTriangleHeap);
    freeHeapArrayBuffer(indexHeap);

    return result;
}

function buildMeshLets(meshlets, meshlet_vertices, meshlet_triangles, indices,
    index_count, vertex_positions, vertex_count, vertex_positions_stride, max_vertices,
    max_triangles, cone_weight) {
    const { meshopt_buildMeshlets } = encoder.api;

    let meshletHeap = createHeapArray(meshlets);
    let meshletVerticesHeap = createHeapArray(meshlet_vertices);
    let meshletTriangleHeap = createHeapArray(meshlet_triangles);

    const indexHeap = createHeapArray(indices);
    const vertexHeap = createHeapArray(vertex_positions);

    const result = meshopt_buildMeshlets(
        meshletHeap.byteOffset,
        meshletVerticesHeap.byteOffset,
        meshletTriangleHeap.byteOffset,
        indexHeap.byteOffset, index_count,
        vertexHeap.byteOffset, vertex_count,
        vertex_positions_stride,
        max_vertices,
        max_triangles,
        cone_weight);

    syncHeapArrayBuffer(meshlets, meshletHeap);
    syncHeapArrayBuffer(meshlet_vertices, meshletVerticesHeap);
    syncHeapArrayBuffer(meshlet_triangles, meshletTriangleHeap);

    freeHeapArrayBuffer(meshletHeap);
    freeHeapArrayBuffer(meshletVerticesHeap);
    freeHeapArrayBuffer(meshletTriangleHeap);
    freeHeapArrayBuffer(vertexHeap);
    freeHeapArrayBuffer(indexHeap);

    return result;
}

function computeMeshLetsBound(meshlet_vertices, meshlet_indices, index_count, vertex_positions, vertex_count, vertex_positions_stride) {
    const { meshopt_computeMeshletBounds } = encoder.api;

    const meshlet_triangles_heap = createHeapArray(meshlet_indices);
    const meshlet_vertices_heap = createHeapArray(meshlet_vertices);
    const vertices_positions_heap = createHeapArray(vertex_positions);

    const bounds = meshopt_computeMeshletBounds(meshlet_vertices_heap.byteOffset, meshlet_triangles_heap.byteOffset, index_count, vertices_positions_heap.byteOffset, vertex_count, vertex_positions_stride);

    freeHeapArrayBuffer(meshlet_vertices_heap);
    freeHeapArrayBuffer(meshlet_triangles_heap);
    freeHeapArrayBuffer(vertices_positions_heap);

    return bounds;
}

function quantizeMesh(destBuffer, destSize, vertexBuffer, vertexCount, vertexSize, attributes, attributeCount) {
    const { meshopt_quantizeMesh } = encoder.api;

    const vertexHeap = createHeapArray(vertexBuffer);
    const attributeHeap = createHeapArray(attributes);
    let destHeap = createHeapArray(destBuffer);

    meshopt_quantizeMesh(destHeap.byteOffset, destSize, vertexHeap.byteOffset, vertexCount, vertexSize, attributeHeap.byteOffset, attributeCount);

    syncHeapArrayBuffer(destBuffer, destHeap);

    freeHeapArrayBuffer(destHeap);
    freeHeapArrayBuffer(vertexHeap);
    freeHeapArrayBuffer(attributeHeap);
}

function optimizeVertexFetchRemap(destBuffer, indexBuffer, indexCount, vertexCount) {
    const { meshopt_optimizeVertexFetchRemap } = encoder.api;

    const indexHeap = createHeapArray(indexBuffer);
    let destHeap = createHeapArray(destBuffer);

    const result = meshopt_optimizeVertexFetchRemap(destHeap.byteOffset, indexHeap.byteOffset, indexCount, vertexCount);

    syncHeapArrayBuffer(destBuffer, destHeap);

    freeHeapArrayBuffer(destHeap);
    freeHeapArrayBuffer(indexHeap);

    return result;
}

function optimizeRemapIndex(destBuffer, indexBuffer, indexCount, remap) {
    const { meshopt_remapIndexBuffer } = encoder.api;

    const indexHeap = createHeapArray(indexBuffer);
    let destHeap = createHeapArray(destBuffer);
    const remapHeap = createHeapArray(remap);

    meshopt_remapIndexBuffer(destHeap.byteOffset, indexHeap.byteOffset, indexCount, remapHeap.byteOffset);

    syncHeapArrayBuffer(destBuffer, destHeap);

    freeHeapArrayBuffer(destHeap);
    freeHeapArrayBuffer(indexHeap);
    freeHeapArrayBuffer(remapHeap);
}

function optimizeRemapVertex(destBuffer, vertexBuffer, vertexCount, vertexSize, remap) {
    const { meshopt_remapVertexBuffer } = encoder.api;

    const vertexHeap = createHeapArray(vertexBuffer);
    const remapHeap = createHeapArray(remap);
    let destHeap = createHeapArray(destBuffer);

    meshopt_remapVertexBuffer(destHeap.byteOffset, vertexHeap.byteOffset, vertexCount, vertexSize, remapHeap.byteOffset);

    syncHeapArrayBuffer(destBuffer, destHeap);

    freeHeapArrayBuffer(destHeap);
    freeHeapArrayBuffer(vertexHeap);
    freeHeapArrayBuffer(remapHeap);
}

module.exports = {
    init,
    utils: {
        createHeapArray,
        allocHeapArrayBuffer,
        freeHeapArrayBuffer,
        bytes,
    },
    optimizer: {
        optimizeVertexCache,
        optimizeVertexFetch,
        optimizeOverdraw,
        optimizeVertexFetchRemap,
        optimizeRemapIndex,
        optimizeRemapVertex,
        encodeIndexBufferBound,
        encodeIndexBuffer,
        encodeVertexBufferBound,
        encodeVertexBuffer,
        simplify,
        simplifyWithAttributes,
        simplifySloppy,
        simplifyPoints,
        buildMeshLetsBound,
        buildMeshLetsScan,
        buildMeshLets,
        computeMeshLetsBound,
        quantizeMesh,
    },
};