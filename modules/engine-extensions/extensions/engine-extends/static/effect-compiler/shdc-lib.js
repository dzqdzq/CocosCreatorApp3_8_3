"use strict";const tokenizer=require("glsl-tokenizer/string"),parser=require("glsl-parser/direct"),mappings=require("./offline-mappings"),yaml=require("js-yaml"),tabAsSpaces=2,plainDefineRE=/#define\s+(\w+)\s+(\w+)/g,effectDefineRE=/#pragma\s+define\s+(\w+)\s+(.*)\n/g,ident=/[_a-zA-Z]\w*/g,labelRE=/(\w+)\((.*?)\)/,locationRE=/location\s*=\s*(\d+)/,inDecl=/(?:layout\s*\((.*?)\)\s*)?in ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,outDecl=/(?:layout\s*\((.*?)\)\s*)?(?<=\b)out ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,layoutExtract=/layout\s*\((.*?)\)(\s*)$/,bindingExtract=/(?:location|binding)\s*=\s*(\d+)/,builtinRE=/^cc\w+$/i,pragmasToStrip=/^\s*(?:#pragma\s*)(?!STDGL|optimize|debug).*$\n/gm,textureFuncRemap=new Map([["ExternalOES","2D"]]);let effectName="",shaderName="",shaderTokens=[];const formatMsg=(e,t)=>effectName+".effect - "+shaderName+(void 0!==t?` - ${t}: `:": ")+e,options={throwOnError:!0,throwOnWarning:!1,noSource:!1,skipParserTest:!1,chunkSearchFn:e=>({}),getAlternativeChunkPaths:e=>[]},dumpSource=e=>{let r=0;return e.reduce((e,t)=>t.line>r?e+(`
${r=t.line}	`+t.data.replace(/\n/g,"")):e+t.data,"")},throwFnFactory=(s,n)=>(e,t)=>{var r=void 0!==(t=options.noSource?void 0:t)?" ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓"+dumpSource(shaderTokens)+"\n":"",e=formatMsg(s+" "+e,t)+r;if(options.throwOnWarning)throw e;n(e)},warn=throwFnFactory("Warning",console.warn),error=throwFnFactory("Error",console.error),convertType=e=>{var t=mappings.typeMap[e];return void 0===t?e:t},VSBit=mappings.getShaderStage("vertex"),FSBit=mappings.getShaderStage("fragment"),CSBit=mappings.getShaderStage("compute"),mapShaderStage=e=>{switch(e){case"vert":return VSBit;case"frag":return FSBit;case"compute":return CSBit;default:return 0}},stripComments=(()=>{const r=/\r\n/g,s=/\/\*.*?\*\//gs,n=/\s*\/\/.*$/gm;return e=>{let t=e.replace(s,"");return t=(t=t.replace(n,"")).replace(r,"\n")}})(),globalChunks={},globalDeprecations={chunks:{},identifiers:{}},addChunk=(()=>{const c=/#pragma\s+deprecate-(chunk|identifier)\s+([\w-]+)(?:\s+(.*))?/g;return(e,t,r=globalChunks,s=globalDeprecations)=>{var n=stripComments(t);let a=c.exec(n),i="",o=0;for(;a;){var l=a[1]+"s";s[l]||(s[l]={}),s[l][a[2]]=a[3],i+=n.slice(o,a.index),o=a.index+a[0].length,a=c.exec(n)}r[e]=i+n.slice(o)}})(),invokeSearch=e=>{var{name:e,content:t}=options.chunkSearchFn(e);return void 0!==t?(addChunk(e,t),e):""},unwindIncludes=(()=>{const p=/^(.*)#include\s+[<"]([^>"]+)[>"](.*)$/gm;let d;return(t,e,r,s=new Set)=>{var o,l,c;if(d=(o=e,l=r.chunks,c=s,(e,t,r,s)=>{var n=r=(r=r.trim()).endsWith(".chunk")?r.slice(0,-6):r;if(c.has(r))return"";void 0!==l[r]&&error(`EFX2003: header '${r}' is deprecated: `+l[r]);let a=void 0;do{if(void 0!==(a=o[r]))break;var i=options.getAlternativeChunkPaths(r);if(i.some(e=>void 0!==o[e]&&(r=e,a=o[e],!0)))break;if(r=invokeSearch([].concat(r,i)),void 0!==(a=globalChunks[r]))break;return error(`EFX2001: can not resolve '${n}'`),""}while(0);return c.add(r),t&&(a=a.replace(/^/gm,t)),a=(a=s?a.replace(/\n/g,s+"\n")+s:a).replace(p,d)}),t=t.replace(p,d),r.identifierRE){let e=r.identifierRE.exec(t);for(;e;){var n=r.identifiers[e[1]];n&&error(`EFX2004: identifier '${e[1]}' is deprecated: `+n),e=r.identifierRE.exec(t)}}return t}})(),expandFunctionalMacro=(()=>{const y=(e,t)=>{if("("!==e[t])return t;let r=1,s=t+1;for(;s<e.length&&("("===e[s]&&r++,")"===e[s]&&r--,0!==r);s++);return s},x=t=>{var r=[];let s=0;for(let e=0;e<t.length;e++)","===t[e="("===t[e]?y(t,e)+1:e]&&(r.push(t.substring(s,e).trim()),s=e+1);return s===t.length&&","!==t[t.length-1]||r.push(t.substring(s).trim()),r},r=/#pragma\s+define\s+(\w+)\(([\w,\s]*)\)\s+(.*?)\n/g,v=/(?<=\w)##(?=\w)/g,E=/\\\s*?\n/g,_=/@@/g,$=/#pragma\s+define|#define/;return s=>{s=s.replace(E,"@@");let e=r.exec(s);for(;null!==e;){var n=e[1],a=x(e[2]),i=e[3],t=e.index,o=e.index+e[0].length,l=new RegExp("^(.*?)"+n+"\\s*\\(","gm");if(new RegExp("\\b"+n+"\\b").test(i))warn(`EFX2002: recursive macro processor '${n}'`);else for(let r=l.exec(s);null!==r;r=l.exec(s)){var c=r.index+r[0].length-1;if(!(t<c&&c<o)){var p=r[1],d=r.index+p.length,c=y(s,c)+1,f=x(s.slice(r.index+r[0].length,c-1)),u=(f.length!==a.length&&warn(`EFX2005: not enough arguments for function-like macro invocation '${n}'`),[]);for(let e=0;e<a.length;e++)for(var m,g=new RegExp("\\b"+a[e]+"\\b","g");null!==(m=g.exec(i));)u.push({beg:m.index,end:g.lastIndex,target:f[e]});let t="",e=0;for(const h of u.sort((e,t)=>e.beg-t.beg))t+=i.slice(e,h.beg)+h.target,e=h.end;if(t+=i.slice(e,i.length),$.test(p)){var b=p.lastIndexOf("@@"),b=b<0?p:p.slice(b+2);let e=b.search(/\S/);e<0&&(e=b.length),t=t.replace(_,"@@"+" ".repeat(e))}else{let e=p.search(/\S/);e<0&&(e=p.length),t=(t=t.replace(v,"")).replace(_,"\n"+" ".repeat(e))}s=s.substring(0,d)+t+s.substring(c),l.lastIndex-=r[0].length}}s=s.substring(0,t)+s.substring(o),r.lastIndex=0,e=r.exec(s)}return s.replace(_,"\\\n"),s}})(),expandInputStatement=e=>{let t=0,r=0,s=0,n=0,a;var i={u:["uvec4","usubpassInput"],i:["ivec4","isubpassInput"],f:["vec4","subpassInput"]};let o="",l=!1,c=!1;for(const x of e){var p=x.type,d=i[x.signed],f=x.inout,u=x.name,m=x.precision||"",g="Color"!==p?a??t:t,b="\n#if __VERSION__ >= 450\n"+`  layout(location = ${n}) out ${d[0]} ${u};
`+`#elif __VERSION__ >= 300
`+`  layout(location = ${s}) out ${d[0]} ${u};
`+`#endif
`,h="\n#if __VERSION__ >= 450\n"+`  layout(location = ${n}) out ${d[0]} ${u};
`+`#endif
`,y=`
`+`#pragma rate __in${u} pass
`+`#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT
`+`  #if __VERSION__ >= 450
`+`    layout(input_attachment_index = ${g}) uniform ${d[1]} __in${u};
`+`    #define subpassLoad_${u} subpassLoad(__in${u})
`+`  #else
`+`    #define subpassLoad_${u} ${d[0]}(gl_LastFrag${p}ARM, 0, 0, 0)
`+`  #endif
`+`#else
`+`  #define subpassLoad_${u} ${d[0]}(0, 0, 0, 0)
`+`#endif
`,g=`
`+`#pragma rate __in${u} pass
`+`#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT
`+`  #if __VERSION__ >= 450
`+`    layout(input_attachment_index = ${g}) uniform subpassInput __in${u};
`+`    #define subpassLoad_${u} subpassLoad(__in${u})
`+`  #elif __VERSION__ >= 300
`+`    layout(location = ${s}) inout ${m} ${d[0]} ${u};
`+`    #define subpassLoad_${u} ${u}
`+`  #else
`+`    #define subpassLoad_${u} gl_LastFragData[${r}]
`+`  #endif
`+`#else
`+`  #define subpassLoad_${u} ${m} ${d[0]}(0, 0, 0, 0)
`+`#endif
`;"out"===f&&(o+=b,n++,s++),"inout"===f&&(o+=h,n++),"in"!==f&&"inout"!==f||("Color"===p?(o+=g,t++,r++,s++,l=!0):(void 0===a&&(a=t,t++),o+=y,c=!0))}return l&&(o="#pragma extension([GL_EXT_shader_framebuffer_fetch, __VERSION__ < 450, enable])\n"+o),o=c?"#pragma extension([GL_ARM_shader_framebuffer_fetch_depth_stencil, __VERSION__ < 450, enable])\n"+o:o},expandSubpassInout=e=>{var t=new Array,r={Color:0,Depth:1,Stencil:2};const s={in:0,inout:1,out:2};var n={Color:{inouts:["in","out","inout"],types:["i","f","u"],hint:""},Depth:{inouts:["in"],types:["f"],hint:"subpassDepth"},Stencil:{inouts:["in"],types:["i"],hint:"isubpassStencil"}};e=e.replace(/subpassLoad\s*\(\s*(\w+)\s*\)/g,"subpassLoad_$1");let a=0;var i=/#pragma\s+(i|u)?subpass(Color|Depth|Stencil)\s+(\w+)\s*(mediump|highp|lowp)?\s+(\w+)\s+/g;let o=i.exec(e);for(;null!==o;){var l=o[1]||"f",c=o[2],p=o[3],d=o[4],f=o[5],u=a,m=n[c];if(!m.inouts.includes(p))return error(`unsupported inout type ${c}, `+p),e;if(!m.types.includes(l))return error(`unsupported subpass type for ${c}, only ${m.hint} supported`),e;t.push({type:c,inout:p,name:f,index:u,precision:d,signed:l,sortKeyInput:r[c],sortKeyInout:s[p]});m=o.index,f=o.index+o[0].length;e=e.substring(0,m)+e.substring(f),i.lastIndex=m,o=i.exec(e),++a}t.sort((e,t)=>e.sortKeyInout!==t.sortKeyInout?e.sortKeyInout-t.sortKeyInout:e.sortKeyInput!=t.sortKeyInput?e.sortKeyInput-t.sortKeyInput:e.sortKeyInout===s.out?e.index-t.index:e.name<t.name?-1:e.name>t.name?1:0);var g,b=expandInputStatement(t),h=/#pragma\s+subpass/g.exec(e);return h&&(g=h.index,h=h.index+h[0].length,e=e.substring(0,g)+b+e.substring(h)),e},expandLiteralMacro=s=>{var t={};let r=effectDefineRE.exec(s);for(;null!==r;){let e=r[2];e.endsWith("\\")&&(e=e.slice(0,-1)),t[r[1]]=e.trim();var n=r.index,a=r.index+r[0].length;s=s.substring(0,n)+s.substring(a),effectDefineRE.lastIndex=n,r=effectDefineRE.exec(s)}var i=Object.keys(t).map(e=>new RegExp(`\\b${e}\\b`,"g")),o=Object.values(t);for(let r=0;r<o.length;r++){let t=o[r];for(let e=0;e<r;e++)t=t.replace(i[e],o[e]);s=s.replace(i[r],t)}return s},extractMacroDefinitions=e=>{var t=new Set;let r=plainDefineRE.exec(e);for(var s,n=new Map;null!==r;)t.add(r[1]),r[2]&&"true"!==r[2].toLowerCase&&"false"!==r[2].toLowerCase&&(s=parseInt(r[2]),isNaN(s))&&n.set(r[1],r[2]),r=plainDefineRE.exec(e);return[t,n]},eliminateDeadCode=(()=>{const x=/[{}()]/g,v=/(?:\w+p\s+)?\w+\s+(\w+)\s*$/,E=/^\s*$/;let _="",$=0,k=0;const S=(e,t)=>{var r=[];let s=t.exec(e);for(;s;)r.push(s),s=t.exec(e);return r},w=new Set,F=(e,t)=>{if(!w.has(t)){w.add(t);for(const r of e[t].deps)F(e,r)}};return(t,r,s)=>{let e=0,n=0,a=0;k=0,x.lastIndex=0,w.clear();var i=[];for(const h of S(t,x)){var o,l,c=h[0];0===e&&("("===c?(n=1,o=t,l=h.index,o=o.substring(k,l).match(v)||["",""],_=o[1],$=l-o[0].length):")"===c?1===n?(n=2,a=h.index+1):n=0:"{"===c&&(n=2===n&&E.test(t.substring(a,h.index))?3:0)),"{"===c&&e++,"}"===c&&0==--e&&3===n&&(k=h.index+1,n=0,_)&&i.push({name:_,beg:$,end:k,paramListEnd:a,deps:[]})}let p=i.findIndex(e=>e.name===r);p<0&&(error(`EFX2403: entry function '${r}' not found.`),p=0);for(let e=0;e<i.length;e++){var d=i[e];for(const y of S(t,new RegExp("\\b"+d.name+"\\b","g"))){var f=i.findIndex(e=>y.index>e.beg&&y.index<e.end);0<=f&&f!==e&&i[f].deps.push(e)}}F(i,p);let u="",m=0,g=0;for(let e=0;e<i.length;e++){var b=i[e];const{name:_,beg:$,end:k}=b;w.has(e)||"main"===_?(b.beg-=g,b.end-=g,b.paramListEnd-=g,s.push(b)):(u+=t.substring(m,$),m=k,g+=k-$)}return u+t.substring(m)}})(),parseCustomLabels=(e,t={})=>{let r=e.join(" "),s=labelRE.exec(r);for(;s;){try{t[s[1]]=yaml.load(s[2]||"true")}catch(e){warn(`EFX2102: parameter for label '${s[1]}' is not legal YAML: `+e.message)}r=r.substring(s.index+s[0].length),s=labelRE.exec(r)}return t},getDefs=(t,e)=>{let r=e.lines.findIndex(e=>t<e);return r<0&&(r=e.lines.length),e[e.lines[r-1]]||[]},pushDefines=(e,t,r)=>{t.has(r.name)||e.push(r)},extractDefines=(r,o,l)=>{const c=[],p=e=>{l[e]=c.reduce((e,t)=>e.concat(t),[]),l.lines.push(e)};let d=0;for(let e=0;e<r.length;e++){let t=r[e],n=t.data,a,i;if("preprocessor"===t.type&&!n.startsWith("#extension")){if("#endif"===(n=n.split(/\s+/))[0]){for(;0<d;)c.pop(),d--;c.pop()}else{if("#else"===n[0]||"#elif"===n[0]){const m=c[c.length-1];if(m&&m.forEach((e,t)=>m[t]="!"===e[0]?e.slice(1):"!"+e),p(t.line),"#else"===n[0])continue;d++}else{if("#pragma"===n[0]){if(n.length<=1)continue;if("define-meta"===n[1]){if(n.length<=2){warn("EFX2101: define pragma: missing info",t.line);continue}if(ident.lastIndex=0,!ident.test(n[2]))continue;var f=c.reduce((e,t)=>e.concat(t),[]);let e=o.find(e=>e.name===n[2]);e||pushDefines(o,l.existingDefines,e={name:n[2],type:"boolean",defines:f,dummyDependency:!0});var u=parseCustomLabels(n.splice(3));for(const g in u)if("range"===g)e.type="number",e.range=[0,3],e.fixedType=!0,Array.isArray(u.range)?e.range=u.range:warn(`EFX2103: invalid range for macro '${e.name}'`,t.line);else if("options"===g)e.type="string",e.options=[],e.fixedType=!0,Array.isArray(u.options)?e.options=u.options:warn(`EFX2104: invalid options for macro '${e.name}'`,t.line);else if("default"===g)switch(u.default){case!0:e.default=1;break;case!1:e.default=0;break;default:e.type="constant",e.default=u.default,e.fixedType=!0}else"editor"!==g?warn(`EFX2105: define pragma: illegal label '${g}'`,t.line):e.editor=u.editor}else"warning"===n[1]?warn("EFX2107: "+n.slice(2).join(" ")):"error"===n[1]?error("EFX2108: "+n.slice(2).join(" ")):(f=parseCustomLabels(n.slice(1))).extension?l.extensions[f.extension[0]]={defines:getDefs(t.line,l),cond:f.extension[1],level:f.extension[2],runtimeCond:f.extension[3]}:l[t.line]=f;continue}if(!/#(el)?if$/.test(n[0]))continue}let r=[],s=!1;n.splice(1).some(e=>{if(ident.lastIndex=0,a=ident.exec(e)){if("defined"===a[0]||a[0].startsWith("__")||a[0].startsWith("GL_")||"VULKAN"===a[0])return!1;var t=c.reduce((e,t)=>e.concat(t),r.slice());if(i=o.find(e=>e.name===a[0])){let e=t.length<i.defines.length;i.dummyDependency&&(e=!0,delete i.dummyDependency),e&&(i.defines=t)}else pushDefines(o,l.existingDefines,i={name:a[0],type:"boolean",defines:t});r.push(("!"===e[0]?"!":"")+a[0])}else if(i&&/^[<=>]+$/.test(e)&&!i.fixedType)i.type="number",i.range=[0,3];else if("||"===e)return!(s=!0);return!1}),s&&(r=[]),c.push(r)}p(t.line)}}o.forEach(e=>(delete e.fixedType,delete e.dummyDependency))},extractUpdateRates=(s,n=[])=>{for(let r=0;r<s.length;r++){let e=s[r],t=e.data;"preprocessor"!==e.type||t.startsWith("#extension")||"#pragma"===(t=t.split(/\s+/))[0]&&4===t.length&&"rate"===t[1]&&n.push({name:t[2],rate:t[3]})}return n},extractParams=(()=>{const precision=/(low|medium|high)p/,extractInfo=(tokens,i)=>{const param={},definedPrecision=precision.exec(tokens[i].data);let offset=definedPrecision?2:0;if(param.name=tokens[i+offset+2].data,param.typename=tokens[i+offset].data,param.type=convertType(tokens[i+offset].data),param.count=1,definedPrecision&&(param.precision=definedPrecision[0]+" "),"["===tokens[offset=nextWord(tokens,i+offset+2)].data){let expr="",end=offset;for(;"]"!==tokens[++end].data;)expr+=tokens[end].data;try{if(/^[\d+\-*/%\s]+$/.test(expr))param.count=eval(expr);else{if(!builtinRE.test(param.name))throw expr;param.count=expr}param.isArray=!0}catch(e){error(`EFX2202: ${param.name}: non-builtin array length must be compile-time constant: `+e,tokens[offset].line)}}return param},stripDuplicates=e=>{const t={};return e.filter(e=>!t[e]&&(t[e]=!0))},exMap={whitespace:!0},nextWord=(e,t)=>{for(;++t,exMap[e[t].type];);return t},nextSemicolon=(e,t,r=e=>{})=>{for(;";"!==e[t].data;)r(e[t++]);return t},isFunctionParameter=(e,t)=>e.some(e=>t>e.beg&&t<e.paramListEnd),nonBlockUniforms=/texture|sampler|image|subpassInput/;return(o,l,c,p,d)=>{var f,u=[],m="vert"===p;for(let i=0;i<o.length;i++){let e=o[i],t=e.data,r,s;if("uniform"===t)r=c.blocks,s="blocks";else if("in"!==t||isFunctionParameter(d,e.position))if("out"!==t||isFunctionParameter(d,e.position)){if("buffer"!==t)continue;r=c.buffers,s="buffers"}else r=m?c.varyings:c.fragColors,s=m?"varyings":"fragColors";else{if("compute"===p){i=nextWord(o,i+2);continue}r=m?c.attributes:c.varyings,s=m?"attributes":"varyings"}const h=getDefs(e.line,l),y={};y.tags=l[e.line-1];let n=nextWord(o,i+2);if("{"!==o[n].data)Object.assign(y,extractInfo(o,i+2)),r===c.blocks&&(g=o[i+(y.precision?4:2)].data,(b=nonBlockUniforms.exec(g))?"sampler"===g?(r=c.samplers,s="samplers"):"sampler"===b[0]?(r=c.samplerTextures,s="samplerTextures"):"texture"===b[0]?(r=c.textures,s="textures"):"image"===b[0]?(r=c.images,s="images"):"subpassInput"===b[0]&&(r=c.subpassInputs,s="subpassInputs"):error("EFX2201: vector uniforms must be declared in blocks.",e.line)),n=nextSemicolon(o,n);else{for(y.name=o[i+2].data,y.members=[];"}"!==o[n=nextWord(o,n)].data;)r!==c.buffers&&(f=extractInfo(o,n),mappings.isSampler(f.type)&&error("EFX2208: texture uniforms must be declared outside blocks.",o[n].line),y.members.push(f)),n=nextSemicolon(o,n);y.members.reduce((e,t)=>{let r=mappings.GetTypeSize(t.type);switch(t.typename){case"mat2":r/=2;break;case"mat3":r/=3;break;case"mat4":r/=4}1<t.count&&r<16?(s=`uniform ${convertType(t.type)} ${t.name}[${t.count}]`,error("EFX2203: "+s+": array UBO members need to be 16-bytes-aligned to avoid implicit padding"),r=16):12===r?(s=`uniform ${convertType(t.type)} `+t.name,error("EFX2204: "+s+": please use 1, 2 or 4-component vectors to avoid implicit padding"),r=16):mappings.isPaddedMatrix(t.type)&&(s=`uniform ${convertType(t.type)} `+t.name,error("EFX2210: "+s+": use only 4x4 matrices to avoid implicit padding"));var s=Math.ceil(e/r)*r,e=s-e;return e&&error(`EFX2205: UBO '${y.name}' introduces implicit padding: `+`${e} bytes before '${t.name}', consider re-ordering the members`),s+r*t.count},0);var g=l.lines.find(e=>e>=o[i].line&&e<o[n].line);g&&error(`EFX2206: ${y.name}: no preprocessors allowed inside uniform blocks!`,g),y.members.forEach(e=>{"string"==typeof e.type&&error(`EFX2211: '${e.type} ${e.name}' in block '${y.name}': `+"struct-typed member within UBOs is not supported due to compatibility reasons.",o[n].line)}),n=nextWord(o,n),";"!==o[n].data&&error("EFX2209: Block declarations must be semicolon-terminated，non-array-typed and instance-name-free. "+`Please check your '${y.name}' block declaration.`,o[n].line)}var b=r.find(e=>e.name===y.name);b&&(y.members&&JSON.stringify(b.members)!==JSON.stringify(y.members)&&error(`EFX2207: different UBO using the same name '${y.name}'`,e.line),b.stageFlags|=mapShaderStage(p),y.duplicate=b);let a=i;r!==c.buffers&&r!==c.images||(y.memoryAccess=mappings.getMemoryAccessFlag(o[i-2].data),/writeonly|readonly/.test(o[i-2].data)&&(a=i-2)),u.push({beg:o[a].position,end:o[n].position,param:y.duplicate||y,type:s}),y.duplicate||(y.defines=stripDuplicates(h),y.stageFlags=mapShaderStage(p),r.push(y)),i=n}return u}})(),miscChecks=(()=>{const r=new RegExp("\\b(?:asm|class|union|enum|typedef|template|this|packed|goto|switch|default|inline|noinline|volatile|public|static|extern|external|interface|flat|long|short|double|half|fixed|unsigned|superp|input|output|hvec2|hvec3|hvec4|dvec2|dvec3|dvec4|fvec2|fvec3|fvec4|sampler1D|sampler3D|sampler1DShadow|sampler2DShadow|sampler2DRect|sampler3DRect|sampler2DRectShadow|sizeof|cast|namespace|using|texture)\\b"),s=/precision\s+(low|medium|high)p\s+(\w+)/;return e=>{var t=s.exec(e),t=(t?/#extension/.test(e.slice(t.index))&&warn("EFX2400: precision declaration should come after extensions"):warn("EFX2401: precision declaration not found."),r.exec(e));if(t&&error("EFX2402: using reserved keyword in glsl1: "+t[0]),!options.skipParserTest){t=tokenizer(e).filter(e=>"preprocessor"!==e.type);shaderTokens=t;try{parser(t)}catch(e){error("EFX2404: glsl1 parser failed: "+e,0)}}}})(),finalTypeCheck=(()=>{let a=null,i=!0;const o=(t,r)=>{let s=a.createShader(r);if(a.shaderSource(s,t),a.compileShader(s),!a.getShaderParameter(s,a.COMPILE_STATUS)){let e=1;r=t.replace(/^|\n/g,()=>`
${e++} `),t=a.getShaderInfoLog(s);a.deleteShader(s),s=null,error(`EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
${t}
`+r)}return s};return(e,t,r,s,n)=>{a||"undefined"==typeof document||(a=document.createElement("canvas").getContext("webgl",{depth:!0,stencil:!0}))&&(a.getSupportedExtensions().forEach(e=>a.getExtension(e)),i=i&&8<=a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS)),i&&a&&(r="#version 100\n"+r.reduce((e,t)=>{let r=1;switch(t.type){case"string":r=t.options[0];break;case"number":r=t.range[0];break;case"constant":r=t.default;break;case"boolean":r=void 0===t.default?1:t.default}return`${e}#define ${t.name} ${r}\n`},""),shaderName=s,s=o(r+e,a.VERTEX_SHADER),shaderName=n,e=o(r+t,a.FRAGMENT_SHADER),shaderName="linking",n=(e=>{let t=a.createProgram();return e.forEach(e=>a.attachShader(t,e)),a.linkProgram(t),a.getProgramParameter(t,a.LINK_STATUS)||(e=a.getProgramInfoLog(t),a.deleteProgram(t),t=null,error("EFX2407: link failed: "+e)),t})([s,e]),a.deleteProgram(n),a.deleteShader(e),a.deleteShader(s))}})(),stripToSpecificVersion=(()=>{const globalSearch=/#(if|elif|else|endif)(.*)?/g,legalExpr=/^[\d<=>!|&^\s]*(__VERSION__)?[\d<=>!|&^\s]*$/,macroWrap=(e,t,r)=>t?`#if ${t}
${e}#endif
`:e,declareExtension=(e,t)=>"require"===t?`#extension ${e}: require
`:`
#ifdef ${e}
#extension ${e}: enable
#endif
`;return(code,version,extensions,isVert)=>{version<310&&(code=code.replace(/layout\s*\((.*?)\)(\s*)(\w+)\s+(\w+)/g,(e,t,r,s,n)=>{return!isVert&&"out"===s||"out"!==s&&"in"!==s&&"uniform"!==s||"uniform"===s&&n.includes("image")?e:(0<=t.indexOf("std140")?"layout(std140)"+r+s:s)+" "+n}));const instances=[];let cap=null,temp=null;for(;;){if(cap=globalSearch.exec(code),!cap)break;"if"===cap[1]?temp?temp.level++:legalExpr.test(cap[2])&&(temp={start:cap.index,end:cap.index,conds:[cap[2]],content:[cap.index+cap[0].length],level:1}):"elif"===cap[1]?!temp||1<temp.level||(legalExpr.test(cap[2])||(error(`EFX2301: #elif conditions after a constant #if should be constant too; get '${cap[2]}'`),cap[2]=""),temp.conds.push(cap[2]),temp.content.push(cap.index,cap.index+cap[0].length)):"else"===cap[1]?!temp||1<temp.level||(temp.conds.push("true"),temp.content.push(cap.index,cap.index+cap[0].length)):"endif"===cap[1]&&temp&&!--temp.level&&(temp.content.push(cap.index),temp.end=cap.index+cap[0].length,instances.push(temp),temp=null)}let res=code;if(instances.length){res=res.substring(0,instances[0].start);for(let j=0;j<instances.length;j++){const ins=instances[j];for(let i=0;i<ins.conds.length;i++)if(eval(ins.conds[i].replace("__VERSION__",version))){const subBlock=code.substring(ins.content[2*i],ins.content[2*i+1]);res+=stripToSpecificVersion(subBlock,version,isVert);break}const next=instances[j+1]&&instances[j+1].start||code.length;res+=code.substring(ins.end,next)}}for(const ext in extensions){const{defines,cond,level,runtimeCond}=extensions[ext];eval(cond.replace("__VERSION__",version))&&(res=macroWrap(declareExtension(ext,level),runtimeCond,defines)+res)}return res}})(),glsl300to100=(a,e,p,t,d,r,s)=>{let f="",i=0;if(t.forEach(t=>{if("blocks"===t.type){const n=(f+=a.slice(i,t.beg)).length-f.search(/\s*$/)+1;e.find(e=>e.name===t.param.name).members.forEach(e=>{var t,r,s=a.match(new RegExp(`\\b${e.name}\\b`,"g"));!s||s.length<=1||(s=convertType(e.type),t=e.precision||"",r="string"==typeof e.count||e.isArray?`[${e.count}]`:"",f+=" ".repeat(n)+`uniform ${t}${s} ${e.name}${r};
`)}),i=t.end+(";"===a[t.end])}}),f=(f+=a.slice(i)).replace(/\btexture((?!2D|Cube)\w*)\s*\(\s*(\w+)\s*([,[])/g,(e,t,r,s,n)=>{const a="texture"+t;if(d.find(e=>e.name===a))return e;let i=new RegExp("sampler(\\w+)\\s+"+r);var o=d.find(e=>n>e.beg&&n<e.end);let l=o&&i.exec(f.substring(o.beg,o.eng))||i.exec(f);if(!l){o=p.find(e=>e.name===r);if(o&&o.options)for(const c of o.options)if(i=new RegExp("sampler(\\w+)\\s+"+c),l=i.exec(f))break;if(!l)return error(`EFX2300: sampler '${r}' does not exist`),e}return`texture${textureFuncRemap.get(l[1])??l[1]}${t}(`+r+s}),s)f=(f=f.replace(inDecl,(e,t,r)=>`attribute ${r};`)).replace(outDecl,(e,t,r)=>`varying ${r};`);else{f=f.replace(inDecl,(e,t,r)=>`varying ${r};`);const o=[];if(f=f.replace(outDecl,(e,t,r,s)=>{t=t&&locationRE.exec(t);return t||error("EFX2302: fragment output location must be specified"),o.push({name:s,location:t[1]}),""}),1===o.length){t=new RegExp(`\\b${o[0].name}\\b`,"g");f=f.replace(t,"gl_FragColor")}else if(1<o.length){for(const l of o){var n=new RegExp(`\\b${l.name}\\b`,"g");f=f.replace(n,`gl_FragData[${l.location}]`)}r.extensions.GL_EXT_draw_buffers||(r.extensions.GL_EXT_draw_buffers={defines:[],cond:"__VERSION__ <= 100",level:"enable"})}}return(f=f.replace(/layout\s*\(.*?\)\s*/g,()=>"")).replace(pragmasToStrip,"")},decorateBlockMemoryLayouts=(n,e)=>{let a=0;const i=[];e.forEach((e,t)=>{var r,s;"blocks"!==e.type&&"buffers"!==e.type||(r="buffers"===e.type,s=n.slice(a,e.beg),s=layoutExtract.exec(s),i[t]=s?a+s.index+(r?0:s[0].length-s[2].length-1):-1,a=e.end)});let s="";return a=0,e.forEach((t,r)=>{r=i[r];if(void 0!==r){if("blocks"===t.type)s=r<0?s+n.slice(a,t.beg)+"layout(std140) ":(s=s+n.slice(a,r)+", std140")+n.slice(r,t.beg);else if("buffers"===t.type){let e="std430";t.param.tags&&void 0!==t.param.tags.glBinding&&(e+=", binding = "+t.param.tags.glBinding),s=(s+=n.slice(a,r<0?t.beg:r))+`layout(${e}) `}s+=n.slice(t.beg,t.end),a=t.end}}),s+=n.slice(a)},decorateBindings=(c,p,e)=>{e=e.filter(e=>!builtinRE.test(e.param.name));let d=0;const f=[],u={};e.forEach((t,e)=>{if("fragColors"!==t.type){var r=t.param.name;if(p[t.type]){var s=c.slice(d,t.beg),n={prop:t.param},s=layoutExtract.exec(s),a=u[t.type]||(u[t.type]={});if(s){n.position=d+s.index+s[0].length-s[2].length-1;var i=bindingExtract.exec(s[1]);if(i){s[1].search(/\bset\s*=/)<0?n.position=s[1].length-n.position:n.position=-1;const o=parseInt(i[1]),l="varyings"===t.type||"attributes"===t.type?"location":"binding";let e=p[t.type].find(e=>e[l]===o);(e=e||"subpassInputs"!==t.type?e:!0)?(a[o]&&a[o]!==r&&error(`EFX2600: duplicated binding/location declaration for '${a[o]}' and '${r}'`),a[a[o]=r]=o):"blocks"===t.type?error(`EFX2601: illegal custom binding for '${r}', block bindings should be consecutive and start from 0`):"samplerTextures"===t.type?error(`EFX2602: illegal custom binding for '${r}', texture bindings should be consecutive and after all the blocks`):"buffers"===t.type?error(`EFX2603: illegal custom binding for '${r}', buffer bindings should be consecutive and after all the `+"blocks/samplerTextures"):"images"===t.type?error(`EFX2604: illegal custom binding for '${r}', image bindings should be consecutive and after all the `+"blocks/samplerTextures/buffers"):"textures"===t.type?error(`EFX2605: illegal custom binding for '${r}', texture bindings should be consecutive and after all the `+"blocks/samplerTextures/buffers/images"):"samplers"===t.type?error(`EFX2606: illegal custom binding for '${r}', sampler bindings should be consecutive and after all the `+"blocks/samplerTextures/buffers/images/textures"):error(`EFX2607: illegal custom location for '${r}', locations should be consecutive and start from 0`)}}f[e]=n,d=t.end}}}),e.forEach((e,t)=>{if(u[e.type]){var r;const s="attributes"===e.type||"varyings"===e.type||"fragColors"===e.type?"location":"binding",n=u[e.type],a=e.param.name;if("attributes"===e.type)if(a in n)f[t].prop[s]=n[a];else{let e=0;for(;n[e];)e++;f[t].prop[s]=e,n[e]=a}else a in n&&(r=f[t].prop[s],(e=p[e.type].find(e=>e[s]===n[a]))&&(e[s]=r),f[t].prop[s]=n[a])}});let a="";d=0;const i=mappings.SetIndex.MATERIAL;return e.forEach((e,t)=>{var r,s,n;f[t]&&(r=(n="attributes"===e.type||"varyings"===e.type||"fragColors"===e.type)?"location":"binding",{position:t,prop:s}=f[t],n=n?"":`set = ${i}, `,void 0===t?a=(a+=c.slice(d,e.beg))+`layout(${n+r} = ${s[r]}) `:0<=t?a=(a=(a+=c.slice(d,t))+(`, ${n+r} = `+s[r]))+c.slice(t,e.beg):t<-1?a=(a=a+c.slice(d,-t)+n)+c.slice(-t,e.beg):a+=c.slice(d,e.beg),a+=c.slice(e.beg,e.end),d=e.end)}),a+=c.slice(d),p.samplerTextures=p.samplerTextures.filter(t=>p.subpassInputs.findIndex(e=>e.binding===t.binding)<0),a},remapDefine=(r,s)=>{for(let t=0;t<r.defines.length;++t){let e=s.get(r.defines[t]);for(;e;)r.defines[t]=e,e=s.get(e)}},shaderFactory=(()=>{const r=/\s+$/gm,s=/(^\s*\n){2,}/gm,k=e=>{let t=e.replace(pragmasToStrip,"");return t=(t=t.replace(s,"\n")).replace(r,"")};const S=(s,n)=>e=>{if(!builtinRE.test(e.name))return!0;var t=e.tags;let r;return r=t&&t.builtin?t.builtin:"global",n[r+"s"][s].push({name:e.name,defines:e.defines}),!1},w=(t,e,r)=>{var s=e[r];for(let e=0;e!==s.length;++e){var n,a=s[e];void 0!==a.rate?t[a.rate][r].push(a):builtinRE.test(a.name)?(n=a.tags,!a.tags||!a.tags.builtin||"global"===n.builtin?t[3][r].push(a):"local"===n.builtin&&t[0][r].push(a)):t[1][r].push(a)}},u=(e,t,r)=>"main"===t?e:e+((e,t)=>{switch(e){case"vert":return`
void main() { gl_Position = ${t}(); }
`;case"frag":return`
layout(location = 0) out vec4 cc_FragColor;
void main() { cc_FragColor = ${t}(); }
`;default:return`
void main() { ${t}(); }
`}})(r,t),m=/([^:]+)(?::(\w+))?/,n={instance:0,batch:1,phase:2,pass:3},g=(e,r)=>{e.forEach(t=>{var e=r.find(e=>e.name===t.name);e&&(t.rate=n[e.rate])})},b={version:"300 es"},F=()=>({blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[],attributes:[],varyings:[],fragColors:[],descriptors:[]}),I=(e,t,r=[],s=F(),n=globalChunks,a=globalDeprecations)=>{var i={},o=(shaderName=e,{lines:[],extensions:{}}),{code:n,record:a,functions:l}=(e=e,n=n,a=a,l=t,c="main",e=m.exec(e),c=e[2]||c,d=new Set,f=[],e=unwindIncludes(`#include <${e[1]}>`,n,a,d),e=u(e,c,l),e=expandSubpassInout(e),e=expandLiteralMacro(e),e=expandFunctionalMacro(e),{code:eliminateDeadCode(e,c,f),record:d,functions:f}),e=shaderTokens=tokenizer(n,b),c=extractMacroDefinitions(n);o.existingDefines=c[0];const p=c[1];extractDefines(e,r,o);var d=extractUpdateRates(e),f=extractParams(e,o,s,t,l),c=(s.samplerTextures=s.samplerTextures.filter(t=>!s.subpassInputs.find(e=>e.name===t.name)),i.blockInfo=f,i.record=a,i.extensions=o.extensions,i.glsl4=n,s.attributes.forEach(e=>{remapDefine(e,p)}),s.blocks.forEach(e=>{remapDefine(e,p)}),s.buffers.forEach(e=>{remapDefine(e,p)}),s.images.forEach(e=>{remapDefine(e,p)}),s.samplerTextures.forEach(e=>{remapDefine(e,p)}),s.samplers.forEach(e=>{remapDefine(e,p)}),s.textures.forEach(e=>{remapDefine(e,p)}),g(s.blocks,d),g(s.buffers,d),g(s.images,d),g(s.samplerTextures,d),g(s.samplers,d),g(s.textures,d),g(s.subpassInputs,d),"vert"==t);return i.glsl3=stripToSpecificVersion(decorateBlockMemoryLayouts(n,f),300,o.extensions,c),"vert"==t||"frag"==t?(i.glsl1=stripToSpecificVersion(glsl300to100(n,s.blocks,r,f,l,o,c),100,o.extensions,c),miscChecks(i.glsl1)):i.glsl1="",i},T=()=>({blocks:[],samplerTextures:[],buffers:[],images:[]});return{compile:I,build:(e,t,r=globalChunks,s=globalDeprecations)=>{let n=[];var a=F(),i={vert:"",frag:""};for(const _ in e)i[_]=I(e[_],_,n,a,r,s);"graphics"===t&&finalTypeCheck(i.vert.glsl1,i.frag.glsl1,n,e.vert,e.frag);var o,l,c={globals:T(),locals:T(),statistics:{}};n=n.filter(e=>"constant"!==e.type);let p=0,d=0,f=0;a.blocks.forEach(e=>{var t=e.members.reduce((e,t)=>"number"!=typeof t.count?e:e+Math.ceil(mappings.GetTypeSize(t.type)/16)*t.count,0);e.stageFlags&VSBit&&(p+=t),e.stageFlags&FSBit&&(d+=t),e.stageFlags&CSBit&&(f+=t)},0),"graphics"===t&&(c.statistics.CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS=p,c.statistics.CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS=d),"compute"===t&&(c.statistics.CC_EFFECT_USED_COMPUTE_UNIFORM_VECTORS=f),a.descriptors[0]={rate:0,blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[]},a.descriptors[1]={rate:1,blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[]},a.descriptors[2]={rate:2,blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[]},a.descriptors[3]={rate:3,blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[]},o=a.descriptors,l=a,w(o,l,"blocks"),w(o,l,"samplerTextures"),w(o,l,"samplers"),w(o,l,"textures"),w(o,l,"buffers"),w(o,l,"images"),w(o,l,"subpassInputs");for(let e=0;4!==e;++e)a.descriptors[e].blocks.forEach(e=>{for(const t of e.members)"number"!=typeof t.count&&(t.count=0)});a.blocks=a.blocks.filter(S("blocks",c)),a.samplerTextures=a.samplerTextures.filter(S("samplerTextures",c)),a.buffers=a.buffers.filter(S("buffers",c)),a.images=a.images.filter(S("images",c)),a.attributes.forEach(e=>{var t;e.format=mappings.formatMap[e.typename],0<=e.defines.indexOf("USE_INSTANCING")&&(e.isInstanced=!0),e.tags&&e.tags.format&&(void 0!==(t=mappings.getFormat(e.tags.format))&&(e.format=t),mappings.isNormalized(t))&&(e.isNormalized=!0)}),a.attributes.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray,delete e.type,delete e.count,delete e.stageFlags)),a.varyings.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),a.blocks.forEach(e=>(delete e.rate,delete e.tags,e.members.forEach(e=>(delete e.typename,delete e.precision,delete e.isArray)))),a.samplerTextures.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),a.buffers.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray,delete e.members)),a.images.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),a.textures.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),a.samplers.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),a.subpassInputs.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray));let u=0,m=(a.blocks.forEach(e=>e.binding=u++),a.samplerTextures.forEach(e=>e.binding=u++),a.samplers.forEach(e=>e.binding=u++),a.textures.forEach(e=>e.binding=u++),a.buffers.forEach(e=>e.binding=u++),a.images.forEach(e=>e.binding=u++),a.subpassInputs.forEach(e=>e.binding=u++),0);a.attributes.forEach(e=>e.location=m++),m=0,a.varyings.forEach(e=>e.location=m++),m=0,a.fragColors.forEach(e=>e.location=m++),a.blocks.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name)))),a.samplerTextures.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name)))),a.samplers.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name)))),a.textures.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name)))),a.buffers.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name)))),a.images.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name)))),a.subpassInputs.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name)))),a.attributes.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name)))),a.varyings.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name)))),a.fragColors.forEach(e=>e.defines=e.defines.filter(t=>n.find(e=>t.endsWith(e.name))));var g={},b={},h={};const y=new Set;for(const $ in e){var x="vert"===$;i[$].glsl4=stripToSpecificVersion(decorateBindings(i[$].glsl4,a,i[$].blockInfo),460,i[$].extensions,x),h[$]=k(i[$].glsl4),b[$]=k(i[$].glsl3),g[$]=k(i[$].glsl1),i[$].record.forEach(e=>y.add(e))}let v=0;v="graphics"===t?((h.compute||b.compute)&&error("compute shader is not supported in graphics effect"),mappings.murmurhash2_32_gc(h.vert+h.frag+b.vert+b.frag+g.vert+g.frag,666)):((h.vert||h.frag||b.vert||b.frag||g.vert||g.frag)&&error("vertex/fragment shader is not supported in compute effect"),mappings.murmurhash2_32_gc(h.vert+h.frag+h.compute+b.vert+b.frag+b.compute+g.vert+g.frag,666));const E=a.descriptors[3];return a.blocks=a.blocks.filter(t=>E.blocks.every(e=>e.name!==t.name)),a.samplerTextures=a.samplerTextures.filter(t=>E.samplerTextures.every(e=>e.name!==t.name)),a.samplers=a.samplers.filter(t=>E.samplers.every(e=>e.name!==t.name)),a.textures=a.textures.filter(t=>E.textures.every(e=>e.name!==t.name)),a.buffers=a.buffers.filter(t=>E.buffers.every(e=>e.name!==t.name)),a.images=a.images.filter(t=>E.images.every(e=>e.name!==t.name)),Object.assign(a,{hash:v,glsl4:h,glsl3:b,glsl1:g,builtins:c,defines:n,record:y})}}})(),compileShader=shaderFactory.compile,parseEffect=(()=>{const l=/CCEffect\s*%{([^]+?)(?:}%|%})/,c=/CCProgram\s*([\w-]+)\s*%{([^]*?)(?:}%|%})/,p=/#.*$/gm,d=/^\s*$/,f=/\n[^\s]/,u=/^[^\S\n]/gm,m=/\t/g,g=(t,r,s="effect")=>{if(Array.isArray(t))if(Array.isArray(r)){if(t[0])for(let e=0;e<r.length;e++)g(t[0],r[e],s+`[${e}]`)}else error(`EFX1002: ${s} must be an array`);else if(!r||"object"!=typeof r||Array.isArray(r))error(`EFX1003: ${s} must be an object`);else{for(const e of Object.keys(r))-1!==e.indexOf(":")&&error(`EFX1004: syntax error at '${e}', you might need to insert a space after colon`);if(t.any)for(const n of Object.keys(r))g(t.any,r[n],s+("."+n));else for(const a of Object.keys(t)){let e=a;if("$"===e[0])e=e.substring(1);else if(!r[e])continue;g(t[a],r[e],s+("."+e))}}};return(e,t)=>{shaderName="syntax",t=t.replace(m," ".repeat(tabAsSpaces));let r={},s={},n={};var a=l.exec(t.replace(p,""));if(a){try{var i=yaml.load(a[1]);r=JSON.parse(JSON.stringify(i))}catch(e){error("EFX1001: CCEffect parser failed: "+e)}r.name||(r.name=e),g(mappings.effectStructure,r)}else error("EFX1000: CCEffect is not defined");t=stripComments(t);let o=c.exec(t);for(;o;){let e=o[2];if(!d.test(e))for(;!f.test(e);)e=e.replace(u,"");addChunk(o[1],e,s,n),t=t.substring(o.index+o[0].length),o=c.exec(t)}return{effect:r,templates:s,localDeprecations:n}}})(),mapPassParam=(()=>{const c=(t,e)=>{let r=0,s=e=>e.name===t&&(r=e.type,!0);return e.blocks.some(e=>e.members.some(s))||e.samplerTextures.some(s),r},p=/^(\w+)(?:\.([xyzw]+|[rgba]+))?$/,d={x:0,y:1,z:2,w:3,r:0,g:1,b:2,a:3},n=(e,t)=>{let r={};for(const o of Object.keys(e)){var s,n,a,i;"__metadata__"===o?(r=e[o],delete e[o]):(s=e[o],a=c(o,t),void 0!==s.type&&warn(`EFX3300: property '${o}': you don't have to specify type in here`),s.type=a,s.target&&(s.handleInfo=((e,t)=>{var r=[e,0,0],s=p.exec(e);if(s){var n=s[2]&&s[2].toLowerCase()||"";const a=d[n[0]]||0;n.split("").map((e,t)=>d[e]-a-t).some(e=>e)&&error(`EFX3304: '${e}': random component swizzle is not supported`),r[0]=s[1],r[1]=a,r[2]=c(s[1],t),n.length&&(r[2]-=Math.max(0,mappings.GetTypeSize(r[2])/4-n.length)),r[2]<=0&&error(`EFX3305: no matching uniform target '${e}'`)}else error(`EFX3303: illegal property target '${e}'`);return r})(s.target,t),delete s.target,s.type=s.handleInfo[2],a=s.editor&&s.editor.visible,n=s.handleInfo[0],i=c(s.handleInfo[0],t),e[n]||(e[n]={type:i,editor:{visible:!1}}),void 0!==a&&!a||(e[n].editor?void 0===e[n].editor.deprecated&&(e[n].editor.deprecated=!0):e[n].editor={deprecated:!0}),mappings.isSampler(i)?s.value&&(e[n].value=s.value):(e[n].value||(e[n].value=Array(mappings.GetTypeSize(i)/4).fill(0)),Array.isArray(s.value)?e[n].value.splice(s.handleInfo[1],s.value.length,...s.value):void 0!==s.value&&e[n].value.splice(s.handleInfo[1],1,s.value))),s.sampler&&(s.samplerHash=(e=>{for(const t of Object.keys(e))if(m[t]===undefined)warn(`EFX3301: illegal sampler info '${t}'`);return mappings.Sampler.computeHash(e)})(u(s.sampler)),delete s.sampler),"number"!=(a=typeof s.value)&&"boolean"!=a||(s.value=[s.value]),(i=((e,t,r)=>{if(t<=0)return"no matching uniform";if(void 0!==e)if("string"===r){if(!mappings.isSampler(t))return"string for vectors"}else{if(!Array.isArray(e))return"non-array for buffer members";if(e.length!==mappings.GetTypeSize(t)/4)return"wrong array length"}return""})(s.value,s.type,a))&&error(`EFX3302: illegal property declaration for '${o}': `+i))}for(const l of Object.keys(e))f(e[l],r);return e},f=(e,t)=>{for(const s of Object.keys(t)){var r=t[s];"object"==typeof r&&"object"==typeof e[s]?f(e[s],r):void 0===e[s]&&(e[s]=r)}},u=t=>{for(const s in t){var r=t[s];if("string"==typeof r){let e=parseInt(r);void 0!==(e=isNaN(e)?mappings.passParams[r.toUpperCase()]:e)&&(t[s]=e)}else if(Array.isArray(r)){if(r.length)switch(typeof r[0]){case"object":r.forEach(u);break;case"string":u(r);break;case"number":t[s]=(255*r[0]<<24|255*r[1]<<16|255*r[2]<<8|255*(r[3]||255))>>>0}}else"object"==typeof r&&u(r)}return t},m=new mappings.SamplerInfo,a=/^([a-zA-Z]+)?\s*([+-])?\s*([\dxabcdef]+)?$/i,i=mappings.RenderPriority.DEFAULT,o=mappings.RenderPriority.MIN,l=mappings.RenderPriority.MAX;return(e,t)=>{shaderName="type error";var r,s={};e.priority&&(s.priority=(e=>{let t=0;var r=a.exec(e);return r[1]&&(t=mappings.RenderPriority[r[1].toUpperCase()]),r[3]&&(t+=parseInt(r[3])*("-"===r[2]?-1:1)),isNaN(t)||t<o||t>l?(warn("EFX3000: illegal pass priority: "+e),i):t})(e.priority),delete e.priority),e.depthStencilState&&(s.depthStencilState=(e=>{for(const t of Object.keys(e))!t.startsWith("stencil")||t.endsWith("Front")||t.endsWith("Back")||(e[t+"Front"]=e[t+"Back"]=e[t],delete e[t]);return e.stencilWriteMaskFront!==e.stencilWriteMaskBack&&warn("EFX3100: WebGL(2) doesn't support inconsistent front/back stencil write mask"),e.stencilReadMaskFront!==e.stencilReadMaskBack&&warn("EFX3101: WebGL(2) doesn't support inconsistent front/back stencil read mask"),e.stencilRefFront!==e.stencilRefBack&&warn("EFX3102: WebGL(2) doesn't support inconsistent front/back stencil ref"),u(e)})(e.depthStencilState),delete e.depthStencilState),e.switch&&(s.switch=(r=e.switch,t.defines.find(e=>e.name===r)&&error("EFX3200: existing shader macros cannot be used as pass switch"),r),delete e.switch),e.properties&&(s.properties=n(e.properties,t),delete e.properties),e.migrations&&(s.migrations=e.migrations,delete e.migrations),u(e),Object.assign(e,s)}})(),reduceHeaderRecord=e=>{var t=new Set;for(const r of e)r.record.forEach(t.add,t);return[...t.values()]},stageValidation=e=>{const t={vert:"graphics",frag:"graphics",compute:"compute"};if(0===e.length)return error("0 stages provided for a pass"),"";const r=t[e[0]];if(e.forEach(e=>t[e]?t[e]!==r?(error("more than one pass type appears"),""):void 0:(error("invalid stage type "+e),"")),"graphics"===r){var s=e.find(e=>"vert"===e),n=e.find(e=>"frag"===e);if(1===e.length||!s||!n)return error("graphics pass must include vert and frag shaders"),""}return r},buildEffect=(t,e)=>{effectName=t;var{effect:t,templates:r,localDeprecations:s}=parseEffect(t,e);if(!t||!Array.isArray(t.techniques))return null;var r=Object.assign({},globalChunks,r),n={};for(const o in globalDeprecations)n[o]=Object.assign({},globalDeprecations[o],s[o]);var e=Object.keys(n.identifiers).reduce((e,t)=>"|"+t+e,"").slice(1),a=(e.length&&(n.identifierRE=new RegExp(`\\b(${e})\\b`,"g")),t.shaders=[]);for(const l of t.techniques)for(const c of l.passes){const p={};var i=[];c.vert&&(p.vert=c.vert,delete c.vert,i.push("vert")),c.frag&&(p.frag=c.frag,delete c.frag,i.push("frag")),c.compute&&(p.compute=c.compute,delete c.compute,i.push("compute"));const t=c.program=i.reduce((e,t)=>e.concat("|"+p[t]),effectName);i=stageValidation(i);if(""!==i){let e=a.find(e=>e.name===t);e||((e=shaderFactory.build(p,i,r,n)).name=t,a.push(e)),mapPassParam(c,e)}}return t.dependencies=reduceHeaderRecord(a),t};module.exports={options:options,addChunk:addChunk,compileShader:compileShader,buildEffect:buildEffect};