"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.GltfMeshHandler=void 0;const reader_manager_1=require("./reader-manager"),utils_1=require("../../utils"),cc_1=require("cc"),fs_extra_1=__importDefault(require("fs-extra")),uv_unwrap_1=require("../utils/uv-unwrap"),fs_extra_2=require("fs-extra"),meshOptimizer_1=require("./meshOptimizer");exports.GltfMeshHandler={name:"gltf-mesh",assetType:"cc.Mesh",iconInfo:{default:{type:"icon",value:"gltf-mesh"},async generateThumbnail(t){var r={type:"icon",value:"gltf-mesh"};try{let e=await Editor.Message.request("scene","query-thumbnail",[t.uuid],[Manager.assetManager.queryAssetProperty(t,"type")]);Array.isArray(e)&&(e=e[0]),r.value=e,r.type="image"}catch(e){console.warn(`Query asset ${t.url} thumbnail failed!`)}return r}},instantiation:".mesh",importer:{version:"1.1.1",async import(e){if(!e.parent)return!1;var t=await reader_manager_1.glTfReaderManager.getOrCreate(e.parent),i=e.parent.userData.generateLightmapUVNode,r=e.parent.userData,s=e.userData;let n=t.createMesh(e.userData.gltfIndex,i,r.addVertexColor??!1),a=(s.lodOptions&&((t=(0,meshOptimizer_1.getDefaultSimplifyOptions)()).targetRatio=s.lodOptions.faceCount,n=await(0,meshOptimizer_1.simplifyMesh)(n,t)),0);if(s.triangleCount=0,n.struct.primitives?.forEach(e=>{e&&e.indexView&&(a+=e.indexView.count/3)}),s.triangleCount=a,n.allowDataAccess=e.parent.userData.allowMeshDataAccess??!0,i){var u=[],l=[];let r=0;for(let e=0;e<n.struct.primitives.length;e++){var m=n.readAttribute(e,cc_1.gfx.AttributeName.ATTR_POSITION);let t;t=2===n.struct.vertexBundles[e].view.stride||4===n.struct.vertexBundles[e].view.stride?n.readIndices(e):(console.warn("Invalid indeces stride"),[]);for(let e=0;e<m.length;++e)u.push(m[e]);for(let e=0;e<t.length;++e)l.push(t[e]+r);n.readAttribute(e,cc_1.gfx.AttributeName.ATTR_TEX_COORD1),r+=n.struct.vertexBundles[e].view.count}var t=u.length/3,s=new Uint8Array(8+4*u.length+4*l.length),i=new Int32Array(s.buffer,0),o=(i[0]=t,i[1]=l.length,new Float32Array(s.buffer,8)),f=new Int32Array(s.buffer,8+4*u.length);for(let e=0;e<u.length;e++)o[e]=u[e];for(let e=0;e<l.length;e++)f[e]=l[e];var t=e.uuid,i=e.temp,s=(await(0,fs_extra_2.ensureDir)(i),await fs_extra_1.default.promises.writeFile(i+`/${t}_in.bin`,s),await(0,uv_unwrap_1.unwrapLightmapUV)(i+`/${t}_in.bin`,i+`/${t}_out.bin`),await fs_extra_1.default.promises.readFile(i+`/${t}_out.bin`)),i=new Uint8Array(s),p=new Float32Array(i.buffer,4);let a=0;for(let r=0;r<n.struct.primitives.length;r++){var h=n.readAttribute(r,cc_1.gfx.AttributeName.ATTR_TEX_COORD1),d=n.struct.vertexBundles[r].attributes;let t=0;if(0<h.length){for(let e=0;e<d.length&&d[e].name!==cc_1.gfx.AttributeName.ATTR_TEX_COORD1;e++){var _=n.readAttributeFormat(r,d[e].name);_&&(t+=_.size)}if(0<t)for(let e=0;e<n.struct.vertexBundles[r].view.count;e++){var c=n.struct.vertexBundles[r].view.offset+t+e*n.struct.vertexBundles[r].view.stride,g=new DataView(n.data.buffer);g.setFloat32(c,p[a],!0),g.setFloat32(c+4,p[a+1],!0),a+=2}}}}r.meshSimplify&&r.meshSimplify.enable&&(n=await(0,meshOptimizer_1.simplifyMesh)(n,r.meshSimplify)),r.meshOptimize&&r.meshOptimize.enable&&(n=await(0,meshOptimizer_1.optimizeMesh)(n,r.meshOptimize)),r.meshCluster&&r.meshCluster.enable&&(n=await(0,meshOptimizer_1.clusterizeMesh)(n,r.meshCluster)),0!==(n=r.meshCompress&&r.meshCompress.enable?await(0,meshOptimizer_1.compressMesh)(n,r.meshCompress):n).data.byteLength&&(n._setRawAsset(".bin"),await e.saveToLibrary(".bin",Buffer.from(n.data)));t=EditorExtends.serialize(n),await e.saveToLibrary(".json",t),s=(0,utils_1.getDependUUIDList)(t);return e.setData("depends",s),!0}}},exports.default=exports.GltfMeshHandler;