"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.deflateMesh=exports.quantizeMesh=exports.encodeMesh=exports.compressMesh=exports.simplifyMesh=exports.getDefaultSimplifyOptions=exports.clusterizeMesh=exports.optimizeMesh=void 0;const cc_1=require("cc"),meshopt_encoder_1=__importDefault(require("meshopt_encoder")),zlib_1=__importDefault(require("zlib")),gltf_converter_1=require("../utils/gltf-converter");let inited=!1;async function tryInitMeshOpt(){return inited?Promise.resolve():meshopt_encoder_1.default.init().then(()=>{console.log("MeshOpt init success"),inited=!0})}function getOffset(t,r){let n=0;for(let e=0;e<r;++e){var i=t[e];n+=cc_1.gfx.FormatInfos[i.format].size}return n}const overdrawThreshold=3;async function optimizeMesh(t,r){if(await tryInitMeshOpt(),!r)return t;if(!(r.overdraw||r.vertexCache||r.vertexFetch))return console.warn("No optimization option is enabled, return the original mesh"),t;var n=new gltf_converter_1.BufferBlob;n.setNextAlignment(0);const i=JSON.parse(JSON.stringify(t.struct));for(let e=0;e<i.primitives.length;++e){var o=i.primitives[e];if(o.primitiveMode===cc_1.gfx.PrimitiveMode.POINT_LIST||void 0===o.indexView){console.warn("Only triangle list is supported.");for(let e=0;e<o.vertexBundelIndices.length;++e){var s=i.vertexBundles[o.vertexBundelIndices[e]],a=s.view,f=new Uint8Array(t.data.buffer,a.offset,a.length),a=(n.setNextAlignment(a.stride),{offset:n.getLength(),length:f.byteLength,count:a.count,stride:a.stride});s.view=a,n.addBuffer(f)}}else{var u=o.indexView,c=i.vertexBundles[o.vertexBundelIndices[0]].view.count,d=new Uint8Array(u.count*Uint32Array.BYTES_PER_ELEMENT);if(2===u.stride){var m=new Uint16Array(t.data.buffer,u.offset,u.count),l=new Uint32Array(d.buffer,0,u.count);for(let e=0;e<u.count;++e)l[e]=m[e]}else 4===u.stride&&d.set(new Uint8Array(t.data.buffer,u.offset,u.count*Uint32Array.BYTES_PER_ELEMENT));if(r.vertexCache&&meshopt_encoder_1.default.optimizer.optimizeVertexCache(d,d,u.count,c),r.overdraw&&((p=o.vertexBundelIndices.findIndex(e=>{return 0<=i.vertexBundles[e].attributes.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION)}))<0?console.warn("No position attribute found, overdraw optimization is not supported."):(A=(p=i.vertexBundles[o.vertexBundelIndices[p]]).view,x=(p=p.attributes).findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION),p=getOffset(p,x),x=new Uint8Array(t.data.buffer,A.offset,A.length),meshopt_encoder_1.default.optimizer.optimizeOverdraw(d,d,u.count,x.subarray(p),c,A.stride,overdrawThreshold))),r.vertexCache||r.overdraw||r.vertexFetch)for(let e=0;e<o.vertexBundelIndices.length;++e){var g=i.vertexBundles[o.vertexBundelIndices[e]],h=g.view,_=new Uint8Array(t.data.buffer,h.offset,h.length),h=(n.setNextAlignment(h.stride),{offset:n.getLength(),length:_.byteLength,count:h.count,stride:h.stride});g.view=h,n.addBuffer(_)}else if(1===o.vertexBundelIndices.length){var x=i.vertexBundles[o.vertexBundelIndices[0]],p=x.view,A=new Uint8Array(t.data.buffer,p.offset,p.length),v=new Uint8Array(p.count*p.stride),y=(meshopt_encoder_1.default.optimizer.optimizeVertexFetch(v,d,u.count,A,p.count,p.stride),n.setNextAlignment(p.stride),{offset:n.getLength(),length:v.byteLength,count:p.count,stride:p.stride});x.view=y,n.addBuffer(v)}else if(1<o.vertexBundelIndices.length){var E=new Uint8Array(u.count*Uint32Array.BYTES_PER_ELEMENT),w=meshopt_encoder_1.default.optimizer.optimizeVertexFetchRemap(E,d,u.count,c);meshopt_encoder_1.default.optimizer.optimizeRemapIndex(d,d,u.count,E);for(let e=0;e<o.vertexBundelIndices.length;++e){var T=i.vertexBundles[o.vertexBundelIndices[e]],b=T.view,B=new Uint8Array(t.data.buffer,b.offset,b.length),R=new Uint8Array(w*b.stride),B=(meshopt_encoder_1.default.optimizer.optimizeRemapVertex(R,B,w,b.stride,E),n.setNextAlignment(b.stride),{offset:n.getLength(),length:R.byteLength,count:w,stride:b.stride});T.view=B,n.addBuffer(R)}}n.setNextAlignment(Uint32Array.BYTES_PER_ELEMENT);y={offset:n.getLength(),length:d.byteLength,count:u.count,stride:Uint32Array.BYTES_PER_ELEMENT};o.indexView=y,n.addBuffer(d)}}var e=new cc_1.Mesh;e.reset({struct:i,data:n.getCombined()}),e.hash;return e}exports.optimizeMesh=optimizeMesh;const maxTriangleCount=124,maxVertexCount=64,coneWeight=.5;async function clusterizeMesh(x,p){if(await tryInitMeshOpt(),p){var e=x.struct,r=x.struct.primitives;const A=x.struct.vertexBundles,v=[],y=[],E=[];let g=0,h=0,_=0;if(r.forEach((e,r)=>{if(e.indexView)if(1===e.vertexBundelIndices.length){var n=e.indexView,i=n.count,o=A[e.vertexBundelIndices[0]].view,s=o.count,a=meshopt_encoder_1.default.optimizer.buildMeshLetsBound(i,maxVertexCount,maxTriangleCount),f=new Uint8Array(a*Uint32Array.BYTES_PER_ELEMENT*4),u=new Uint8Array(a*maxVertexCount*Uint32Array.BYTES_PER_ELEMENT),a=new Uint8Array(a*maxTriangleCount*Uint32Array.BYTES_PER_ELEMENT*3),c=A[e.vertexBundelIndices[0]].attributes,d=c.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION),c=getOffset(c,d),d=new Uint8Array(x.data.buffer,o.offset+c,o.length-c);let t=0;if(4===n.stride){c=new Uint32Array(x.data.buffer,n.offset,i);t=meshopt_encoder_1.default.optimizer.buildMeshLets(f,u,a,c,i,d,s,o.stride,maxVertexCount,maxTriangleCount,coneWeight)}else{if(2!==n.stride)return void console.warn(`Submesh ${r} has unsupported index stride, meshlet optimization is not supported.`);var m=new Uint16Array(x.data.buffer,n.offset,i),l=new Uint32Array(i);for(let e=0;e<i;++e)l[e]=m[e];t=meshopt_encoder_1.default.optimizer.buildMeshLets(f,u,a,l,i,d,s,o.stride,maxVertexCount,maxTriangleCount,coneWeight)}if(p?.coneCluster){new Uint8Array(48*t);for(let e=0;e<t;++e);}v.push(f),y.push(u),E.push(a),g+=f.byteLength,h+=u.byteLength,_+=a.byteLength,e.cluster={clusterView:{offset:g,length:f.byteLength,count:t,stride:4*Uint32Array.BYTES_PER_ELEMENT},vertexView:{offset:h,length:u.byteLength,count:s,stride:Uint32Array.BYTES_PER_ELEMENT},triangleView:{offset:_,length:a.byteLength,count:i,stride:3*Uint32Array.BYTES_PER_ELEMENT}}}else 1<e.vertexBundelIndices.length?console.warn(`Submesh ${r} has more than one vertex bundle, cache optimization is not supported.`):console.warn(`Submesh ${r} has no vertex bundle, cache optimization is not supported.`);else console.warn(`Submesh ${r} has no index buffer, meshlet optimization is not supported.`)}),0<v.length){const i=v.reduce((e,t)=>e+t.byteLength,0),o=y.reduce((e,t)=>e+t.byteLength,0);var n=E.reduce((e,t)=>e+t.byteLength,0);const s=new Uint8Array(x.data.byteLength+i+o+n);s.set(x.data);let t=x.data.byteLength;v.forEach(e=>{s.set(e,t),t+=e.byteLength}),y.forEach(e=>{s.set(e,t),t+=e.byteLength}),E.forEach(e=>{s.set(e,t),t+=e.byteLength}),r.forEach((e,t)=>{e.cluster&&(e.cluster.clusterView.offset+=x.data.byteLength,e.cluster.vertexView.offset+=x.data.byteLength+i,e.cluster.triangleView.offset+=x.data.byteLength+i+o)});n=new cc_1.Mesh;n.reset({struct:e,data:s}),n.struct.cluster=!0,n.hash;return n}}return x}function getDefaultSimplifyOptions(){return{enable:!0,targetRatio:.5,autoErrorRatio:!0,lockBoundary:!0}}async function simplifyMesh(i,e){if(await tryInitMeshOpt(),!e||!e.targetRatio)return i;if(!i.struct.primitives.every(e=>e.primitiveMode===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST||e.primitiveMode===cc_1.gfx.PrimitiveMode.POINT_LIST))return console.warn("Only triangle list and point list are supported."),i;if(i.struct.compressed)return console.warn("Compressed mesh is not supported."),i;if(i.struct.cluster)return console.warn("Mesh cluster is not supported."),i;if(i.struct.quantized)return console.warn("Quantized mesh is not supported."),i;var o=e.lockBoundary?1:0,s=e.targetRatio,t=1-Math.pow(.9,-Math.log10(s)),a=!e.autoErrorRate&&e.errorRate||t,f=new gltf_converter_1.BufferBlob;f.setNextAlignment(0);const u=JSON.parse(JSON.stringify(i.struct));var r=u.primitives;for(let n=0;n<r.length;++n){var c=r[n];if(c.primitiveMode===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST&&c.indexView){var d=c.indexView;let e,t=new Uint8Array(d.count*Uint32Array.BYTES_PER_ELEMENT),r=d.count;if(2===d.stride){e=new Uint8Array(t.buffer,0,d.count*Uint32Array.BYTES_PER_ELEMENT);var m=new Uint16Array(i.data.buffer,d.offset,d.count),l=new Uint32Array(e.buffer,0,d.count);for(let e=0;e<d.count;++e)l[e]=m[e]}else{if(4!==d.stride)return console.warn(`Submesh ${n} has unsupported index stride, simplify optimization is not supported.`),i;e=new Uint8Array(i.data.buffer,d.offset,d.count*Uint32Array.BYTES_PER_ELEMENT)}var g=c.vertexBundelIndices.findIndex(e=>{return 0<=u.vertexBundles[e].attributes.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION)});if(g<0)return console.warn("No position attribute found, simplify optimization is not supported."),i;var g=u.vertexBundles[c.vertexBundelIndices[g]],h=g.view,_=g.attributes,x=_.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION),_=getOffset(_,x),x=new Uint8Array(i.data.buffer,h.offset,h.length),p=3*Math.floor(d.count*s/3);if(r=meshopt_encoder_1.default.optimizer.simplify(t,e,d.count,x.subarray(_),h.count,h.stride,p,a,o,0),t=new Uint8Array(t.buffer,0,r*Uint32Array.BYTES_PER_ELEMENT),1===c.vertexBundelIndices.length){r<h.count?r:h.count;_=new Uint8Array(h.count*h.stride),p=meshopt_encoder_1.default.optimizer.optimizeVertexFetch(_,t,r,x,h.count,h.stride),_=new Uint8Array(_.buffer,0,p*h.stride),x=(f.setNextAlignment(h.stride),{offset:f.getLength(),length:_.byteLength,count:p,stride:h.stride});g.view=x,f.addBuffer(_)}else{var A=new Uint8Array(r*Uint32Array.BYTES_PER_ELEMENT),v=meshopt_encoder_1.default.optimizer.optimizeVertexFetchRemap(A,t,r,h.count);meshopt_encoder_1.default.optimizer.optimizeRemapIndex(t,t,r,A);for(let e=0;e<c.vertexBundelIndices.length;++e){var y=u.vertexBundles[c.vertexBundelIndices[e]],E=y.view,w=new Uint8Array(i.data.buffer,E.offset,E.length),T=new Uint8Array(v*E.stride),w=(meshopt_encoder_1.default.optimizer.optimizeRemapVertex(T,w,v,E.stride,A),f.setNextAlignment(E.stride),{offset:f.getLength(),length:T.byteLength,count:v,stride:E.stride});y.view=w,f.addBuffer(T)}}f.setNextAlignment(Uint32Array.BYTES_PER_ELEMENT);p={offset:f.getLength(),length:t.byteLength,count:r,stride:Uint32Array.BYTES_PER_ELEMENT};c.indexView=p,f.addBuffer(t)}else if(c.primitiveMode===cc_1.gfx.PrimitiveMode.POINT_LIST){if(1===c.vertexBundelIndices.length){var g=u.vertexBundles[c.vertexBundelIndices[0]],x=g.view,_=g.attributes,h=_.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION),p=getOffset(_,h),b=new Uint8Array(i.data.buffer,x.offset,x.length),B=3*Math.floor(x.count*s/3),R=new Uint8Array(B*x.stride),b=meshopt_encoder_1.default.optimizer.simplifyPoints(R,b.subarray(p),x.count,x.stride,B),R=new Uint8Array(R.buffer,0,b*x.stride),B=(f.setNextAlignment(x.stride),{offset:f.getLength(),length:R.byteLength,count:b,stride:x.stride});g.view=B,f.addBuffer(R)}else if(1<c.vertexBundelIndices.length)return console.warn(`Submesh ${n} has more than one vertex bundle, which is not supported.`),i}else{for(let e=0;e<c.vertexBundelIndices.length;++e){var N=u.vertexBundles[c.vertexBundelIndices[e]],M=N.view,z=new Uint8Array(i.data.buffer,M.offset,M.length),M=(f.setNextAlignment(M.stride),{offset:f.getLength(),length:z.byteLength,count:M.count,stride:M.stride});N.view=M,f.addBuffer(z)}c.indexView&&(b=c.indexView,B=new Uint8Array(i.data.buffer,b.offset,b.length),f.setNextAlignment(Uint32Array.BYTES_PER_ELEMENT),R={offset:f.getLength(),length:B.byteLength,count:b.count,stride:Uint32Array.BYTES_PER_ELEMENT},c.indexView=R,f.addBuffer(B))}}e=new cc_1.Mesh;e.reset({struct:u,data:f.getCombined()}),e.hash;return e}async function compressMesh(e,t){return await tryInitMeshOpt(),t?(t?.quantize&&(e=await quantizeMesh(e)),t?.encode&&(e=await encodeMesh(e)),t?.compress&&(e=await deflateMesh(e))):console.warn("Mesh compression is not enabled, original mesh will be returned."),e}async function encodeMesh(t){if(await tryInitMeshOpt(),t.struct.encoded)return t;var e=JSON.parse(JSON.stringify(t.struct)),r=new gltf_converter_1.BufferBlob;r.setNextAlignment(0);for(const l of e.vertexBundles){var n=l.view,i=new Uint8Array(t.data.buffer,n.offset,n.length),o=meshopt_encoder_1.default.optimizer.encodeVertexBufferBound(n.count,n.stride),s=new Uint8Array(o),o=meshopt_encoder_1.default.optimizer.encodeVertexBuffer(s,o,i,n.count,n.stride),s=new Uint8Array(s.buffer,0,o),i=(r.setNextAlignment(n.stride),{offset:r.getLength(),length:s.byteLength,count:n.count,stride:n.stride});l.view=i,r.addBuffer(s)}for(const g of e.primitives)if(void 0!==g.indexView){var a=g.indexView;let e=new Uint8Array;if(2===a.stride){var f=new Uint16Array(t.data.buffer,a.offset,a.count),u=new Uint32Array(a.count*Uint32Array.BYTES_PER_ELEMENT);for(let e=0;e<a.count;++e)u[e]=f[e];e=new Uint8Array(u.buffer,0,a.count*Uint32Array.BYTES_PER_ELEMENT)}else 4===a.stride&&(e=new Uint8Array(t.data.buffer,a.offset,a.count*Uint32Array.BYTES_PER_ELEMENT));var c=meshopt_encoder_1.default.optimizer.encodeIndexBufferBound(a.count,a.count),d=new Uint8Array(c),c=meshopt_encoder_1.default.optimizer.encodeIndexBuffer(d,c,e,a.count),d=new Uint8Array(d.buffer,0,c),c=(r.setNextAlignment(Uint32Array.BYTES_PER_ELEMENT),{offset:r.getLength(),length:d.byteLength,count:a.count,stride:Uint32Array.BYTES_PER_ELEMENT});g.indexView=c,r.addBuffer(d)}var m=new cc_1.Mesh;m.reset({struct:e,data:r.getCombined()}),m.struct.encoded=!0,m.hash;return m}exports.clusterizeMesh=clusterizeMesh,exports.getDefaultSimplifyOptions=getDefaultSimplifyOptions,exports.simplifyMesh=simplifyMesh,exports.compressMesh=compressMesh,exports.encodeMesh=encodeMesh;const quantizeConfiguration=new Map([[cc_1.gfx.AttributeName.ATTR_POSITION,{enum:0,size:6,format:cc_1.gfx.Format.RGB16F,origin:cc_1.gfx.Format.RGB32F}],[cc_1.gfx.AttributeName.ATTR_NORMAL,{enum:1,size:6,format:cc_1.gfx.Format.RGB16F,origin:cc_1.gfx.Format.RGB32F}],[cc_1.gfx.AttributeName.ATTR_TANGENT,{enum:2,size:8,format:cc_1.gfx.Format.RGBA16F,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_BITANGENT,{enum:2,size:8,format:cc_1.gfx.Format.RGBA16F,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_COLOR,{enum:3,size:4,format:cc_1.gfx.Format.RGBA8,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_COLOR1,{enum:3,size:4,format:cc_1.gfx.Format.RGBA8,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_COLOR2,{enum:3,size:4,format:cc_1.gfx.Format.RGBA8,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_JOINTS,{enum:4,size:16,format:cc_1.gfx.Format.RGBA32F,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_WEIGHTS,{enum:5,size:16,format:cc_1.gfx.Format.RGBA32F,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD1,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD2,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD3,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD4,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD5,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD6,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD7,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD8,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_BATCH_ID,{enum:7,size:4,format:cc_1.gfx.Format.R32F,origin:cc_1.gfx.Format.R32F}],[cc_1.gfx.AttributeName.ATTR_BATCH_UV,{enum:8,size:8,format:cc_1.gfx.Format.RG32F,origin:cc_1.gfx.Format.RG32F}]]);function quantizeSize(t){let r=0;for(let e=0;e<t.length;++e){var n=t[e],i=n.name,o=quantizeConfiguration.get(i);if(void 0===o)return void console.log(`Attribute ${i} is not supported for quantization.`);if(r+=o.size,o.origin!==n.format)return void console.warn(`Attribute ${i} has different format from origin, quantization may not work.`);n.format=o.format}return r}function mapAttribute(e){return e.map(e=>{var e=e.name,t=quantizeConfiguration.get(e);return void 0===t&&console.error(`Attribute ${e} is not supported for quantization.`),t.enum})}async function quantizeMesh(t){if(t.struct.quantized)return t;var r=new gltf_converter_1.BufferBlob,n=(r.setNextAlignment(0),JSON.parse(JSON.stringify(t.struct)));for(let e=0;e<n.vertexBundles.length;++e){var i=n.vertexBundles[e],o=i.view,s=JSON.parse(JSON.stringify(i.attributes)),a=quantizeSize(s);if(!a)return t;var f=new Uint8Array(t.data.buffer,o.offset,o.length),u=mapAttribute(s),c=new Uint8Array(a*o.count),f=(meshopt_encoder_1.default.optimizer.quantizeMesh(c,c.byteLength,f,o.count,o.stride,Uint32Array.from(u),u.length),r.setNextAlignment(a),{offset:r.getLength(),length:c.byteLength,count:o.count,stride:a});i.view=f,i.attributes=s,r.addBuffer(c)}for(let e=0;e<n.primitives.length;++e){var d,m,l=n.primitives[e];void 0!==l.indexView&&(m=l.indexView,d=new Uint8Array(t.data.buffer,m.offset,m.length),r.setNextAlignment(m.stride),m={offset:r.getLength(),length:d.byteLength,count:m.count,stride:m.stride},l.indexView=m,r.addBuffer(d))}var e=new cc_1.Mesh;e.reset({struct:n,data:r.getCombined()}),e.struct.quantized=!0,e.hash;return e}async function deflateMesh(e){var t,r;return e.struct.compressed?e:(t=e.data,t=zlib_1.default.deflateSync(t),(e=JSON.parse(JSON.stringify(e.struct))).compressed=!0,(r=new cc_1.Mesh).reset({struct:e,data:t}),r.hash,r)}exports.quantizeMesh=quantizeMesh,exports.deflateMesh=deflateMesh;