"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getNormalizer=exports.getGfxAttributeName=exports.PPGeometry=void 0;const cc_1=require("cc");function getMergedSetSize(t,e){let r=t.size;for(const i of e)t.has(i)||r++;return r}function mergeSets(t,e){var r=new Set;for(const i of t)r.add(i);for(const n of e)r.add(n);return r}function isStrictSubSet(t,e){for(const r of e)if(!t.has(r))return!1;return!0}class PPGeometry{static skinningProcess(e,r){var i=[],n=[],o=cc_1.pipeline.JOINT_UNIFORM_CAPACITY;for(let t=0;t<e.length;t++){var s=e[t];if(r||!s._jointSet||s._jointSet.size<=o)i.push(s),n.push(t);else{var a=s.getAttribute(PPGeometry.StdSemantics.joints).data,c=s._getTriangleIndices(),a=EditorExtends.GeometryUtils.splitBasedOnJoints(a,c,s.primitiveMode,o);if(a.length)for(const _ of a){const A=Array.from(_.indices.reduce((t,e)=>t.add(e),new Set).values()),P=new(EditorExtends.GeometryUtils.getUintArrayCtor(A.length))(_.indices.length),x=(_.indices.forEach((t,e)=>P[e]=A.indexOf(t)),new PPGeometry(A.length,_.primitiveMode,P,_.jointSet));s.forEachAttribute(e=>{var t=e["semantic"];const i=e.components,n=e.data,o=new n.constructor(A.length*i);if(A.forEach((e,r)=>{for(let t=0;t<i;t++)o[r*i+t]=n[e*i+t]}),x.setAttribute(t,o,i,e.isNormalized),e.morphs){var r=x.getAttribute(t);r.morphs=new Array(e.morphs.length);for(let t=0;t<e.morphs.length;++t){const i=3,n=e.morphs[t],s=new n.constructor(3*A.length);A.forEach((e,r)=>{for(let t=0;t<3;++t)s[3*r+t]=n[3*e+t]}),r.morphs[t]=s}}}),i.push(x),n.push(t)}else i.push(s),n.push(t)}}var m=i.reduce((t,e)=>(e._jointSet&&t.push(e._jointSet),t),[]);let u=1<m.length;for(;u;){u=!1;let r=1/0,i=-1,n=-1;for(let e=0;e<m.length;e++){var d=m[e];for(let t=e+1;t<m.length;t++){var f=m[t],h=getMergedSetSize(d,f);h<=o&&(h=Math.min(Math.abs(h-d.size),Math.abs(h-f.size)))<r&&(u=!0,r=h,i=e,n=t)}}if(u){var t=m[i],l=m[n];if(m[i]=mergeSets(t,l),m[n]=m[m.length-1],--m.length<=1)break;r=1/0}}let S=m.map(t=>Array.from(t.values()).sort((t,e)=>t-e));if(!S.length||S.every(t=>1===t.length&&!t[0]))S=void 0;else for(let t=0;t<i.length;t++){var g=i[t];const y=g._jointSet;y&&(g._jointMapIndex=m.findIndex(t=>isStrictSubSet(t,y)))}return{geometries:i,materialIndices:n,jointMaps:S}}get vertexCount(){return this._vertexCount}get indices(){return this._indices}get primitiveMode(){return this._primitiveMode}get jointMapIndex(){return this._jointMapIndex}constructor(t,e,r,i){this._vertices={},this._vertexCount=t,this._primitiveMode=e,this._jointSet=i,r&&r.BYTES_PER_ELEMENT<Uint16Array.BYTES_PER_ELEMENT&&(r=Uint16Array.from(r)),this._indices=r}calculateNormals(t=Float32Array){var e=this._assertAttribute(PPGeometry.StdSemantics.position).data,r=this._getTriangleIndices(),t=new t(3*this._vertexCount);return EditorExtends.GeometryUtils.calculateNormals(e,r,t)}calculateTangents(t=Float32Array,e=0){var r=this._assertAttribute(PPGeometry.StdSemantics.position).data,i=this._getTriangleIndices(),n=this._assertAttribute(PPGeometry.StdSemantics.normal).data,e=this._assertAttribute(PPGeometry.StdSemantics.set(PPGeometry.StdSemantics.texcoord,e)).data,t=new t(4*this._vertexCount);return EditorExtends.GeometryUtils.calculateTangents(r,i,n,e,t)}sanityCheck(){if(this.hasAttribute(PPGeometry.StdSemantics.weights)&&this.hasAttribute(PPGeometry.StdSemantics.joints)){var n=this.getAttribute(PPGeometry.StdSemantics.weights),r=this.getAttribute(PPGeometry.StdSemantics.joints),t=this.vertexCount;if(r.data.constructor!==Uint16Array){var e=new Uint16Array(r.data.length);for(let t=0;t<e.length;t++)e[t]=r.data[t];r.data=e}var[o,s]=getTargetJointWeightCheckParams(n.data.constructor);for(let i=0;i<t;++i){let r=0;for(let e=0;e<n.components;e++){let t=n.data[n.components*i+e];Number.isNaN(t)&&(t=n.data[n.components*i+e]=o-s),r+=t+s}if(r!==o&&0!==r)if(1===o)for(let t=0;t<n.components;t++)n.data[n.components*i+t]*=o/r;else{var a=[];for(let t=0;t<n.components;t++)a.push((n.data[n.components*i+t]+s)/r);let e=0;for(let t=0;t<n.components;t++){var c=a[t],m=(0,cc_1.clamp)(Math.floor((c+e)*o),0,o);e=c-m/o,n.data[n.components*i+t]=m-s}}}this._jointSet=new Set,this._jointSet.add(0);for(let e=0;e<t;++e)for(let t=0;t<r.components;t++)0<n.data[r.components*e+t]?this._jointSet.add(r.data[r.components*e+t]):r.data[r.components*e+t]=0}}getAttribute(t){return this._vertices[t]}hasAttribute(t){return t in this._vertices}deleteAttribute(t){delete this._vertices[t]}setAttribute(t,e,r,i){if(void 0===i)if(e.constructor===Float32Array)i=!1;else if("number"==typeof t)switch(PPGeometry.StdSemantics.decode(t).semantic0){case PPGeometry.StdSemantics.texcoord:case PPGeometry.StdSemantics.color:case PPGeometry.StdSemantics.weights:i=!0}this._vertices[t]=new PPGeometry.Attribute(t,e,r,i)}*attributes(){yield*Object.values(this._vertices)}forEachAttribute(t){Object.values(this._vertices).forEach(t)}reduceJointInfluences(){r=PPGeometry.StdSemantics.joints;var r,t=Object.values(this._vertices).reduce((t,e)=>t+(equalStdSemantic(e.semantic,r)?1:0),0);if(!(t<=1)){let t;for(const f of Object.values(this._vertices))if(equalStdSemantic(f.semantic,PPGeometry.StdSemantics.weights)){var e=f.data.constructor;if(t){if(t!==e)return void console.error("All weights attribute should be of same component type.")}else t=e}if(t){var i=new Uint16Array(4*this._vertexCount),n=new t(4*this._vertexCount);for(const h of Object.values(this._vertices))if(PPGeometry.isStdSemantic(h.semantic)){var{semantic0:o,set:s}=PPGeometry.StdSemantics.decode(h.semantic);if(o===PPGeometry.StdSemantics.joints){o=PPGeometry.StdSemantics.set(PPGeometry.StdSemantics.weights,s);if(o in this._vertices){var a=h,c=this._vertices[o].data;for(let t=0;t<4;++t)for(let e=0;e<this._vertexCount;++e){var m=4*e+t,u=c[m];for(let t=0;t<4;++t){var d=4*e+t;if(u>=n[d]){for(let t=4*(e+1)-1-1;t>=d;--t)n[t+1]=n[t],i[t+1]=i[t];n[d]=u,i[d]=a.data[m];break}}}this.deleteAttribute(h.semantic),this.deleteAttribute(o)}else console.error(`Vertex attribute joints-${s} has no corresponding weights attribute`)}}for(let r=0;r<this._vertexCount;++r){let e=0;for(let t=0;t<4;++t)e+=n[4*r+t];if(0!==e)for(let t=0;t<4;++t)n[4*r+t]/=e}this.setAttribute(PPGeometry.StdSemantics.set(PPGeometry.StdSemantics.joints,0),i,4),this.setAttribute(PPGeometry.StdSemantics.set(PPGeometry.StdSemantics.weights,0),n,4)}else console.error("The number of joints attribute and weights attribute are not matched.")}}_getTriangleIndices(){if(this._primitiveMode!==cc_1.gfx.PrimitiveMode.TRIANGLE_LIST)throw new Error("Triangles expected.");return this._indices||this._generatedIndices||(this._generatedIndices=(()=>{var e=new(this._vertexCount>=1<<8*Uint16Array.BYTES_PER_ELEMENT?Uint32Array:Uint16Array)(this._vertexCount);for(let t=0;t<this._vertexCount;++t)e[t]=t;return e})())}_assertAttribute(e){if(this.hasAttribute(e))return this.getAttribute(e);{let t;var r,i;throw PPGeometry.isStdSemantic(e)?({semantic0:r,set:i}=PPGeometry.StdSemantics.decode(e),t=""+PPGeometry.StdSemantics[r],0!==i&&(t+=`(set ${i})`)):t=e,new Error(t+" attribute is expect but not present")}}}function getTargetJointWeightCheckParams(t){switch(t){case Int8Array:return[255,128];case Uint8Array:return[255,0];case Int16Array:return[65535,32768];case Uint16Array:return[65535,0];case Int32Array:return[4294967295,2147483648];case Uint32Array:return[4294967295,0];case Float32Array:return[1,0]}return[1,0]}exports.PPGeometry=PPGeometry,function(t){var e;(e=t.StdSemantics||(t.StdSemantics={}))[e.position=0]="position",e[e.normal=1]="normal",e[e.texcoord=2]="texcoord",e[e.tangent=3]="tangent",e[e.joints=4]="joints",e[e.weights=5]="weights",e[e.color=6]="color",(e=t.StdSemantics||(t.StdSemantics={})).set=function(t,e){return(e<<4)+t},e.decode=function(t){return{semantic0:15&t,set:t>>4}},t.isStdSemantic=function(t){return"number"==typeof t};t.Attribute=class{constructor(t,e,r,i=!1){this.morphs=null,this.semantic=t,this.data=e,this.components=r,this.isNormalized=i}getGFXFormat(){var t=attributeFormatMap.get(this.data.constructor);if(void 0!==t&&this.components in t)return t[this.components];throw new Error("No corresponding gfx format for attribute.")}}}(PPGeometry=exports.PPGeometry||(exports.PPGeometry={}));const stdSemanticInfoMap={[PPGeometry.StdSemantics.position]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_POSITION,components:3},[PPGeometry.StdSemantics.normal]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_NORMAL,components:3},[PPGeometry.StdSemantics.texcoord]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_TEX_COORD,components:2,multisets:{1:cc_1.gfx.AttributeName.ATTR_TEX_COORD1,2:cc_1.gfx.AttributeName.ATTR_TEX_COORD2,3:cc_1.gfx.AttributeName.ATTR_TEX_COORD3,4:cc_1.gfx.AttributeName.ATTR_TEX_COORD4,5:cc_1.gfx.AttributeName.ATTR_TEX_COORD5,6:cc_1.gfx.AttributeName.ATTR_TEX_COORD6,7:cc_1.gfx.AttributeName.ATTR_TEX_COORD7,8:cc_1.gfx.AttributeName.ATTR_TEX_COORD8}},[PPGeometry.StdSemantics.tangent]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_TANGENT,components:4},[PPGeometry.StdSemantics.joints]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_JOINTS,components:4},[PPGeometry.StdSemantics.weights]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_WEIGHTS,components:4},[PPGeometry.StdSemantics.color]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_COLOR,components:[3,4]}},attributeFormatMap=new Map([[Int8Array,{1:cc_1.gfx.Format.R8SN,2:cc_1.gfx.Format.RG8SN,3:cc_1.gfx.Format.RGB8SN,4:cc_1.gfx.Format.RGBA8SN}],[Uint8Array,{1:cc_1.gfx.Format.R8,2:cc_1.gfx.Format.RG8,3:cc_1.gfx.Format.RGB8,4:cc_1.gfx.Format.RGBA8}],[Int16Array,{1:cc_1.gfx.Format.R16I,2:cc_1.gfx.Format.RG16I,3:cc_1.gfx.Format.RGB16I,4:cc_1.gfx.Format.RGBA16I}],[Uint16Array,{1:cc_1.gfx.Format.R16UI,2:cc_1.gfx.Format.RG16UI,3:cc_1.gfx.Format.RGB16UI,4:cc_1.gfx.Format.RGBA16UI}],[Int32Array,{1:cc_1.gfx.Format.R32I,2:cc_1.gfx.Format.RG32I,3:cc_1.gfx.Format.RGB32I,4:cc_1.gfx.Format.RGBA32I}],[Uint32Array,{1:cc_1.gfx.Format.R32UI,2:cc_1.gfx.Format.RG32UI,3:cc_1.gfx.Format.RGB32UI,4:cc_1.gfx.Format.RGBA32UI}],[Float32Array,{1:cc_1.gfx.Format.R32F,2:cc_1.gfx.Format.RG32F,3:cc_1.gfx.Format.RGB32F,4:cc_1.gfx.Format.RGBA32F}]]);function getGfxAttributeName(t){var e=t["semantic"];let r;if(PPGeometry.isStdSemantic(e)){var{semantic0:i,set:n}=PPGeometry.StdSemantics.decode(e),o=stdSemanticInfoMap[i];if(!(Array.isArray(o.components)?o.components.includes(t.components):o.components===t.components))throw new Error(`Mismatched ${PPGeometry.StdSemantics[i]} components, expect ${o.components}.`);if(0===n)r=o.gfxAttributeName;else{if(!(o.multisets&&n in o.multisets))throw new Error(PPGeometry.StdSemantics[i]+` doesn't allow set ${n}.`);r=o.multisets[n]}}else r=e;return r}exports.getGfxAttributeName=getGfxAttributeName,exports.getNormalizer=(()=>{const e=t=>t/255,r=t=>t/65535,i=t=>t/(2**32-1),n=t=>Math.max(t/127,-1),o=t=>Math.max(t/32767,-1),s=t=>Math.max(t/(2**31-1),-1);return t=>{switch(!0){case t instanceof Int8Array:return n;case t instanceof Int16Array:return o;case t instanceof Int32Array:return s;case t instanceof Uint8Array:return e;case t instanceof Uint16Array:return r;case t instanceof Uint32Array:return i;default:return null}}})();const equalStdSemantic=(t,e)=>PPGeometry.isStdSemantic(t)&&PPGeometry.StdSemantics.decode(t).semantic0===e;